
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002b9 	.word	0x080002b9
 8000008:	080002bb 	.word	0x080002bb
 800000c:	080002bb 	.word	0x080002bb
 8000010:	080002bb 	.word	0x080002bb
 8000014:	080002bb 	.word	0x080002bb
 8000018:	080002bb 	.word	0x080002bb
 800001c:	080002bb 	.word	0x080002bb
 8000020:	080002bb 	.word	0x080002bb
 8000024:	080002bb 	.word	0x080002bb
 8000028:	080002bb 	.word	0x080002bb
 800002c:	080002c1 	.word	0x080002c1
 8000030:	080002bb 	.word	0x080002bb
 8000034:	080002bb 	.word	0x080002bb
 8000038:	080002df 	.word	0x080002df
 800003c:	080002bb 	.word	0x080002bb
 8000040:	080002bb 	.word	0x080002bb
 8000044:	080002bb 	.word	0x080002bb
 8000048:	080002bb 	.word	0x080002bb
 800004c:	080002bb 	.word	0x080002bb
 8000050:	080002bb 	.word	0x080002bb
 8000054:	080002bb 	.word	0x080002bb
 8000058:	08002001 	.word	0x08002001
 800005c:	08002081 	.word	0x08002081
 8000060:	080020f1 	.word	0x080020f1
 8000064:	08002161 	.word	0x08002161
 8000068:	080021d1 	.word	0x080021d1
 800006c:	080002bb 	.word	0x080002bb
 8000070:	080002bb 	.word	0x080002bb
 8000074:	080002bb 	.word	0x080002bb
 8000078:	080002bb 	.word	0x080002bb
 800007c:	080002bb 	.word	0x080002bb
 8000080:	080002bb 	.word	0x080002bb
 8000084:	080002bb 	.word	0x080002bb
 8000088:	080002bb 	.word	0x080002bb
 800008c:	080002bb 	.word	0x080002bb
 8000090:	080002bb 	.word	0x080002bb
 8000094:	080002bb 	.word	0x080002bb
 8000098:	080002bb 	.word	0x080002bb
 800009c:	08002241 	.word	0x08002241
 80000a0:	080002bb 	.word	0x080002bb
 80000a4:	080002bb 	.word	0x080002bb
 80000a8:	080002bb 	.word	0x080002bb
 80000ac:	080002bb 	.word	0x080002bb
 80000b0:	08002881 	.word	0x08002881
 80000b4:	080029c1 	.word	0x080029c1
 80000b8:	080002bb 	.word	0x080002bb
 80000bc:	080002bb 	.word	0x080002bb
 80000c0:	080002bb 	.word	0x080002bb
 80000c4:	080002bb 	.word	0x080002bb
 80000c8:	080002bb 	.word	0x080002bb
 80000cc:	080002bb 	.word	0x080002bb
 80000d0:	080002bb 	.word	0x080002bb
 80000d4:	08002671 	.word	0x08002671
 80000d8:	08002691 	.word	0x08002691
 80000dc:	080002bb 	.word	0x080002bb
 80000e0:	08002421 	.word	0x08002421
 80000e4:	080002bb 	.word	0x080002bb
 80000e8:	080002bb 	.word	0x080002bb
 80000ec:	080002bb 	.word	0x080002bb
 80000f0:	080002bb 	.word	0x080002bb
 80000f4:	080002bb 	.word	0x080002bb
 80000f8:	080002bb 	.word	0x080002bb
 80000fc:	080002bb 	.word	0x080002bb
 8000100:	080002bb 	.word	0x080002bb
 8000104:	080002bb 	.word	0x080002bb
 8000108:	080002bb 	.word	0x080002bb
 800010c:	080002bb 	.word	0x080002bb
 8000110:	080002bb 	.word	0x080002bb
 8000114:	080002bb 	.word	0x080002bb
 8000118:	080002bb 	.word	0x080002bb
 800011c:	080002bb 	.word	0x080002bb
 8000120:	080002bb 	.word	0x080002bb
 8000124:	080002bb 	.word	0x080002bb
 8000128:	080002bb 	.word	0x080002bb
 800012c:	080002bb 	.word	0x080002bb
 8000130:	080002bb 	.word	0x080002bb
 8000134:	080002bb 	.word	0x080002bb
 8000138:	080002bb 	.word	0x080002bb
 800013c:	080002bb 	.word	0x080002bb
 8000140:	080002bb 	.word	0x080002bb
 8000144:	080002bb 	.word	0x080002bb
 8000148:	080002bb 	.word	0x080002bb
 800014c:	080002bb 	.word	0x080002bb
 8000150:	080002bb 	.word	0x080002bb
 8000154:	080002bb 	.word	0x080002bb
 8000158:	080002bb 	.word	0x080002bb
 800015c:	080002bb 	.word	0x080002bb
 8000160:	080002bb 	.word	0x080002bb
 8000164:	080002bb 	.word	0x080002bb
 8000168:	080002bb 	.word	0x080002bb
 800016c:	080002bb 	.word	0x080002bb
 8000170:	080002bb 	.word	0x080002bb
 8000174:	080002bb 	.word	0x080002bb
 8000178:	080002bb 	.word	0x080002bb
 800017c:	080002bb 	.word	0x080002bb
 8000180:	080002bb 	.word	0x080002bb
 8000184:	080002bb 	.word	0x080002bb
 8000188:	080002bb 	.word	0x080002bb
 800018c:	080002bb 	.word	0x080002bb
 8000190:	080002bb 	.word	0x080002bb
 8000194:	080002bb 	.word	0x080002bb
 8000198:	080002bb 	.word	0x080002bb
 800019c:	080002bb 	.word	0x080002bb
 80001a0:	080002bb 	.word	0x080002bb
 80001a4:	080002bb 	.word	0x080002bb
 80001a8:	080002bb 	.word	0x080002bb
 80001ac:	080026b1 	.word	0x080026b1
 80001b0:	080002bb 	.word	0x080002bb
 80001b4:	080002bb 	.word	0x080002bb
 80001b8:	080002bb 	.word	0x080002bb
 80001bc:	080002bb 	.word	0x080002bb
 80001c0:	080002bb 	.word	0x080002bb
 80001c4:	080002bb 	.word	0x080002bb
 80001c8:	080002bb 	.word	0x080002bb
 80001cc:	080002bb 	.word	0x080002bb
 80001d0:	080002bb 	.word	0x080002bb
 80001d4:	080002bb 	.word	0x080002bb
 80001d8:	080002bb 	.word	0x080002bb
 80001dc:	080002bb 	.word	0x080002bb

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4826      	ldr	r0, [pc, #152]	; (800027c <endfiniloop+0x6>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4825      	ldr	r0, [pc, #148]	; (8000280 <endfiniloop+0xa>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 80001ee:	4825      	ldr	r0, [pc, #148]	; (8000284 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 80001f0:	4925      	ldr	r1, [pc, #148]	; (8000288 <endfiniloop+0x12>)
                str     r0, [r1]
 80001f2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001f4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001f6:	f380 8814 	msr	CONTROL, r0
                isb
 80001fa:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80001fe:	f001 feaf 	bl	8001f60 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000202:	f002 fc15 	bl	8002a30 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000206:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800020a:	4920      	ldr	r1, [pc, #128]	; (800028c <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 800020c:	4a1b      	ldr	r2, [pc, #108]	; (800027c <endfiniloop+0x6>)

0800020e <msloop>:
msloop:
                cmp     r1, r2
 800020e:	4291      	cmp	r1, r2
                itt     lo
 8000210:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000212:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000216:	e7fa      	bcc.n	800020e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000218:	491d      	ldr	r1, [pc, #116]	; (8000290 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 800021a:	4a19      	ldr	r2, [pc, #100]	; (8000280 <endfiniloop+0xa>)

0800021c <psloop>:
psloop:
                cmp     r1, r2
 800021c:	4291      	cmp	r1, r2
                itt     lo
 800021e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000220:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000224:	e7fa      	bcc.n	800021c <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 8000226:	491b      	ldr	r1, [pc, #108]	; (8000294 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 8000228:	4a1b      	ldr	r2, [pc, #108]	; (8000298 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 800022a:	4b1c      	ldr	r3, [pc, #112]	; (800029c <endfiniloop+0x26>)

0800022c <dloop>:
dloop:
                cmp     r2, r3
 800022c:	429a      	cmp	r2, r3
                ittt    lo
 800022e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000230:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000234:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000238:	e7f8      	bcc.n	800022c <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800023a:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 800023c:	4918      	ldr	r1, [pc, #96]	; (80002a0 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 800023e:	4a19      	ldr	r2, [pc, #100]	; (80002a4 <endfiniloop+0x2e>)

08000240 <bloop>:
bloop:
                cmp     r1, r2
 8000240:	4291      	cmp	r1, r2
                itt     lo
 8000242:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000244:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000248:	e7fa      	bcc.n	8000240 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800024a:	f001 fea1 	bl	8001f90 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800024e:	f001 fe8f 	bl	8001f70 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000252:	4c15      	ldr	r4, [pc, #84]	; (80002a8 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000254:	4d15      	ldr	r5, [pc, #84]	; (80002ac <endfiniloop+0x36>)

08000256 <initloop>:
initloop:
                cmp     r4, r5
 8000256:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000258:	da03      	bge.n	8000262 <endinitloop>
                ldr     r1, [r4], #4
 800025a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800025e:	4788      	blx	r1
                b       initloop
 8000260:	e7f9      	b.n	8000256 <initloop>

08000262 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000262:	f002 fdd5 	bl	8002e10 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 8000266:	4c12      	ldr	r4, [pc, #72]	; (80002b0 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 8000268:	4d12      	ldr	r5, [pc, #72]	; (80002b4 <endfiniloop+0x3e>)

0800026a <finiloop>:
finiloop:
                cmp     r4, r5
 800026a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800026c:	da03      	bge.n	8000276 <endfiniloop>
                ldr     r1, [r4], #4
 800026e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000272:	4788      	blx	r1
                b       finiloop
 8000274:	e7f9      	b.n	800026a <finiloop>

08000276 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000276:	f001 be83 	b.w	8001f80 <__default_exit>
 800027a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 800027c:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000280:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000284:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000288:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800028c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000290:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000294:	080034f4 	.word	0x080034f4
                ldr     r2, =__data_base__
 8000298:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800029c:	20000858 	.word	0x20000858
                ldr     r1, =__bss_base__
 80002a0:	20000858 	.word	0x20000858
                ldr     r2, =__bss_end__
 80002a4:	200010c8 	.word	0x200010c8
                ldr     r4, =__init_array_base__
 80002a8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 80002ac:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_base__
 80002b0:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 80002b4:	080001e0 	.word	0x080001e0

080002b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002b8:	e792      	b.n	80001e0 <_crt0_entry>

080002ba <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80002ba:	f000 f800 	bl	80002be <_unhandled_exception>

080002be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002be:	e7fe      	b.n	80002be <_unhandled_exception>

080002c0 <SVC_Handler>:
 * Performs a context switch between two threads using SVC.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  SVC_Handler
SVC_Handler:
                mrs     r2, PSP
 80002c0:	f3ef 8209 	mrs	r2, PSP

ctxswitch:
                /* SVC called from privilege mode for context switch.*/
#endif
                /* Context store for old thread through R1.*/
                adds    r1, #CONTEXT_OFFSET
 80002c4:	310c      	adds	r1, #12

                mrs     r3, BASEPRI
 80002c6:	f3ef 8311 	mrs	r3, BASEPRI
                PORT_STORE_INTEGER_CONTEXT
 80002ca:	e8a1 4ffc 	stmia.w	r1!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
                PORT_STORE_FLOAT_CONTEXT
                PORT_STORE_MPU_CONTEXT

                /* Context load for new thread through R0.*/
                adds    r0, #CONTEXT_OFFSET
 80002ce:	300c      	adds	r0, #12
#endif
                mov     r0, r4
1:
#endif /* CH_DBG_SYSTEM_STATE_CHECK || CH_DBG_STATISTICS */

                PORT_LOAD_INTEGER_CONTEXT
 80002d0:	e8b0 4ffc 	ldmia.w	r0!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002d4:	f382 8809 	msr	PSP, r2
 80002d8:	f383 8811 	msr	BASEPRI, r3
                PORT_LOAD_FLOAT_CONTEXT
                PORT_LOAD_MPU_CONTEXT

                bx      lr
 80002dc:	4770      	bx	lr

080002de <PendSV_Handler>:
 * Tail preemption check using PENDSV.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  PendSV_Handler
PendSV_Handler:
                mrs     r3, BASEPRI
 80002de:	f3ef 8311 	mrs	r3, BASEPRI
                push    {r3, lr}
 80002e2:	b508      	push	{r3, lr}

                bl      __port_schedule_next
 80002e4:	f002 fd64 	bl	8002db0 <__port_schedule_next>
                cmp     r0, #0
 80002e8:	2800      	cmp	r0, #0
                it      eq
 80002ea:	bf08      	it	eq
                popeq   {r3, pc}
 80002ec:	bd08      	popeq	{r3, pc}
                pop     {r3, lr}
 80002ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

                /* Context store for old thread through R1.*/
                adds    r1, #CONTEXT_OFFSET
 80002f2:	310c      	adds	r1, #12

                mrs     r2, PSP
 80002f4:	f3ef 8209 	mrs	r2, PSP
#if PORT_USE_SYSCALL
                mrs     r12, CONTROL
#endif
                PORT_STORE_INTEGER_CONTEXT
 80002f8:	e8a1 4ffc 	stmia.w	r1!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
                PORT_STORE_FLOAT_CONTEXT
                PORT_STORE_MPU_CONTEXT

                /* Context load for new thread through R0.*/
                adds    r0, #CONTEXT_OFFSET
 80002fc:	300c      	adds	r0, #12
#endif
                mov     r0, r4
1:
#endif /* CH_DBG_SYSTEM_STATE_CHECK || CH_DBG_STATISTICS */

                PORT_LOAD_INTEGER_CONTEXT
 80002fe:	e8b0 4ffc 	ldmia.w	r0!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000302:	f382 8809 	msr	PSP, r2
 8000306:	f383 8811 	msr	BASEPRI, r3
                PORT_LOAD_FLOAT_CONTEXT
                PORT_LOAD_MPU_CONTEXT

                bx      lr
 800030a:	4770      	bx	lr

0800030c <__port_thread_start>:
                bl      __dbg_check_unlock
#endif
#if CH_DBG_STATISTICS
                bl      __stats_stop_measure_crit_thd
#endif
                movs    r3, #CORTEX_BASEPRI_DISABLED
 800030c:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 800030e:	f383 8811 	msr	BASEPRI, r3
                mov     r0, r5
 8000312:	4628      	mov	r0, r5
                blx     r4
 8000314:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 8000316:	2000      	movs	r0, #0
                bl      chThdExit
 8000318:	f002 fd02 	bl	8002d20 <chThdExit>

0800031c <.zombies>:
.zombies:       b       .zombies
 800031c:	e7fe      	b.n	800031c <.zombies>
	...

08000320 <memcpy>:
 8000320:	4684      	mov	ip, r0
 8000322:	ea41 0300 	orr.w	r3, r1, r0
 8000326:	f013 0303 	ands.w	r3, r3, #3
 800032a:	d16d      	bne.n	8000408 <memcpy+0xe8>
 800032c:	3a40      	subs	r2, #64	; 0x40
 800032e:	d341      	bcc.n	80003b4 <memcpy+0x94>
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	f851 3b04 	ldr.w	r3, [r1], #4
 800038c:	f840 3b04 	str.w	r3, [r0], #4
 8000390:	f851 3b04 	ldr.w	r3, [r1], #4
 8000394:	f840 3b04 	str.w	r3, [r0], #4
 8000398:	f851 3b04 	ldr.w	r3, [r1], #4
 800039c:	f840 3b04 	str.w	r3, [r0], #4
 80003a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a4:	f840 3b04 	str.w	r3, [r0], #4
 80003a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003ac:	f840 3b04 	str.w	r3, [r0], #4
 80003b0:	3a40      	subs	r2, #64	; 0x40
 80003b2:	d2bd      	bcs.n	8000330 <memcpy+0x10>
 80003b4:	3230      	adds	r2, #48	; 0x30
 80003b6:	d311      	bcc.n	80003dc <memcpy+0xbc>
 80003b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003bc:	f840 3b04 	str.w	r3, [r0], #4
 80003c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c4:	f840 3b04 	str.w	r3, [r0], #4
 80003c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003cc:	f840 3b04 	str.w	r3, [r0], #4
 80003d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d4:	f840 3b04 	str.w	r3, [r0], #4
 80003d8:	3a10      	subs	r2, #16
 80003da:	d2ed      	bcs.n	80003b8 <memcpy+0x98>
 80003dc:	320c      	adds	r2, #12
 80003de:	d305      	bcc.n	80003ec <memcpy+0xcc>
 80003e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003e4:	f840 3b04 	str.w	r3, [r0], #4
 80003e8:	3a04      	subs	r2, #4
 80003ea:	d2f9      	bcs.n	80003e0 <memcpy+0xc0>
 80003ec:	3204      	adds	r2, #4
 80003ee:	d008      	beq.n	8000402 <memcpy+0xe2>
 80003f0:	07d2      	lsls	r2, r2, #31
 80003f2:	bf1c      	itt	ne
 80003f4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003f8:	f800 3b01 	strbne.w	r3, [r0], #1
 80003fc:	d301      	bcc.n	8000402 <memcpy+0xe2>
 80003fe:	880b      	ldrh	r3, [r1, #0]
 8000400:	8003      	strh	r3, [r0, #0]
 8000402:	4660      	mov	r0, ip
 8000404:	4770      	bx	lr
 8000406:	bf00      	nop
 8000408:	2a08      	cmp	r2, #8
 800040a:	d313      	bcc.n	8000434 <memcpy+0x114>
 800040c:	078b      	lsls	r3, r1, #30
 800040e:	d08d      	beq.n	800032c <memcpy+0xc>
 8000410:	f010 0303 	ands.w	r3, r0, #3
 8000414:	d08a      	beq.n	800032c <memcpy+0xc>
 8000416:	f1c3 0304 	rsb	r3, r3, #4
 800041a:	1ad2      	subs	r2, r2, r3
 800041c:	07db      	lsls	r3, r3, #31
 800041e:	bf1c      	itt	ne
 8000420:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000424:	f800 3b01 	strbne.w	r3, [r0], #1
 8000428:	d380      	bcc.n	800032c <memcpy+0xc>
 800042a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800042e:	f820 3b02 	strh.w	r3, [r0], #2
 8000432:	e77b      	b.n	800032c <memcpy+0xc>
 8000434:	3a04      	subs	r2, #4
 8000436:	d3d9      	bcc.n	80003ec <memcpy+0xcc>
 8000438:	3a01      	subs	r2, #1
 800043a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800043e:	f800 3b01 	strb.w	r3, [r0], #1
 8000442:	d2f9      	bcs.n	8000438 <memcpy+0x118>
 8000444:	780b      	ldrb	r3, [r1, #0]
 8000446:	7003      	strb	r3, [r0, #0]
 8000448:	784b      	ldrb	r3, [r1, #1]
 800044a:	7043      	strb	r3, [r0, #1]
 800044c:	788b      	ldrb	r3, [r1, #2]
 800044e:	7083      	strb	r3, [r0, #2]
 8000450:	4660      	mov	r0, ip
 8000452:	4770      	bx	lr
	...

08000460 <_ctl>:
    return sd_lld_control(sdp, operation, arg);
#else
    return HAL_RET_UNKNOWN_CTL;
#endif
  }
  return HAL_RET_SUCCESS;
 8000460:	2901      	cmp	r1, #1
}
 8000462:	bf14      	ite	ne
 8000464:	f06f 0013 	mvnne.w	r0, #19
 8000468:	2000      	moveq	r0, #0
 800046a:	4770      	bx	lr
 800046c:	0000      	movs	r0, r0
	...

08000470 <__ctl>:
  switch (operation) {
  case CHN_CTL_NOP:
    osalDbgCheck(arg == NULL);
    break;
  case CHN_CTL_INVALID:
    return HAL_RET_UNKNOWN_CTL;
 8000470:	2900      	cmp	r1, #0
  default:
    /* Delegating to the LLD if supported.*/
    return sio_lld_control(siop, operation, arg);
  }
  return HAL_RET_SUCCESS;
}
 8000472:	bf0c      	ite	eq
 8000474:	f06f 0013 	mvneq.w	r0, #19
 8000478:	2000      	movne	r0, #0
 800047a:	4770      	bx	lr
 800047c:	0000      	movs	r0, r0
	...

08000480 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000480:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8000484:	f04f 0c00 	mov.w	ip, #0
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8000488:	09d5      	lsrs	r5, r2, #7
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800048a:	f04f 080f 	mov.w	r8, #15
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800048e:	2202      	movs	r2, #2
      m1 = 1 << bit;
 8000490:	2701      	movs	r7, #1
      m2 = 3 << (bit * 2);
 8000492:	2603      	movs	r6, #3
 8000494:	e010      	b.n	80004b8 <_pal_lld_setgroupmode+0x38>
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000496:	6a04      	ldr	r4, [r0, #32]
 8000498:	ea24 0303 	bic.w	r3, r4, r3
 800049c:	ea43 0309 	orr.w	r3, r3, r9
 80004a0:	6203      	str	r3, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 80004a2:	6803      	ldr	r3, [r0, #0]
 80004a4:	ea0a 0a03 	and.w	sl, sl, r3
 80004a8:	ea4a 0302 	orr.w	r3, sl, r2
 80004ac:	6003      	str	r3, [r0, #0]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 80004ae:	0849      	lsrs	r1, r1, #1
 80004b0:	d02a      	beq.n	8000508 <_pal_lld_setgroupmode+0x88>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 80004b2:	0092      	lsls	r2, r2, #2
    bit++;
 80004b4:	f10c 0c01 	add.w	ip, ip, #1
      altrmask = altr << ((bit & 7) * 4);
 80004b8:	f00c 0307 	and.w	r3, ip, #7
 80004bc:	009b      	lsls	r3, r3, #2
      m2 = 3 << (bit * 2);
 80004be:	ea4f 0e4c 	mov.w	lr, ip, lsl #1
    if ((mask & 1) != 0) {
 80004c2:	f011 0f01 	tst.w	r1, #1
      altrmask = altr << ((bit & 7) * 4);
 80004c6:	fa05 f903 	lsl.w	r9, r5, r3
      m1 = 1 << bit;
 80004ca:	fa07 fa0c 	lsl.w	sl, r7, ip
      m2 = 3 << (bit * 2);
 80004ce:	fa06 fe0e 	lsl.w	lr, r6, lr
      m4 = 15 << ((bit & 7) * 4);
 80004d2:	fa08 f303 	lsl.w	r3, r8, r3
    if ((mask & 1) != 0) {
 80004d6:	d0ea      	beq.n	80004ae <_pal_lld_setgroupmode+0x2e>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80004d8:	6844      	ldr	r4, [r0, #4]
 80004da:	ea24 040a 	bic.w	r4, r4, sl
 80004de:	6044      	str	r4, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80004e0:	6884      	ldr	r4, [r0, #8]
 80004e2:	ea24 040e 	bic.w	r4, r4, lr
 80004e6:	6084      	str	r4, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80004e8:	68c4      	ldr	r4, [r0, #12]
        if (bit < 8)
 80004ea:	f1bc 0f07 	cmp.w	ip, #7
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80004ee:	ea24 040e 	bic.w	r4, r4, lr
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80004f2:	ea6f 0a0e 	mvn.w	sl, lr
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80004f6:	60c4      	str	r4, [r0, #12]
        if (bit < 8)
 80004f8:	d9cd      	bls.n	8000496 <_pal_lld_setgroupmode+0x16>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80004fa:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80004fc:	ea24 0303 	bic.w	r3, r4, r3
 8000500:	ea43 0309 	orr.w	r3, r3, r9
 8000504:	6243      	str	r3, [r0, #36]	; 0x24
 8000506:	e7cc      	b.n	80004a2 <_pal_lld_setgroupmode+0x22>
  }
}
 8000508:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800050c:	0000      	movs	r0, r0
	...

08000510 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000510:	4a02      	ldr	r2, [pc, #8]	; (800051c <notify1+0xc>)
 8000512:	6813      	ldr	r3, [r2, #0]
 8000514:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000518:	6013      	str	r3, [r2, #0]
}
 800051a:	4770      	bx	lr
 800051c:	40013800 	.word	0x40013800

08000520 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000520:	4a02      	ldr	r2, [pc, #8]	; (800052c <notify2+0xc>)
 8000522:	6813      	ldr	r3, [r2, #0]
 8000524:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000528:	6013      	str	r3, [r2, #0]
}
 800052a:	4770      	bx	lr
 800052c:	40004400 	.word	0x40004400

08000530 <sio_lld_put>:
 *
 * @notapi
 */
void sio_lld_put(SIODriver *siop, uint_fast16_t data) {

  siop->usart->TDR = data;
 8000530:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8000532:	6299      	str	r1, [r3, #40]	; 0x28

  /* If the TX FIFO has been filled then the interrupt is enabled again.*/
  if (sio_lld_is_tx_full(siop)) {
 8000534:	69da      	ldr	r2, [r3, #28]
 8000536:	f012 0f80 	tst.w	r2, #128	; 0x80
  if ((siop->enabled & SIO_EV_TXNOTFULL) != 0U) {
 800053a:	68c2      	ldr	r2, [r0, #12]
  if (sio_lld_is_tx_full(siop)) {
 800053c:	d006      	beq.n	800054c <sio_lld_put+0x1c>
  if ((siop->enabled & SIO_EV_TXDONE) != 0U) {
 800053e:	06d2      	lsls	r2, r2, #27
 8000540:	d503      	bpl.n	800054a <sio_lld_put+0x1a>
    siop->usart->CR1 |= USART_CR1_TCIE;
 8000542:	681a      	ldr	r2, [r3, #0]
 8000544:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000548:	601a      	str	r2, [r3, #0]
    usart_enable_tx_irq(siop);
  }

  /* The transmit complete interrupt is always re-enabled on write.*/
  usart_enable_tx_end_irq(siop);
}
 800054a:	4770      	bx	lr
  if ((siop->enabled & SIO_EV_TXNOTFULL) != 0U) {
 800054c:	0711      	lsls	r1, r2, #28
 800054e:	d5f6      	bpl.n	800053e <sio_lld_put+0xe>
    siop->usart->CR3 |= USART_CR3_TXFTIE;
 8000550:	6899      	ldr	r1, [r3, #8]
 8000552:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000556:	6099      	str	r1, [r3, #8]
 8000558:	e7f1      	b.n	800053e <sio_lld_put+0xe>
 800055a:	bf00      	nop
 800055c:	0000      	movs	r0, r0
	...

08000560 <__idle_thread>:
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8000560:	e7fe      	b.n	8000560 <__idle_thread>
 8000562:	bf00      	nop
	...

08000570 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000570:	4b01      	ldr	r3, [pc, #4]	; (8000578 <chTMStartMeasurementX+0x8>)
 8000572:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8000574:	6083      	str	r3, [r0, #8]
}
 8000576:	4770      	bx	lr
 8000578:	e0001000 	.word	0xe0001000
 800057c:	00000000 	.word	0x00000000

08000580 <chTMStopMeasurementX>:
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8000580:	4a0e      	ldr	r2, [pc, #56]	; (80005bc <chTMStopMeasurementX+0x3c>)
 8000582:	4b0f      	ldr	r3, [pc, #60]	; (80005c0 <chTMStopMeasurementX+0x40>)
  tmp->last = (now - tmp->last) - offset;
 8000584:	6881      	ldr	r1, [r0, #8]
 8000586:	685b      	ldr	r3, [r3, #4]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000588:	b410      	push	{r4}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 800058a:	6894      	ldr	r4, [r2, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 800058c:	6902      	ldr	r2, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 800058e:	1b1b      	subs	r3, r3, r4
 8000590:	1a5b      	subs	r3, r3, r1
  tmp->cumulative += (rttime_t)tmp->last;
 8000592:	18d2      	adds	r2, r2, r3
 8000594:	6941      	ldr	r1, [r0, #20]
 8000596:	6102      	str	r2, [r0, #16]
  if (tmp->last > tmp->worst) {
 8000598:	6842      	ldr	r2, [r0, #4]
  tmp->n++;
 800059a:	68c4      	ldr	r4, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
 800059c:	f141 0100 	adc.w	r1, r1, #0
  if (tmp->last > tmp->worst) {
 80005a0:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 80005a2:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 80005a4:	bf88      	it	hi
 80005a6:	6043      	strhi	r3, [r0, #4]
  tmp->n++;
 80005a8:	3401      	adds	r4, #1
  if (tmp->last < tmp->best) {
 80005aa:	4293      	cmp	r3, r2
  tmp->last = (now - tmp->last) - offset;
 80005ac:	e9c0 3402 	strd	r3, r4, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80005b0:	6141      	str	r1, [r0, #20]
}
 80005b2:	bc10      	pop	{r4}
    tmp->best = tmp->last;
 80005b4:	bf38      	it	cc
 80005b6:	6003      	strcc	r3, [r0, #0]
}
 80005b8:	4770      	bx	lr
 80005ba:	bf00      	nop
 80005bc:	20000c38 	.word	0x20000c38
 80005c0:	e0001000 	.word	0xe0001000
	...

080005d0 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 80005d0:	b410      	push	{r4}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80005d2:	2330      	movs	r3, #48	; 0x30
 80005d4:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80005d8:	4b0b      	ldr	r3, [pc, #44]	; (8000608 <chCoreAllocFromTop+0x38>)
 80005da:	685c      	ldr	r4, [r3, #4]
 80005dc:	4249      	negs	r1, r1
 80005de:	1a20      	subs	r0, r4, r0
 80005e0:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80005e2:	6819      	ldr	r1, [r3, #0]
  prev = p - offset;
 80005e4:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80005e6:	428a      	cmp	r2, r1
 80005e8:	d307      	bcc.n	80005fa <chCoreAllocFromTop+0x2a>
 80005ea:	4294      	cmp	r4, r2
 80005ec:	d305      	bcc.n	80005fa <chCoreAllocFromTop+0x2a>
  ch_memcore.topmem = prev;
 80005ee:	605a      	str	r2, [r3, #4]
 80005f0:	2300      	movs	r3, #0
 80005f2:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 80005f6:	bc10      	pop	{r4}
 80005f8:	4770      	bx	lr
    return NULL;
 80005fa:	2000      	movs	r0, #0
 80005fc:	2300      	movs	r3, #0
 80005fe:	f383 8811 	msr	BASEPRI, r3
}
 8000602:	bc10      	pop	{r4}
 8000604:	4770      	bx	lr
 8000606:	bf00      	nop
 8000608:	20000c30 	.word	0x20000c30
 800060c:	00000000 	.word	0x00000000

08000610 <chCoreAllocAlignedI>:
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000610:	4b06      	ldr	r3, [pc, #24]	; (800062c <chCoreAllocAlignedI+0x1c>)
 8000612:	685a      	ldr	r2, [r3, #4]
 8000614:	4249      	negs	r1, r1
 8000616:	1a10      	subs	r0, r2, r0
 8000618:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 800061a:	6819      	ldr	r1, [r3, #0]
 800061c:	4288      	cmp	r0, r1
 800061e:	d303      	bcc.n	8000628 <chCoreAllocAlignedI+0x18>
 8000620:	4282      	cmp	r2, r0
 8000622:	d301      	bcc.n	8000628 <chCoreAllocAlignedI+0x18>
  ch_memcore.topmem = prev;
 8000624:	6058      	str	r0, [r3, #4]
  return p;
 8000626:	4770      	bx	lr
    return NULL;
 8000628:	2000      	movs	r0, #0
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 800062a:	4770      	bx	lr
 800062c:	20000c30 	.word	0x20000c30

08000630 <sd_lld_start.constprop.0>:
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8000630:	7a03      	ldrb	r3, [r0, #8]
 8000632:	2b01      	cmp	r3, #1
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8000634:	b410      	push	{r4}
  if (sdp->state == SD_STOP) {
 8000636:	d016      	beq.n	8000666 <sd_lld_start.constprop.0+0x36>
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 8000638:	6d83      	ldr	r3, [r0, #88]	; 0x58
 800063a:	491a      	ldr	r1, [pc, #104]	; (80006a4 <sd_lld_start.constprop.0+0x74>)
  USART_TypeDef *u = sdp->usart;
 800063c:	6d42      	ldr	r2, [r0, #84]	; 0x54
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 800063e:	f503 4396 	add.w	r3, r3, #19200	; 0x4b00
 8000642:	fba1 1303 	umull	r1, r3, r1, r3
 8000646:	0b1b      	lsrs	r3, r3, #12
  u->BRR = brr;
 8000648:	60d3      	str	r3, [r2, #12]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800064a:	2440      	movs	r4, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800064c:	2301      	movs	r3, #1
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800064e:	6054      	str	r4, [r2, #4]
  u->ICR = 0xFFFFFFFFU;
 8000650:	f04f 31ff 	mov.w	r1, #4294967295
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000654:	6093      	str	r3, [r2, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000656:	f240 132d 	movw	r3, #301	; 0x12d
 800065a:	6013      	str	r3, [r2, #0]
      rccEnableLPUART1(true);
    }
#endif
  }
  usart_init(sdp, config);
}
 800065c:	bc10      	pop	{r4}
  u->ICR = 0xFFFFFFFFU;
 800065e:	6211      	str	r1, [r2, #32]
    sdp->rxmask = 0xFF;
 8000660:	f880 105c 	strb.w	r1, [r0, #92]	; 0x5c
}
 8000664:	4770      	bx	lr
    if (&SD1 == sdp) {
 8000666:	4b10      	ldr	r3, [pc, #64]	; (80006a8 <sd_lld_start.constprop.0+0x78>)
 8000668:	4298      	cmp	r0, r3
 800066a:	d00d      	beq.n	8000688 <sd_lld_start.constprop.0+0x58>
    if (&SD2 == sdp) {
 800066c:	4b0f      	ldr	r3, [pc, #60]	; (80006ac <sd_lld_start.constprop.0+0x7c>)
 800066e:	4298      	cmp	r0, r3
 8000670:	d1e2      	bne.n	8000638 <sd_lld_start.constprop.0+0x8>
      rccEnableUSART2(true);
 8000672:	4b0f      	ldr	r3, [pc, #60]	; (80006b0 <sd_lld_start.constprop.0+0x80>)
 8000674:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000676:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800067a:	659a      	str	r2, [r3, #88]	; 0x58
 800067c:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800067e:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8000682:	679a      	str	r2, [r3, #120]	; 0x78
 8000684:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8000686:	e7d7      	b.n	8000638 <sd_lld_start.constprop.0+0x8>
      rccEnableUSART1(true);
 8000688:	4b09      	ldr	r3, [pc, #36]	; (80006b0 <sd_lld_start.constprop.0+0x80>)
 800068a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800068c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000690:	661a      	str	r2, [r3, #96]	; 0x60
 8000692:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8000696:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800069a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
 800069e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80006a2:	e7c9      	b.n	8000638 <sd_lld_start.constprop.0+0x8>
 80006a4:	1b4e81b5 	.word	0x1b4e81b5
 80006a8:	200008a8 	.word	0x200008a8
 80006ac:	20000908 	.word	0x20000908
 80006b0:	40021000 	.word	0x40021000
	...

080006c0 <__sch_wakeup>:
 80006c0:	2330      	movs	r3, #48	; 0x30
 80006c2:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
 80006c6:	f891 304c 	ldrb.w	r3, [r1, #76]	; 0x4c
 80006ca:	2b0c      	cmp	r3, #12
 80006cc:	d810      	bhi.n	80006f0 <__sch_wakeup+0x30>
 80006ce:	e8df f003 	tbb	[pc, r3]
 80006d2:	0f2a      	.short	0x0f2a
 80006d4:	070b260f 	.word	0x070b260f
 80006d8:	0f0f0b0f 	.word	0x0f0f0b0f
 80006dc:	0f0f      	.short	0x0f0f
 80006de:	0b          	.byte	0x0b
 80006df:	00          	.byte	0x00
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80006e0:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 80006e2:	6893      	ldr	r3, [r2, #8]
 80006e4:	3301      	adds	r3, #1
 80006e6:	6093      	str	r3, [r2, #8]
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
 80006e8:	e9d1 3200 	ldrd	r3, r2, [r1]
 80006ec:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 80006ee:	605a      	str	r2, [r3, #4]
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 80006f0:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
 80006f2:	2200      	movs	r2, #0
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 80006f4:	f04f 34ff 	mov.w	r4, #4294967295
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80006f8:	6c0b      	ldr	r3, [r1, #64]	; 0x40
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio >= p->prio));
 80006fa:	6888      	ldr	r0, [r1, #8]
  tp->u.rdymsg = MSG_TIMEOUT;
 80006fc:	650c      	str	r4, [r1, #80]	; 0x50
  tp->state = CH_STATE_READY;
 80006fe:	f881 204c 	strb.w	r2, [r1, #76]	; 0x4c
    pqp = pqp->next;
 8000702:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8000704:	689a      	ldr	r2, [r3, #8]
 8000706:	4282      	cmp	r2, r0
 8000708:	d2fb      	bcs.n	8000702 <__sch_wakeup+0x42>

  /* Insertion on prev.*/
  p->next       = pqp;
  p->prev       = pqp->prev;
 800070a:	685a      	ldr	r2, [r3, #4]
 800070c:	2000      	movs	r0, #0
 800070e:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
 8000712:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
 8000714:	6059      	str	r1, [r3, #4]
 8000716:	f380 8811 	msr	BASEPRI, r0
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
 800071a:	bc10      	pop	{r4}
 800071c:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 800071e:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 8000720:	2200      	movs	r2, #0
 8000722:	601a      	str	r2, [r3, #0]
    break;
 8000724:	e7e4      	b.n	80006f0 <__sch_wakeup+0x30>
 8000726:	2300      	movs	r3, #0
 8000728:	f383 8811 	msr	BASEPRI, r3
 800072c:	4770      	bx	lr
 800072e:	bf00      	nop

08000730 <chEvtBroadcastFlagsI>:
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8000730:	6803      	ldr	r3, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000732:	4298      	cmp	r0, r3
 8000734:	d034      	beq.n	80007a0 <chEvtBroadcastFlagsI+0x70>
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000736:	b4f0      	push	{r4, r5, r6, r7}
    tp->u.rdymsg = MSG_OK;
 8000738:	2500      	movs	r5, #0
 800073a:	e005      	b.n	8000748 <chEvtBroadcastFlagsI+0x18>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800073c:	f1bc 0f0b 	cmp.w	ip, #11
 8000740:	d029      	beq.n	8000796 <chEvtBroadcastFlagsI+0x66>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8000742:	681b      	ldr	r3, [r3, #0]
  while (elp != (event_listener_t *)esp) {
 8000744:	4298      	cmp	r0, r3
 8000746:	d024      	beq.n	8000792 <chEvtBroadcastFlagsI+0x62>
    elp->flags |= flags;
 8000748:	68da      	ldr	r2, [r3, #12]
 800074a:	430a      	orrs	r2, r1
 800074c:	60da      	str	r2, [r3, #12]
    if ((flags == (eventflags_t)0) ||
 800074e:	b111      	cbz	r1, 8000756 <chEvtBroadcastFlagsI+0x26>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 8000750:	691a      	ldr	r2, [r3, #16]
    if ((flags == (eventflags_t)0) ||
 8000752:	4211      	tst	r1, r2
 8000754:	d0f5      	beq.n	8000742 <chEvtBroadcastFlagsI+0x12>
  tp->epending |= events;
 8000756:	e9d3 2401 	ldrd	r2, r4, [r3, #4]
 800075a:	6e16      	ldr	r6, [r2, #96]	; 0x60
  if (((tp->state == CH_STATE_WTOREVT) &&
 800075c:	f892 c04c 	ldrb.w	ip, [r2, #76]	; 0x4c
  tp->epending |= events;
 8000760:	4334      	orrs	r4, r6
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000762:	f1bc 0f0a 	cmp.w	ip, #10
  tp->epending |= events;
 8000766:	6614      	str	r4, [r2, #96]	; 0x60
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000768:	d1e8      	bne.n	800073c <chEvtBroadcastFlagsI+0xc>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800076a:	6d16      	ldr	r6, [r2, #80]	; 0x50
  if (((tp->state == CH_STATE_WTOREVT) &&
 800076c:	4234      	tst	r4, r6
 800076e:	d0e8      	beq.n	8000742 <chEvtBroadcastFlagsI+0x12>
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8000770:	6c14      	ldr	r4, [r2, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 8000772:	6897      	ldr	r7, [r2, #8]
    tp->u.rdymsg = MSG_OK;
 8000774:	6515      	str	r5, [r2, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8000776:	f882 504c 	strb.w	r5, [r2, #76]	; 0x4c
    pqp = pqp->next;
 800077a:	6824      	ldr	r4, [r4, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800077c:	68a6      	ldr	r6, [r4, #8]
 800077e:	42be      	cmp	r6, r7
 8000780:	d2fb      	bcs.n	800077a <chEvtBroadcastFlagsI+0x4a>
    elp = elp->next;
 8000782:	681b      	ldr	r3, [r3, #0]
  p->prev       = pqp->prev;
 8000784:	6866      	ldr	r6, [r4, #4]
  while (elp != (event_listener_t *)esp) {
 8000786:	4298      	cmp	r0, r3
 8000788:	e9c2 4600 	strd	r4, r6, [r2]
  p->prev->next = p;
 800078c:	6032      	str	r2, [r6, #0]
  pqp->prev     = p;
 800078e:	6062      	str	r2, [r4, #4]
 8000790:	d1da      	bne.n	8000748 <chEvtBroadcastFlagsI+0x18>
  }
}
 8000792:	bcf0      	pop	{r4, r5, r6, r7}
 8000794:	4770      	bx	lr
      ((tp->state == CH_STATE_WTANDEVT) &&
 8000796:	6d16      	ldr	r6, [r2, #80]	; 0x50
 8000798:	ea36 0404 	bics.w	r4, r6, r4
 800079c:	d1d1      	bne.n	8000742 <chEvtBroadcastFlagsI+0x12>
 800079e:	e7e7      	b.n	8000770 <chEvtBroadcastFlagsI+0x40>
 80007a0:	4770      	bx	lr
 80007a2:	bf00      	nop
	...

080007b0 <sd_lld_serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
void sd_lld_serve_interrupt(SerialDriver *sdp) {
 80007b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 80007b4:	6d45      	ldr	r5, [r0, #84]	; 0x54
  uint32_t cr1 = u->CR1;
 80007b6:	f8d5 9000 	ldr.w	r9, [r5]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 80007ba:	69eb      	ldr	r3, [r5, #28]
  u->ICR = isr;
 80007bc:	622b      	str	r3, [r5, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80007be:	071a      	lsls	r2, r3, #28
void sd_lld_serve_interrupt(SerialDriver *sdp) {
 80007c0:	b082      	sub	sp, #8
 80007c2:	4604      	mov	r4, r0
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80007c4:	f040 80bb 	bne.w	800093e <sd_lld_serve_interrupt+0x18e>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 80007c8:	05d9      	lsls	r1, r3, #23
 80007ca:	f100 80aa 	bmi.w	8000922 <sd_lld_serve_interrupt+0x172>
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
 80007ce:	069e      	lsls	r6, r3, #26
 80007d0:	d54e      	bpl.n	8000870 <sd_lld_serve_interrupt+0xc0>
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 80007d2:	f104 070c 	add.w	r7, r4, #12
 80007d6:	f04f 0830 	mov.w	r8, #48	; 0x30
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 80007da:	1d20      	adds	r0, r4, #4

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80007dc:	2600      	movs	r6, #0
 80007de:	e02a      	b.n	8000836 <sd_lld_serve_interrupt+0x86>
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 80007e0:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
 80007e4:	429a      	cmp	r2, r3
 80007e6:	d037      	beq.n	8000858 <sd_lld_serve_interrupt+0xa8>
    iqp->q_counter++;
 80007e8:	6963      	ldr	r3, [r4, #20]
    *iqp->q_wrptr++ = b;
 80007ea:	1c51      	adds	r1, r2, #1
    iqp->q_counter++;
 80007ec:	3301      	adds	r3, #1
    *iqp->q_wrptr++ = b;
 80007ee:	6221      	str	r1, [r4, #32]
    iqp->q_counter++;
 80007f0:	6163      	str	r3, [r4, #20]
    *iqp->q_wrptr++ = b;
 80007f2:	f882 a000 	strb.w	sl, [r2]
    if (iqp->q_wrptr >= iqp->q_top) {
 80007f6:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 80007fa:	429a      	cmp	r2, r3
 80007fc:	d301      	bcc.n	8000802 <sd_lld_serve_interrupt+0x52>
      iqp->q_wrptr = iqp->q_buffer;
 80007fe:	69a3      	ldr	r3, [r4, #24]
 8000800:	6223      	str	r3, [r4, #32]
  return (bool)(qp->next != qp);
 8000802:	68e2      	ldr	r2, [r4, #12]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (ch_queue_notempty(&tqp->queue)) {
 8000804:	42ba      	cmp	r2, r7
 8000806:	d011      	beq.n	800082c <sd_lld_serve_interrupt+0x7c>
  qp->next       = p->next;
 8000808:	6813      	ldr	r3, [r2, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800080a:	6c11      	ldr	r1, [r2, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 800080c:	f8d2 c008 	ldr.w	ip, [r2, #8]
  qp->next       = p->next;
 8000810:	60e3      	str	r3, [r4, #12]
  qp->next->prev = qp;
 8000812:	605f      	str	r7, [r3, #4]
 8000814:	6516      	str	r6, [r2, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8000816:	f882 604c 	strb.w	r6, [r2, #76]	; 0x4c
    pqp = pqp->next;
 800081a:	6809      	ldr	r1, [r1, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800081c:	688b      	ldr	r3, [r1, #8]
 800081e:	4563      	cmp	r3, ip
 8000820:	d2fb      	bcs.n	800081a <sd_lld_serve_interrupt+0x6a>
  p->prev       = pqp->prev;
 8000822:	684b      	ldr	r3, [r1, #4]
 8000824:	e9c2 1300 	strd	r1, r3, [r2]
  p->prev->next = p;
 8000828:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 800082a:	604a      	str	r2, [r1, #4]
 800082c:	f386 8811 	msr	BASEPRI, r6
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
    osalSysUnlockFromISR();

    isr = u->ISR;
 8000830:	69eb      	ldr	r3, [r5, #28]
  while (isr & USART_ISR_RXNE) {
 8000832:	069a      	lsls	r2, r3, #26
 8000834:	d51c      	bpl.n	8000870 <sd_lld_serve_interrupt+0xc0>
 8000836:	f388 8811 	msr	BASEPRI, r8
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 800083a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800083c:	f894 a05c 	ldrb.w	sl, [r4, #92]	; 0x5c
  if (iqIsEmptyI(&sdp->iqueue))
 8000840:	6963      	ldr	r3, [r4, #20]
 8000842:	ea0a 0a02 	and.w	sl, sl, r2
 8000846:	2b00      	cmp	r3, #0
 8000848:	d1ca      	bne.n	80007e0 <sd_lld_serve_interrupt+0x30>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800084a:	2104      	movs	r1, #4
 800084c:	f7ff ff70 	bl	8000730 <chEvtBroadcastFlagsI>
  if (!iqIsFullI(iqp)) {
 8000850:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
 8000854:	429a      	cmp	r2, r3
 8000856:	d1c7      	bne.n	80007e8 <sd_lld_serve_interrupt+0x38>
 8000858:	6963      	ldr	r3, [r4, #20]
 800085a:	2b00      	cmp	r3, #0
 800085c:	d0c4      	beq.n	80007e8 <sd_lld_serve_interrupt+0x38>
 800085e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8000862:	f7ff ff65 	bl	8000730 <chEvtBroadcastFlagsI>
 8000866:	f386 8811 	msr	BASEPRI, r6
    isr = u->ISR;
 800086a:	69eb      	ldr	r3, [r5, #28]
  while (isr & USART_ISR_RXNE) {
 800086c:	069a      	lsls	r2, r3, #26
 800086e:	d4e2      	bmi.n	8000836 <sd_lld_serve_interrupt+0x86>
     situations:
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
 8000870:	f019 0f80 	tst.w	r9, #128	; 0x80
 8000874:	d043      	beq.n	80008fe <sd_lld_serve_interrupt+0x14e>
    while (isr & USART_ISR_TXE) {
 8000876:	0618      	lsls	r0, r3, #24
 8000878:	d541      	bpl.n	80008fe <sd_lld_serve_interrupt+0x14e>
      msg_t b;

      osalSysLockFromISR();
      b = oqGetI(&sdp->oqueue);
 800087a:	f104 0630 	add.w	r6, r4, #48	; 0x30
 800087e:	2730      	movs	r7, #48	; 0x30
 8000880:	2100      	movs	r1, #0
 8000882:	e027      	b.n	80008d4 <sd_lld_serve_interrupt+0x124>

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
    uint8_t b;

    oqp->q_counter++;
 8000884:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000886:	3301      	adds	r3, #1
 8000888:	63a3      	str	r3, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
    if (oqp->q_rdptr >= oqp->q_top) {
 800088a:	6c23      	ldr	r3, [r4, #64]	; 0x40
    b = *oqp->q_rdptr++;
 800088c:	1c50      	adds	r0, r2, #1
 800088e:	64a0      	str	r0, [r4, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
 8000890:	4298      	cmp	r0, r3
    b = *oqp->q_rdptr++;
 8000892:	f892 e000 	ldrb.w	lr, [r2]
    if (oqp->q_rdptr >= oqp->q_top) {
 8000896:	d301      	bcc.n	800089c <sd_lld_serve_interrupt+0xec>
      oqp->q_rdptr = oqp->q_buffer;
 8000898:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800089a:	64a3      	str	r3, [r4, #72]	; 0x48
  return (bool)(qp->next != qp);
 800089c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800089e:	42b3      	cmp	r3, r6
 80008a0:	d011      	beq.n	80008c6 <sd_lld_serve_interrupt+0x116>
  qp->next       = p->next;
 80008a2:	681a      	ldr	r2, [r3, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80008a4:	6c18      	ldr	r0, [r3, #64]	; 0x40
 80008a6:	6322      	str	r2, [r4, #48]	; 0x30
  qp->next->prev = qp;
 80008a8:	6056      	str	r6, [r2, #4]
  } while (unlikely(pqp->prio >= p->prio));
 80008aa:	689a      	ldr	r2, [r3, #8]
 80008ac:	6519      	str	r1, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 80008ae:	f883 104c 	strb.w	r1, [r3, #76]	; 0x4c
    pqp = pqp->next;
 80008b2:	6800      	ldr	r0, [r0, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80008b4:	f8d0 c008 	ldr.w	ip, [r0, #8]
 80008b8:	4594      	cmp	ip, r2
 80008ba:	d2fa      	bcs.n	80008b2 <sd_lld_serve_interrupt+0x102>
  p->prev       = pqp->prev;
 80008bc:	6842      	ldr	r2, [r0, #4]
 80008be:	e9c3 0200 	strd	r0, r2, [r3]
  p->prev->next = p;
 80008c2:	6013      	str	r3, [r2, #0]
  pqp->prev     = p;
 80008c4:	6043      	str	r3, [r0, #4]
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
        osalSysUnlockFromISR();
        break;
      }
      u->TDR = b;
 80008c6:	f8c5 e028 	str.w	lr, [r5, #40]	; 0x28
 80008ca:	f381 8811 	msr	BASEPRI, r1
      osalSysUnlockFromISR();

      isr = u->ISR;
 80008ce:	69eb      	ldr	r3, [r5, #28]
    while (isr & USART_ISR_TXE) {
 80008d0:	061a      	lsls	r2, r3, #24
 80008d2:	d514      	bpl.n	80008fe <sd_lld_serve_interrupt+0x14e>
 80008d4:	f387 8811 	msr	BASEPRI, r7
  if (!oqIsEmptyI(oqp)) {
 80008d8:	e9d4 0211 	ldrd	r0, r2, [r4, #68]	; 0x44
 80008dc:	4290      	cmp	r0, r2
 80008de:	d1d1      	bne.n	8000884 <sd_lld_serve_interrupt+0xd4>
 80008e0:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80008e2:	2800      	cmp	r0, #0
 80008e4:	d0ce      	beq.n	8000884 <sd_lld_serve_interrupt+0xd4>
 80008e6:	2108      	movs	r1, #8
 80008e8:	1d20      	adds	r0, r4, #4
 80008ea:	9301      	str	r3, [sp, #4]
 80008ec:	f7ff ff20 	bl	8000730 <chEvtBroadcastFlagsI>
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
 80008f0:	f029 0280 	bic.w	r2, r9, #128	; 0x80
 80008f4:	602a      	str	r2, [r5, #0]
 80008f6:	2200      	movs	r2, #0
 80008f8:	f382 8811 	msr	BASEPRI, r2
}
 80008fc:	9b01      	ldr	r3, [sp, #4]
    }
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
 80008fe:	f019 0f40 	tst.w	r9, #64	; 0x40
 8000902:	d00b      	beq.n	800091c <sd_lld_serve_interrupt+0x16c>
 8000904:	0659      	lsls	r1, r3, #25
 8000906:	d509      	bpl.n	800091c <sd_lld_serve_interrupt+0x16c>
 8000908:	2330      	movs	r3, #48	; 0x30
 800090a:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue)) {
 800090e:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 8000912:	429a      	cmp	r2, r3
 8000914:	d02e      	beq.n	8000974 <sd_lld_serve_interrupt+0x1c4>
 8000916:	2300      	movs	r3, #0
 8000918:	f383 8811 	msr	BASEPRI, r3
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
      u->CR1 = cr1 & ~USART_CR1_TCIE;
    }
    osalSysUnlockFromISR();
  }
}
 800091c:	b002      	add	sp, #8
 800091e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000922:	9301      	str	r3, [sp, #4]
 8000924:	2230      	movs	r2, #48	; 0x30
 8000926:	f382 8811 	msr	BASEPRI, r2
  chEvtBroadcastFlagsI(esp, flags);
 800092a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800092e:	1d20      	adds	r0, r4, #4
 8000930:	f7ff fefe 	bl	8000730 <chEvtBroadcastFlagsI>
 8000934:	2200      	movs	r2, #0
 8000936:	f382 8811 	msr	BASEPRI, r2
}
 800093a:	9b01      	ldr	r3, [sp, #4]
 800093c:	e747      	b.n	80007ce <sd_lld_serve_interrupt+0x1e>
  if (isr & USART_ISR_ORE)
 800093e:	f3c3 01c0 	ubfx	r1, r3, #3, #1
 8000942:	0209      	lsls	r1, r1, #8
  if (isr & USART_ISR_PE)
 8000944:	07df      	lsls	r7, r3, #31
    sts |= SD_PARITY_ERROR;
 8000946:	bf48      	it	mi
 8000948:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_FE)
 800094c:	079e      	lsls	r6, r3, #30
    sts |= SD_FRAMING_ERROR;
 800094e:	bf48      	it	mi
 8000950:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (isr & USART_ISR_NE)
 8000954:	0758      	lsls	r0, r3, #29
    sts |= SD_NOISE_ERROR;
 8000956:	bf48      	it	mi
 8000958:	f041 0180 	orrmi.w	r1, r1, #128	; 0x80
 800095c:	9301      	str	r3, [sp, #4]
 800095e:	2230      	movs	r2, #48	; 0x30
 8000960:	f382 8811 	msr	BASEPRI, r2
  chEvtBroadcastFlagsI(esp, flags);
 8000964:	1d20      	adds	r0, r4, #4
 8000966:	f7ff fee3 	bl	8000730 <chEvtBroadcastFlagsI>
 800096a:	2200      	movs	r2, #0
 800096c:	f382 8811 	msr	BASEPRI, r2
 8000970:	9b01      	ldr	r3, [sp, #4]
}
 8000972:	e729      	b.n	80007c8 <sd_lld_serve_interrupt+0x18>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8000974:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000976:	2b00      	cmp	r3, #0
 8000978:	d0cd      	beq.n	8000916 <sd_lld_serve_interrupt+0x166>
 800097a:	2110      	movs	r1, #16
 800097c:	1d20      	adds	r0, r4, #4
 800097e:	f7ff fed7 	bl	8000730 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000982:	f029 0340 	bic.w	r3, r9, #64	; 0x40
 8000986:	602b      	str	r3, [r5, #0]
 8000988:	e7c5      	b.n	8000916 <sd_lld_serve_interrupt+0x166>
 800098a:	bf00      	nop
 800098c:	0000      	movs	r0, r0
	...

08000990 <chMtxUnlock.constprop.0>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8000990:	b470      	push	{r4, r5, r6}
  return __sch_get_currthread();
 8000992:	4d2a      	ldr	r5, [pc, #168]	; (8000a3c <chMtxUnlock.constprop.0+0xac>)
 8000994:	2330      	movs	r3, #48	; 0x30
 8000996:	68ee      	ldr	r6, [r5, #12]
 8000998:	f383 8811 	msr	BASEPRI, r3
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
 800099c:	4828      	ldr	r0, [pc, #160]	; (8000a40 <chMtxUnlock.constprop.0+0xb0>)
  return (bool)(qp->next != qp);
 800099e:	6804      	ldr	r4, [r0, #0]
 80009a0:	68c3      	ldr	r3, [r0, #12]
 80009a2:	6673      	str	r3, [r6, #100]	; 0x64

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80009a4:	4284      	cmp	r4, r0
 80009a6:	d041      	beq.n	8000a2c <chMtxUnlock.constprop.0+0x9c>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 80009a8:	6eb1      	ldr	r1, [r6, #104]	; 0x68
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
 80009aa:	b14b      	cbz	r3, 80009c0 <chMtxUnlock.constprop.0+0x30>
 80009ac:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80009ae:	4293      	cmp	r3, r2
 80009b0:	d003      	beq.n	80009ba <chMtxUnlock.constprop.0+0x2a>
 80009b2:	6892      	ldr	r2, [r2, #8]
 80009b4:	4291      	cmp	r1, r2
 80009b6:	bf38      	it	cc
 80009b8:	4611      	movcc	r1, r2
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
 80009ba:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 80009bc:	2b00      	cmp	r3, #0
 80009be:	d1f5      	bne.n	80009ac <chMtxUnlock.constprop.0+0x1c>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 80009c0:	60b1      	str	r1, [r6, #8]
  qp->next       = p->next;
 80009c2:	6823      	ldr	r3, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80009c4:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80009c6:	6003      	str	r3, [r0, #0]
  qp->next->prev = qp;
 80009c8:	6058      	str	r0, [r3, #4]
  } while (unlikely(pqp->prio >= p->prio));
 80009ca:	68a1      	ldr	r1, [r4, #8]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80009cc:	6c23      	ldr	r3, [r4, #64]	; 0x40
      tp->mtxlist = mp;
 80009ce:	6660      	str	r0, [r4, #100]	; 0x64
      mp->next = tp->mtxlist;
 80009d0:	e9c0 4202 	strd	r4, r2, [r0, #8]
  tp->state = CH_STATE_READY;
 80009d4:	2200      	movs	r2, #0
 80009d6:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
    pqp = pqp->next;
 80009da:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80009dc:	689a      	ldr	r2, [r3, #8]
 80009de:	428a      	cmp	r2, r1
 80009e0:	d2fb      	bcs.n	80009da <chMtxUnlock.constprop.0+0x4a>
  p->prev       = pqp->prev;
 80009e2:	685a      	ldr	r2, [r3, #4]
 *
 * @sclass
 */
void chSchRescheduleS(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);
 80009e4:	68e9      	ldr	r1, [r5, #12]
 80009e6:	e9c4 3200 	strd	r3, r2, [r4]
  p->prev->next = p;
 80009ea:	6014      	str	r4, [r2, #0]

  chDbgCheckClassS();

  /* Note, we are favoring the path where the reschedule is necessary
     because higher priority threads are ready.*/
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 80009ec:	6828      	ldr	r0, [r5, #0]
  pqp->prev     = p;
 80009ee:	605c      	str	r4, [r3, #4]
 80009f0:	688a      	ldr	r2, [r1, #8]
 80009f2:	6883      	ldr	r3, [r0, #8]
 80009f4:	4293      	cmp	r3, r2
 80009f6:	d914      	bls.n	8000a22 <chMtxUnlock.constprop.0+0x92>
  pqp->next       = p->next;
 80009f8:	6803      	ldr	r3, [r0, #0]
 80009fa:	602b      	str	r3, [r5, #0]
  pqp->next->prev = pqp;
 80009fc:	605d      	str	r5, [r3, #4]
  ntp->state = CH_STATE_CURRENT;
 80009fe:	2301      	movs	r3, #1
 8000a00:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  tp->state = CH_STATE_READY;
 8000a04:	2300      	movs	r3, #0
 8000a06:	f881 304c 	strb.w	r3, [r1, #76]	; 0x4c
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8000a0a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  __instance_set_currthread(oip, ntp);
 8000a0c:	60e8      	str	r0, [r5, #12]
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
 8000a0e:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio > p->prio));
 8000a10:	689c      	ldr	r4, [r3, #8]
 8000a12:	42a2      	cmp	r2, r4
 8000a14:	d3fb      	bcc.n	8000a0e <chMtxUnlock.constprop.0+0x7e>

  /* Insertion on prev.*/
  p->next       = pqp;
  p->prev       = pqp->prev;
 8000a16:	685a      	ldr	r2, [r3, #4]
 8000a18:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
 8000a1c:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
 8000a1e:	6059      	str	r1, [r3, #4]
  chSysSwitch(ntp, otp);
 8000a20:	df00      	svc	0
 8000a22:	2300      	movs	r3, #0
 8000a24:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 8000a28:	bc70      	pop	{r4, r5, r6}
 8000a2a:	4770      	bx	lr
      mp->owner = NULL;
 8000a2c:	2300      	movs	r3, #0
 8000a2e:	60a3      	str	r3, [r4, #8]
 8000a30:	2300      	movs	r3, #0
 8000a32:	f383 8811 	msr	BASEPRI, r3
}
 8000a36:	bc70      	pop	{r4, r5, r6}
 8000a38:	4770      	bx	lr
 8000a3a:	bf00      	nop
 8000a3c:	20000a68 	.word	0x20000a68
 8000a40:	20000848 	.word	0x20000848
	...

08000a50 <chMtxLockS.constprop.0>:
void chMtxLockS(mutex_t *mp) {
 8000a50:	b4f0      	push	{r4, r5, r6, r7}
  if (mp->owner != NULL) {
 8000a52:	4c36      	ldr	r4, [pc, #216]	; (8000b2c <chMtxLockS.constprop.0+0xdc>)
 8000a54:	4d36      	ldr	r5, [pc, #216]	; (8000b30 <chMtxLockS.constprop.0+0xe0>)
 8000a56:	68a3      	ldr	r3, [r4, #8]
 8000a58:	68e9      	ldr	r1, [r5, #12]
 8000a5a:	b343      	cbz	r3, 8000aae <chMtxLockS.constprop.0+0x5e>
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8000a5c:	6888      	ldr	r0, [r1, #8]
 8000a5e:	689a      	ldr	r2, [r3, #8]
 8000a60:	4290      	cmp	r0, r2
 8000a62:	d907      	bls.n	8000a74 <chMtxLockS.constprop.0+0x24>
        switch (tp->state) {
 8000a64:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 8000a68:	6098      	str	r0, [r3, #8]
        switch (tp->state) {
 8000a6a:	2a06      	cmp	r2, #6
 8000a6c:	d045      	beq.n	8000afa <chMtxLockS.constprop.0+0xaa>
 8000a6e:	2a07      	cmp	r2, #7
 8000a70:	d034      	beq.n	8000adc <chMtxLockS.constprop.0+0x8c>
 8000a72:	b312      	cbz	r2, 8000aba <chMtxLockS.constprop.0+0x6a>
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
 8000a74:	4b2d      	ldr	r3, [pc, #180]	; (8000b2c <chMtxLockS.constprop.0+0xdc>)
 8000a76:	e003      	b.n	8000a80 <chMtxLockS.constprop.0+0x30>
  do {
    cp = cp->next;
  } while ((cp != qp) &&
 8000a78:	6898      	ldr	r0, [r3, #8]
 8000a7a:	688a      	ldr	r2, [r1, #8]
 8000a7c:	4290      	cmp	r0, r2
 8000a7e:	d302      	bcc.n	8000a86 <chMtxLockS.constprop.0+0x36>
    cp = cp->next;
 8000a80:	681b      	ldr	r3, [r3, #0]
  } while ((cp != qp) &&
 8000a82:	42a3      	cmp	r3, r4
 8000a84:	d1f8      	bne.n	8000a78 <chMtxLockS.constprop.0+0x28>
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
  tp->next       = cp;
  tp->prev       = cp->prev;
 8000a86:	685a      	ldr	r2, [r3, #4]
  ch_priority_queue_t *p = pqp->next;
 8000a88:	6828      	ldr	r0, [r5, #0]
 8000a8a:	e9c1 3200 	strd	r3, r2, [r1]
  tp->prev->next = tp;
 8000a8e:	6011      	str	r1, [r2, #0]
  otp->state = newstate;
 8000a90:	2206      	movs	r2, #6
  cp->prev       = tp;
 8000a92:	6059      	str	r1, [r3, #4]
 8000a94:	f881 204c 	strb.w	r2, [r1, #76]	; 0x4c
  pqp->next       = p->next;
 8000a98:	6803      	ldr	r3, [r0, #0]
 8000a9a:	602b      	str	r3, [r5, #0]
      currtp->u.wtmtxp = mp;
 8000a9c:	650c      	str	r4, [r1, #80]	; 0x50
  pqp->next->prev = pqp;
 8000a9e:	605d      	str	r5, [r3, #4]
  ntp->state = CH_STATE_CURRENT;
 8000aa0:	2301      	movs	r3, #1
 8000aa2:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  __instance_set_currthread(oip, ntp);
 8000aa6:	60e8      	str	r0, [r5, #12]
  chSysSwitch(ntp, otp);
 8000aa8:	df00      	svc	0
}
 8000aaa:	bcf0      	pop	{r4, r5, r6, r7}
 8000aac:	4770      	bx	lr
    mp->next = currtp->mtxlist;
 8000aae:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    currtp->mtxlist = mp;
 8000ab0:	664c      	str	r4, [r1, #100]	; 0x64
    mp->next = currtp->mtxlist;
 8000ab2:	e9c4 1302 	strd	r1, r3, [r4, #8]
}
 8000ab6:	bcf0      	pop	{r4, r5, r6, r7}
 8000ab8:	4770      	bx	lr
  p->prev->next = p->next;
 8000aba:	e9d3 6700 	ldrd	r6, r7, [r3]
 8000abe:	603e      	str	r6, [r7, #0]
  p->next->prev = p->prev;
 8000ac0:	6077      	str	r7, [r6, #4]
  tp->state = CH_STATE_READY;
 8000ac2:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8000ac6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    pqp = pqp->next;
 8000ac8:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8000aca:	6896      	ldr	r6, [r2, #8]
 8000acc:	4286      	cmp	r6, r0
 8000ace:	d2fb      	bcs.n	8000ac8 <chMtxLockS.constprop.0+0x78>
  p->next       = pqp;
 8000ad0:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8000ad2:	6850      	ldr	r0, [r2, #4]
 8000ad4:	6058      	str	r0, [r3, #4]
  p->prev->next = p;
 8000ad6:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 8000ad8:	6053      	str	r3, [r2, #4]
 8000ada:	e7cb      	b.n	8000a74 <chMtxLockS.constprop.0+0x24>
  p->prev->next = p->next;
 8000adc:	e9d3 2000 	ldrd	r2, r0, [r3]
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8000ae0:	6d1e      	ldr	r6, [r3, #80]	; 0x50
 8000ae2:	6002      	str	r2, [r0, #0]
  p->next->prev = p->prev;
 8000ae4:	6050      	str	r0, [r2, #4]
  ch_queue_t *cp = qp;
 8000ae6:	4632      	mov	r2, r6
 8000ae8:	e003      	b.n	8000af2 <chMtxLockS.constprop.0+0xa2>
  } while ((cp != qp) &&
 8000aea:	6898      	ldr	r0, [r3, #8]
 8000aec:	6897      	ldr	r7, [r2, #8]
 8000aee:	4287      	cmp	r7, r0
 8000af0:	d3ee      	bcc.n	8000ad0 <chMtxLockS.constprop.0+0x80>
    cp = cp->next;
 8000af2:	6812      	ldr	r2, [r2, #0]
  } while ((cp != qp) &&
 8000af4:	4296      	cmp	r6, r2
 8000af6:	d1f8      	bne.n	8000aea <chMtxLockS.constprop.0+0x9a>
 8000af8:	e7ea      	b.n	8000ad0 <chMtxLockS.constprop.0+0x80>
  p->prev->next = p->next;
 8000afa:	e9d3 2000 	ldrd	r2, r0, [r3]
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8000afe:	6d1e      	ldr	r6, [r3, #80]	; 0x50
 8000b00:	6002      	str	r2, [r0, #0]
  p->next->prev = p->prev;
 8000b02:	6050      	str	r0, [r2, #4]
  ch_queue_t *cp = qp;
 8000b04:	4632      	mov	r2, r6
 8000b06:	e003      	b.n	8000b10 <chMtxLockS.constprop.0+0xc0>
  } while ((cp != qp) &&
 8000b08:	6898      	ldr	r0, [r3, #8]
 8000b0a:	6897      	ldr	r7, [r2, #8]
 8000b0c:	4287      	cmp	r7, r0
 8000b0e:	d302      	bcc.n	8000b16 <chMtxLockS.constprop.0+0xc6>
    cp = cp->next;
 8000b10:	6812      	ldr	r2, [r2, #0]
  } while ((cp != qp) &&
 8000b12:	4296      	cmp	r6, r2
 8000b14:	d1f8      	bne.n	8000b08 <chMtxLockS.constprop.0+0xb8>
  tp->prev       = cp->prev;
 8000b16:	6850      	ldr	r0, [r2, #4]
  tp->next       = cp;
 8000b18:	601a      	str	r2, [r3, #0]
  tp->prev       = cp->prev;
 8000b1a:	6058      	str	r0, [r3, #4]
  tp->prev->next = tp;
 8000b1c:	6003      	str	r3, [r0, #0]
  cp->prev       = tp;
 8000b1e:	6053      	str	r3, [r2, #4]
          tp = tp->u.wtmtxp->owner;
 8000b20:	68b3      	ldr	r3, [r6, #8]
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8000b22:	6888      	ldr	r0, [r1, #8]
 8000b24:	689a      	ldr	r2, [r3, #8]
 8000b26:	4290      	cmp	r0, r2
 8000b28:	d89c      	bhi.n	8000a64 <chMtxLockS.constprop.0+0x14>
 8000b2a:	e7a3      	b.n	8000a74 <chMtxLockS.constprop.0+0x24>
 8000b2c:	20000848 	.word	0x20000848
 8000b30:	20000a68 	.word	0x20000a68
	...

08000b40 <vt_insert_first.constprop.0>:
                            sysinterval_t delay) {
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8000b40:	4b16      	ldr	r3, [pc, #88]	; (8000b9c <vt_insert_first.constprop.0+0x5c>)
static void vt_insert_first(virtual_timers_list_t *vtlp,
 8000b42:	b430      	push	{r4, r5}
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {

  dlp->delta      = delta;
  dlp->prev       = dlhp;
 8000b44:	f103 0410 	add.w	r4, r3, #16
  vtlp->lasttime = now;
 8000b48:	61d9      	str	r1, [r3, #28]
 8000b4a:	6044      	str	r4, [r0, #4]
  dlp->next       = dlp->prev->next;
 8000b4c:	691c      	ldr	r4, [r3, #16]
  dlp->delta      = delta;
 8000b4e:	6082      	str	r2, [r0, #8]
 8000b50:	2a02      	cmp	r2, #2
  dlp->next       = dlp->prev->next;
 8000b52:	6004      	str	r4, [r0, #0]
 8000b54:	bf38      	it	cc
 8000b56:	2202      	movcc	r2, #2
  dlp->next->prev = dlp;
 8000b58:	6060      	str	r0, [r4, #4]
  dlhp->next      = dlp;
 8000b5a:	6118      	str	r0, [r3, #16]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000b5c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8000b60:	188c      	adds	r4, r1, r2
 8000b62:	6344      	str	r4, [r0, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000b64:	2400      	movs	r4, #0
 8000b66:	6104      	str	r4, [r0, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000b68:	2402      	movs	r4, #2
 8000b6a:	60c4      	str	r4, [r0, #12]
  return (systime_t)STM32_ST_TIM->CNT;
 8000b6c:	6a45      	ldr	r5, [r0, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8000b6e:	eba5 0c01 	sub.w	ip, r5, r1
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8000b72:	4562      	cmp	r2, ip
 8000b74:	d903      	bls.n	8000b7e <vt_insert_first.constprop.0+0x3e>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8000b76:	bc30      	pop	{r4, r5}
 8000b78:	4770      	bx	lr
 8000b7a:	4629      	mov	r1, r5
 8000b7c:	4615      	mov	r5, r2
    currdelta += (sysinterval_t)1;
 8000b7e:	3401      	adds	r4, #1
  return systime + (systime_t)interval;
 8000b80:	4421      	add	r1, r4
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000b82:	6341      	str	r1, [r0, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8000b84:	6a42      	ldr	r2, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8000b86:	1b51      	subs	r1, r2, r5
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8000b88:	42a1      	cmp	r1, r4
 8000b8a:	d2f6      	bcs.n	8000b7a <vt_insert_first.constprop.0+0x3a>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8000b8c:	2c02      	cmp	r4, #2
 8000b8e:	d9f2      	bls.n	8000b76 <vt_insert_first.constprop.0+0x36>
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8000b90:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000b92:	f042 0201 	orr.w	r2, r2, #1
}
 8000b96:	bc30      	pop	{r4, r5}
 8000b98:	635a      	str	r2, [r3, #52]	; 0x34
 8000b9a:	4770      	bx	lr
 8000b9c:	20000a68 	.word	0x20000a68

08000ba0 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8000ba0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  thread_t *tp = __instance_get_currthread(currcore);
 8000ba4:	4d5c      	ldr	r5, [pc, #368]	; (8000d18 <chSchGoSleepTimeoutS+0x178>)
  if (TIME_INFINITE != timeout) {
 8000ba6:	1c4b      	adds	r3, r1, #1
  thread_t *tp = __instance_get_currthread(currcore);
 8000ba8:	68ee      	ldr	r6, [r5, #12]
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8000baa:	b086      	sub	sp, #24
 8000bac:	4607      	mov	r7, r0
  if (TIME_INFINITE != timeout) {
 8000bae:	d069      	beq.n	8000c84 <chSchGoSleepTimeoutS+0xe4>
  return (bool)(dlhp == dlhp->next);
 8000bb0:	46a8      	mov	r8, r5
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  /* Timer initialization.*/
  vtp->par     = par;
  vtp->func    = vtfunc;
 8000bb2:	4b5a      	ldr	r3, [pc, #360]	; (8000d1c <chSchGoSleepTimeoutS+0x17c>)
 8000bb4:	f858 0f10 	ldr.w	r0, [r8, #16]!
 8000bb8:	e9cd 3603 	strd	r3, r6, [sp, #12]
 8000bbc:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
  vtp->reload  = (sysinterval_t)0;
 8000bc0:	2300      	movs	r3, #0
 8000bc2:	9305      	str	r3, [sp, #20]
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8000bc4:	4540      	cmp	r0, r8
 8000bc6:	460a      	mov	r2, r1
 8000bc8:	f8dc 1024 	ldr.w	r1, [ip, #36]	; 0x24
 8000bcc:	f000 8097 	beq.w	8000cfe <chSchGoSleepTimeoutS+0x15e>
 8000bd0:	69eb      	ldr	r3, [r5, #28]
    if (delta < vtlp->dlist.next->delta) {
 8000bd2:	6884      	ldr	r4, [r0, #8]
 8000bd4:	1acb      	subs	r3, r1, r3
    if (delta < nowdelta) {
 8000bd6:	18d3      	adds	r3, r2, r3
 8000bd8:	bf28      	it	cs
 8000bda:	4613      	movcs	r3, r2
    if (delta < vtlp->dlist.next->delta) {
 8000bdc:	429c      	cmp	r4, r3
 8000bde:	d923      	bls.n	8000c28 <chSchGoSleepTimeoutS+0x88>
  if (delay < currdelta) {
 8000be0:	2a02      	cmp	r2, #2
 8000be2:	bf38      	it	cc
 8000be4:	2202      	movcc	r2, #2
  return systime + (systime_t)interval;
 8000be6:	eb01 0e02 	add.w	lr, r1, r2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000bea:	f8cc e034 	str.w	lr, [ip, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8000bee:	f8dc e024 	ldr.w	lr, [ip, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8000bf2:	ebae 0101 	sub.w	r1, lr, r1
    if (likely(nowdelta < delay)) {
 8000bf6:	428a      	cmp	r2, r1
 8000bf8:	bf98      	it	ls
 8000bfa:	2202      	movls	r2, #2
 8000bfc:	d814      	bhi.n	8000c28 <chSchGoSleepTimeoutS+0x88>
    currdelta += (sysinterval_t)1;
 8000bfe:	3201      	adds	r2, #1
  return systime + (systime_t)interval;
 8000c00:	eb02 010e 	add.w	r1, r2, lr
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000c04:	f8cc 1034 	str.w	r1, [ip, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8000c08:	f8dc 1024 	ldr.w	r1, [ip, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8000c0c:	eba1 0e0e 	sub.w	lr, r1, lr
    if (likely(nowdelta < delay)) {
 8000c10:	4596      	cmp	lr, r2
 8000c12:	d27d      	bcs.n	8000d10 <chSchGoSleepTimeoutS+0x170>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8000c14:	2a02      	cmp	r2, #2
 8000c16:	d907      	bls.n	8000c28 <chSchGoSleepTimeoutS+0x88>
 8000c18:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8000c1a:	f042 0201 	orr.w	r2, r2, #1
 8000c1e:	636a      	str	r2, [r5, #52]	; 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8000c20:	e002      	b.n	8000c28 <chSchGoSleepTimeoutS+0x88>
  while (likely(dlp->delta < delta)) {
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
    dlp = dlp->next;
 8000c22:	6800      	ldr	r0, [r0, #0]
    delta -= dlp->delta;
 8000c24:	1b1b      	subs	r3, r3, r4
  while (likely(dlp->delta < delta)) {
 8000c26:	6884      	ldr	r4, [r0, #8]
 8000c28:	429c      	cmp	r4, r3
 8000c2a:	d3fa      	bcc.n	8000c22 <chSchGoSleepTimeoutS+0x82>
  dlp->delta      = delta;
 8000c2c:	9302      	str	r3, [sp, #8]

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8000c2e:	6882      	ldr	r2, [r0, #8]
  dlp->next       = dlhp;
 8000c30:	9000      	str	r0, [sp, #0]
  dlp->delta -= delta;
 8000c32:	1ad2      	subs	r2, r2, r3
  dlp->prev       = dlp->next->prev;
 8000c34:	6843      	ldr	r3, [r0, #4]
 8000c36:	9301      	str	r3, [sp, #4]
  dlp->prev->next = dlp;
 8000c38:	466c      	mov	r4, sp
 8000c3a:	601c      	str	r4, [r3, #0]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8000c3c:	f04f 33ff 	mov.w	r3, #4294967295
  dlhp->prev      = dlp;
 8000c40:	e9c0 4201 	strd	r4, r2, [r0, #4]
  dlhp->delta = (sysinterval_t)-1;
 8000c44:	61ab      	str	r3, [r5, #24]
  ch_priority_queue_t *p = pqp->next;
 8000c46:	6828      	ldr	r0, [r5, #0]
  otp->state = newstate;
 8000c48:	f886 704c 	strb.w	r7, [r6, #76]	; 0x4c
  pqp->next       = p->next;
 8000c4c:	6803      	ldr	r3, [r0, #0]
 8000c4e:	602b      	str	r3, [r5, #0]
  ntp->state = CH_STATE_CURRENT;
 8000c50:	2201      	movs	r2, #1
  pqp->next->prev = pqp;
 8000c52:	605d      	str	r5, [r3, #4]
  chSysSwitch(ntp, otp);
 8000c54:	4631      	mov	r1, r6
  ntp->state = CH_STATE_CURRENT;
 8000c56:	f880 204c 	strb.w	r2, [r0, #76]	; 0x4c
  __instance_set_currthread(oip, ntp);
 8000c5a:	60e8      	str	r0, [r5, #12]
  chSysSwitch(ntp, otp);
 8000c5c:	df00      	svc	0
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {

  chDbgCheckClassI();

  return (bool)(vtp->dlist.next != NULL);
 8000c5e:	9b00      	ldr	r3, [sp, #0]
    if (chVTIsArmedI(&vt)) {
 8000c60:	b163      	cbz	r3, 8000c7c <chSchGoSleepTimeoutS+0xdc>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8000c62:	692a      	ldr	r2, [r5, #16]
 8000c64:	42a2      	cmp	r2, r4
 8000c66:	d01d      	beq.n	8000ca4 <chSchGoSleepTimeoutS+0x104>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
 8000c68:	e9dd 1001 	ldrd	r1, r0, [sp, #4]

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8000c6c:	689a      	ldr	r2, [r3, #8]
 8000c6e:	600b      	str	r3, [r1, #0]
 8000c70:	4402      	add	r2, r0
 8000c72:	e9c3 1201 	strd	r1, r2, [r3, #4]
    vtp->dlist.next = NULL;

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8000c76:	f04f 33ff 	mov.w	r3, #4294967295
 8000c7a:	61ab      	str	r3, [r5, #24]
}
 8000c7c:	6d30      	ldr	r0, [r6, #80]	; 0x50
 8000c7e:	b006      	add	sp, #24
 8000c80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  ch_priority_queue_t *p = pqp->next;
 8000c84:	6828      	ldr	r0, [r5, #0]
  otp->state = newstate;
 8000c86:	f886 704c 	strb.w	r7, [r6, #76]	; 0x4c
  pqp->next       = p->next;
 8000c8a:	6803      	ldr	r3, [r0, #0]
 8000c8c:	602b      	str	r3, [r5, #0]
  ntp->state = CH_STATE_CURRENT;
 8000c8e:	2201      	movs	r2, #1
  pqp->next->prev = pqp;
 8000c90:	605d      	str	r5, [r3, #4]
  chSysSwitch(ntp, otp);
 8000c92:	4631      	mov	r1, r6
  ntp->state = CH_STATE_CURRENT;
 8000c94:	f880 204c 	strb.w	r2, [r0, #76]	; 0x4c
  __instance_set_currthread(oip, ntp);
 8000c98:	60e8      	str	r0, [r5, #12]
  chSysSwitch(ntp, otp);
 8000c9a:	df00      	svc	0
}
 8000c9c:	6d30      	ldr	r0, [r6, #80]	; 0x50
 8000c9e:	b006      	add	sp, #24
 8000ca0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return;
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
  vtp->dlist.next = NULL;
 8000ca4:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8000ca6:	4543      	cmp	r3, r8
  dlhp->next       = dlp->next;
 8000ca8:	612b      	str	r3, [r5, #16]
  vtp->dlist.next = NULL;
 8000caa:	9200      	str	r2, [sp, #0]
  dlhp->next->prev = dlhp;
 8000cac:	f8c3 8004 	str.w	r8, [r3, #4]
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8000cb0:	d02a      	beq.n	8000d08 <chSchGoSleepTimeoutS+0x168>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8000cb2:	689a      	ldr	r2, [r3, #8]
 8000cb4:	9902      	ldr	r1, [sp, #8]
 8000cb6:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000cba:	440a      	add	r2, r1
 8000cbc:	609a      	str	r2, [r3, #8]
 8000cbe:	6a41      	ldr	r1, [r0, #36]	; 0x24

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8000cc0:	69eb      	ldr	r3, [r5, #28]
 8000cc2:	1acc      	subs	r4, r1, r3

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8000cc4:	42a2      	cmp	r2, r4
 8000cc6:	d9d9      	bls.n	8000c7c <chSchGoSleepTimeoutS+0xdc>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8000cc8:	1a5b      	subs	r3, r3, r1
 8000cca:	4413      	add	r3, r2
 8000ccc:	2b02      	cmp	r3, #2
 8000cce:	bf38      	it	cc
 8000cd0:	2302      	movcc	r3, #2
  return systime + (systime_t)interval;
 8000cd2:	18ca      	adds	r2, r1, r3
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000cd4:	6342      	str	r2, [r0, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8000cd6:	6a42      	ldr	r2, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8000cd8:	1a51      	subs	r1, r2, r1
    if (likely(nowdelta < delay)) {
 8000cda:	4299      	cmp	r1, r3
 8000cdc:	bf28      	it	cs
 8000cde:	2302      	movcs	r3, #2
 8000ce0:	d3cc      	bcc.n	8000c7c <chSchGoSleepTimeoutS+0xdc>
    currdelta += (sysinterval_t)1;
 8000ce2:	3301      	adds	r3, #1
  return systime + (systime_t)interval;
 8000ce4:	18d1      	adds	r1, r2, r3
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000ce6:	6341      	str	r1, [r0, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8000ce8:	6a41      	ldr	r1, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8000cea:	1a8a      	subs	r2, r1, r2
    if (likely(nowdelta < delay)) {
 8000cec:	429a      	cmp	r2, r3
 8000cee:	d211      	bcs.n	8000d14 <chSchGoSleepTimeoutS+0x174>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8000cf0:	2b02      	cmp	r3, #2
 8000cf2:	d9c3      	bls.n	8000c7c <chSchGoSleepTimeoutS+0xdc>
  currcore->rfcu.mask |= mask;
 8000cf4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000cf6:	f043 0301 	orr.w	r3, r3, #1
 8000cfa:	636b      	str	r3, [r5, #52]	; 0x34
}
 8000cfc:	e7be      	b.n	8000c7c <chSchGoSleepTimeoutS+0xdc>
      vt_insert_first(vtlp, vtp, now, delay);
 8000cfe:	466c      	mov	r4, sp
 8000d00:	4620      	mov	r0, r4
 8000d02:	f7ff ff1d 	bl	8000b40 <vt_insert_first.constprop.0>
      return;
 8000d06:	e79e      	b.n	8000c46 <chSchGoSleepTimeoutS+0xa6>
  STM32_ST_TIM->DIER = 0U;
 8000d08:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000d0c:	60da      	str	r2, [r3, #12]
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
 8000d0e:	e7b5      	b.n	8000c7c <chSchGoSleepTimeoutS+0xdc>
  return (systime_t)STM32_ST_TIM->CNT;
 8000d10:	468e      	mov	lr, r1
 8000d12:	e774      	b.n	8000bfe <chSchGoSleepTimeoutS+0x5e>
 8000d14:	460a      	mov	r2, r1
 8000d16:	e7e4      	b.n	8000ce2 <chSchGoSleepTimeoutS+0x142>
 8000d18:	20000a68 	.word	0x20000a68
 8000d1c:	080006c1 	.word	0x080006c1

08000d20 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8000d20:	b570      	push	{r4, r5, r6, lr}
 8000d22:	2330      	movs	r3, #48	; 0x30
 8000d24:	4604      	mov	r4, r0
 8000d26:	460d      	mov	r5, r1
 8000d28:	f383 8811 	msr	BASEPRI, r3
 8000d2c:	4e16      	ldr	r6, [pc, #88]	; (8000d88 <iqGetTimeout+0x68>)
}
 8000d2e:	e008      	b.n	8000d42 <iqGetTimeout+0x22>
  p->prev       = qp->prev;
 8000d30:	6862      	ldr	r2, [r4, #4]
 8000d32:	e9c3 4200 	strd	r4, r2, [r3]
  p->prev->next = p;
 8000d36:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
 8000d38:	6063      	str	r3, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000d3a:	f7ff ff31 	bl	8000ba0 <chSchGoSleepTimeoutS>
    if (msg < MSG_OK) {
 8000d3e:	2800      	cmp	r0, #0
 8000d40:	db08      	blt.n	8000d54 <iqGetTimeout+0x34>
  while (iqIsEmptyI(iqp)) {
 8000d42:	68a3      	ldr	r3, [r4, #8]
 8000d44:	4629      	mov	r1, r5
 8000d46:	2004      	movs	r0, #4
 8000d48:	b943      	cbnz	r3, 8000d5c <iqGetTimeout+0x3c>
 8000d4a:	68f3      	ldr	r3, [r6, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8000d4c:	2d00      	cmp	r5, #0
 8000d4e:	d1ef      	bne.n	8000d30 <iqGetTimeout+0x10>
    return MSG_TIMEOUT;
 8000d50:	f04f 30ff 	mov.w	r0, #4294967295
 8000d54:	2300      	movs	r3, #0
 8000d56:	f383 8811 	msr	BASEPRI, r3
}
 8000d5a:	bd70      	pop	{r4, r5, r6, pc}
  iqp->q_counter--;
 8000d5c:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8000d5e:	69a1      	ldr	r1, [r4, #24]
  iqp->q_counter--;
 8000d60:	3b01      	subs	r3, #1
 8000d62:	60a3      	str	r3, [r4, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000d64:	6923      	ldr	r3, [r4, #16]
  b = *iqp->q_rdptr++;
 8000d66:	1c4a      	adds	r2, r1, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8000d68:	429a      	cmp	r2, r3
    iqp->q_rdptr = iqp->q_buffer;
 8000d6a:	bf28      	it	cs
 8000d6c:	68e3      	ldrcs	r3, [r4, #12]
  b = *iqp->q_rdptr++;
 8000d6e:	61a2      	str	r2, [r4, #24]
 8000d70:	780d      	ldrb	r5, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 8000d72:	bf28      	it	cs
 8000d74:	61a3      	strcs	r3, [r4, #24]
  if (iqp->q_notify != NULL) {
 8000d76:	69e3      	ldr	r3, [r4, #28]
 8000d78:	b10b      	cbz	r3, 8000d7e <iqGetTimeout+0x5e>
    iqp->q_notify(iqp);
 8000d7a:	4620      	mov	r0, r4
 8000d7c:	4798      	blx	r3
 8000d7e:	2300      	movs	r3, #0
 8000d80:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 8000d84:	4628      	mov	r0, r5
}
 8000d86:	bd70      	pop	{r4, r5, r6, pc}
 8000d88:	20000a68 	.word	0x20000a68
 8000d8c:	00000000 	.word	0x00000000

08000d90 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000d90:	f04f 31ff 	mov.w	r1, #4294967295
 8000d94:	300c      	adds	r0, #12
 8000d96:	f7ff bfc3 	b.w	8000d20 <iqGetTimeout>
 8000d9a:	bf00      	nop
 8000d9c:	0000      	movs	r0, r0
	...

08000da0 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000da0:	300c      	adds	r0, #12
 8000da2:	f7ff bfbd 	b.w	8000d20 <iqGetTimeout>
 8000da6:	bf00      	nop
	...

08000db0 <oqPutTimeout>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000db0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000db4:	2330      	movs	r3, #48	; 0x30
 8000db6:	4604      	mov	r4, r0
 8000db8:	460f      	mov	r7, r1
 8000dba:	4616      	mov	r6, r2
 8000dbc:	f383 8811 	msr	BASEPRI, r3
 8000dc0:	f8df 8060 	ldr.w	r8, [pc, #96]	; 8000e24 <oqPutTimeout+0x74>
 8000dc4:	e008      	b.n	8000dd8 <oqPutTimeout+0x28>
  p->prev       = qp->prev;
 8000dc6:	6865      	ldr	r5, [r4, #4]
 8000dc8:	e9c3 4500 	strd	r4, r5, [r3]
  p->prev->next = p;
 8000dcc:	602b      	str	r3, [r5, #0]
  qp->prev      = p;
 8000dce:	6063      	str	r3, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000dd0:	f7ff fee6 	bl	8000ba0 <chSchGoSleepTimeoutS>
    if (msg < MSG_OK) {
 8000dd4:	2800      	cmp	r0, #0
 8000dd6:	db09      	blt.n	8000dec <oqPutTimeout+0x3c>
  while (oqIsFullI(oqp)) {
 8000dd8:	68a3      	ldr	r3, [r4, #8]
 8000dda:	4631      	mov	r1, r6
 8000ddc:	2004      	movs	r0, #4
 8000dde:	b953      	cbnz	r3, 8000df6 <oqPutTimeout+0x46>
 8000de0:	f8d8 300c 	ldr.w	r3, [r8, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8000de4:	2e00      	cmp	r6, #0
 8000de6:	d1ee      	bne.n	8000dc6 <oqPutTimeout+0x16>
    return MSG_TIMEOUT;
 8000de8:	f04f 30ff 	mov.w	r0, #4294967295
 8000dec:	2300      	movs	r3, #0
 8000dee:	f383 8811 	msr	BASEPRI, r3
}
 8000df2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  *oqp->q_wrptr++ = b;
 8000df6:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 8000df8:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000dfa:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8000dfc:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8000dfe:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 8000e00:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000e02:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000e04:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8000e08:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000e0a:	bf24      	itt	cs
 8000e0c:	68e3      	ldrcs	r3, [r4, #12]
 8000e0e:	6163      	strcs	r3, [r4, #20]
  if (oqp->q_notify != NULL) {
 8000e10:	69e3      	ldr	r3, [r4, #28]
 8000e12:	b10b      	cbz	r3, 8000e18 <oqPutTimeout+0x68>
    oqp->q_notify(oqp);
 8000e14:	4620      	mov	r0, r4
 8000e16:	4798      	blx	r3
 8000e18:	2000      	movs	r0, #0
 8000e1a:	f380 8811 	msr	BASEPRI, r0
}
 8000e1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000e22:	bf00      	nop
 8000e24:	20000a68 	.word	0x20000a68
	...

08000e30 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000e30:	f04f 32ff 	mov.w	r2, #4294967295
 8000e34:	3030      	adds	r0, #48	; 0x30
 8000e36:	f7ff bfbb 	b.w	8000db0 <oqPutTimeout>
 8000e3a:	bf00      	nop
 8000e3c:	0000      	movs	r0, r0
	...

08000e40 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000e40:	3030      	adds	r0, #48	; 0x30
 8000e42:	f7ff bfb5 	b.w	8000db0 <oqPutTimeout>
 8000e46:	bf00      	nop
	...

08000e50 <__putt>:
static msg_t __putt(void *ip, uint8_t b, sysinterval_t timeout) {
 8000e50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000e54:	4605      	mov	r5, r0
 8000e56:	4689      	mov	r9, r1
 8000e58:	4616      	mov	r6, r2
 8000e5a:	2330      	movs	r3, #48	; 0x30
 8000e5c:	f383 8811 	msr	BASEPRI, r3
 8000e60:	4f11      	ldr	r7, [pc, #68]	; (8000ea8 <__putt+0x58>)
  /*lint -save -e506 -e681 [2.1] Silencing this error because it is
    tested with a template implementation of sio_lld_is_tx_full() which
    is constant.*/
  while (sioIsTXFullX(siop)) {
  /*lint -restore*/
    msg = osalThreadSuspendTimeoutS(&siop->sync_tx, timeout);
 8000e62:	f100 0820 	add.w	r8, r0, #32
  while (sioIsTXFullX(siop)) {
 8000e66:	e006      	b.n	8000e76 <__putt+0x26>
  *trp = tp;
 8000e68:	622b      	str	r3, [r5, #32]
  tp->u.wttrp = trp;
 8000e6a:	f8c3 8050 	str.w	r8, [r3, #80]	; 0x50
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8000e6e:	f7ff fe97 	bl	8000ba0 <chSchGoSleepTimeoutS>
    if (msg != MSG_OK) {
 8000e72:	4604      	mov	r4, r0
 8000e74:	b958      	cbnz	r0, 8000e8e <__putt+0x3e>
  while (sioIsTXFullX(siop)) {
 8000e76:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8000e78:	69db      	ldr	r3, [r3, #28]
 8000e7a:	061b      	lsls	r3, r3, #24
 8000e7c:	4631      	mov	r1, r6
 8000e7e:	f04f 0003 	mov.w	r0, #3
 8000e82:	d40f      	bmi.n	8000ea4 <__putt+0x54>
 8000e84:	68fb      	ldr	r3, [r7, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8000e86:	2e00      	cmp	r6, #0
 8000e88:	d1ee      	bne.n	8000e68 <__putt+0x18>
    return MSG_TIMEOUT;
 8000e8a:	f04f 34ff 	mov.w	r4, #4294967295
 8000e8e:	2300      	movs	r3, #0
 8000e90:	f383 8811 	msr	BASEPRI, r3
  if (msg != MSG_OK) {
 8000e94:	b91c      	cbnz	r4, 8000e9e <__putt+0x4e>
  sioPutX(siop, b);
 8000e96:	4649      	mov	r1, r9
 8000e98:	4628      	mov	r0, r5
 8000e9a:	f7ff fb49 	bl	8000530 <sio_lld_put>
}
 8000e9e:	4620      	mov	r0, r4
 8000ea0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000ea4:	2400      	movs	r4, #0
 8000ea6:	e7f2      	b.n	8000e8e <__putt+0x3e>
 8000ea8:	20000a68 	.word	0x20000a68
 8000eac:	00000000 	.word	0x00000000

08000eb0 <sync_write>:
                         sysinterval_t timeout) {
 8000eb0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (i < n) {
 8000eb4:	4690      	mov	r8, r2
 8000eb6:	2a00      	cmp	r2, #0
 8000eb8:	d052      	beq.n	8000f60 <sync_write+0xb0>
  i = 0U;
 8000eba:	2600      	movs	r6, #0
 8000ebc:	4d29      	ldr	r5, [pc, #164]	; (8000f64 <sync_write+0xb4>)
 8000ebe:	4604      	mov	r4, r0
 8000ec0:	468b      	mov	fp, r1
 8000ec2:	461f      	mov	r7, r3
 8000ec4:	46b1      	mov	r9, r6
 8000ec6:	2330      	movs	r3, #48	; 0x30
 8000ec8:	f383 8811 	msr	BASEPRI, r3
    msg = osalThreadSuspendTimeoutS(&siop->sync_tx, timeout);
 8000ecc:	f104 0a20 	add.w	sl, r4, #32
  while (sioIsTXFullX(siop)) {
 8000ed0:	e005      	b.n	8000ede <sync_write+0x2e>
  *trp = tp;
 8000ed2:	6223      	str	r3, [r4, #32]
  tp->u.wttrp = trp;
 8000ed4:	f8c3 a050 	str.w	sl, [r3, #80]	; 0x50
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8000ed8:	f7ff fe62 	bl	8000ba0 <chSchGoSleepTimeoutS>
    if (msg != MSG_OK) {
 8000edc:	b958      	cbnz	r0, 8000ef6 <sync_write+0x46>
  while (sioIsTXFullX(siop)) {
 8000ede:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000ee0:	69db      	ldr	r3, [r3, #28]
 8000ee2:	061a      	lsls	r2, r3, #24
 8000ee4:	4639      	mov	r1, r7
 8000ee6:	f04f 0003 	mov.w	r0, #3
 8000eea:	d433      	bmi.n	8000f54 <sync_write+0xa4>
 8000eec:	68eb      	ldr	r3, [r5, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8000eee:	2f00      	cmp	r7, #0
 8000ef0:	d1ef      	bne.n	8000ed2 <sync_write+0x22>
    return MSG_TIMEOUT;
 8000ef2:	f04f 30ff 	mov.w	r0, #4294967295
 8000ef6:	f389 8811 	msr	BASEPRI, r9
    if (msg != MSG_OK) {
 8000efa:	bb40      	cbnz	r0, 8000f4e <sync_write+0x9e>
    written = sioAsyncWrite(siop, bp, n - i);
 8000efc:	eba8 0c06 	sub.w	ip, r8, r6
 8000f00:	2330      	movs	r3, #48	; 0x30
 8000f02:	f383 8811 	msr	BASEPRI, r3
    if (sio_lld_is_tx_full(siop)) {
 8000f06:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8000f08:	69d3      	ldr	r3, [r2, #28]
 8000f0a:	061b      	lsls	r3, r3, #24
 8000f0c:	d50e      	bpl.n	8000f2c <sync_write+0x7c>
 8000f0e:	44dc      	add	ip, fp
 8000f10:	465b      	mov	r3, fp
 8000f12:	e001      	b.n	8000f18 <sync_write+0x68>
    if (wr >= n) {
 8000f14:	4563      	cmp	r3, ip
 8000f16:	d01f      	beq.n	8000f58 <sync_write+0xa8>
    siop->usart->TDR = (uint32_t)*buffer++;
 8000f18:	f813 1b01 	ldrb.w	r1, [r3], #1
 8000f1c:	6291      	str	r1, [r2, #40]	; 0x28
    if (sio_lld_is_tx_full(siop)) {
 8000f1e:	69d1      	ldr	r1, [r2, #28]
 8000f20:	0609      	lsls	r1, r1, #24
    wr++;
 8000f22:	f100 0001 	add.w	r0, r0, #1
    if (sio_lld_is_tx_full(siop)) {
 8000f26:	d4f5      	bmi.n	8000f14 <sync_write+0x64>
    i += written;
 8000f28:	4406      	add	r6, r0
    bp += written;
 8000f2a:	4483      	add	fp, r0
  if ((siop->enabled & SIO_EV_TXNOTFULL) != 0U) {
 8000f2c:	68e3      	ldr	r3, [r4, #12]
 8000f2e:	0718      	lsls	r0, r3, #28
 8000f30:	d503      	bpl.n	8000f3a <sync_write+0x8a>
    siop->usart->CR3 |= USART_CR3_TXFTIE;
 8000f32:	6891      	ldr	r1, [r2, #8]
 8000f34:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000f38:	6091      	str	r1, [r2, #8]
  if ((siop->enabled & SIO_EV_TXDONE) != 0U) {
 8000f3a:	06db      	lsls	r3, r3, #27
 8000f3c:	d503      	bpl.n	8000f46 <sync_write+0x96>
    siop->usart->CR1 |= USART_CR1_TCIE;
 8000f3e:	6813      	ldr	r3, [r2, #0]
 8000f40:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000f44:	6013      	str	r3, [r2, #0]
 8000f46:	f389 8811 	msr	BASEPRI, r9
  while (i < n) {
 8000f4a:	45b0      	cmp	r8, r6
 8000f4c:	d8bb      	bhi.n	8000ec6 <sync_write+0x16>
}
 8000f4e:	4630      	mov	r0, r6
 8000f50:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000f54:	2000      	movs	r0, #0
 8000f56:	e7ce      	b.n	8000ef6 <sync_write+0x46>
  if ((siop->enabled & SIO_EV_TXNOTFULL) != 0U) {
 8000f58:	68e3      	ldr	r3, [r4, #12]
    i += written;
 8000f5a:	4406      	add	r6, r0
    bp += written;
 8000f5c:	4483      	add	fp, r0
 8000f5e:	e7ec      	b.n	8000f3a <sync_write+0x8a>
  i = 0U;
 8000f60:	4616      	mov	r6, r2
  return i;
 8000f62:	e7f4      	b.n	8000f4e <sync_write+0x9e>
 8000f64:	20000a68 	.word	0x20000a68
	...

08000f70 <__write>:
  return sync_write(ip, bp, n, TIME_INFINITE);
 8000f70:	f04f 33ff 	mov.w	r3, #4294967295
 8000f74:	f7ff bf9c 	b.w	8000eb0 <sync_write>
	...

08000f80 <__writet>:
  return sync_write(ip, bp, n, timeout);
 8000f80:	f7ff bf96 	b.w	8000eb0 <sync_write>
	...

08000f90 <sioSynchronizeRX>:
msg_t sioSynchronizeRX(SIODriver *siop, sysinterval_t timeout) {
 8000f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000f92:	460d      	mov	r5, r1
 8000f94:	2330      	movs	r3, #48	; 0x30
 8000f96:	f383 8811 	msr	BASEPRI, r3
  if (sioHasRXErrorsX(siop)) {
 8000f9a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8000f9c:	69d9      	ldr	r1, [r3, #28]
 8000f9e:	f240 120f 	movw	r2, #271	; 0x10f
 8000fa2:	4211      	tst	r1, r2
 8000fa4:	d119      	bne.n	8000fda <sioSynchronizeRX+0x4a>
 8000fa6:	4e10      	ldr	r6, [pc, #64]	; (8000fe8 <sioSynchronizeRX+0x58>)
 8000fa8:	4604      	mov	r4, r0
    msg = osalThreadSuspendTimeoutS(&siop->sync_rx, timeout);
 8000faa:	f100 0718 	add.w	r7, r0, #24
 8000fae:	e005      	b.n	8000fbc <sioSynchronizeRX+0x2c>
  *trp = tp;
 8000fb0:	61a3      	str	r3, [r4, #24]
  tp->u.wttrp = trp;
 8000fb2:	651f      	str	r7, [r3, #80]	; 0x50
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8000fb4:	f7ff fdf4 	bl	8000ba0 <chSchGoSleepTimeoutS>
    if (msg != MSG_OK) {
 8000fb8:	b958      	cbnz	r0, 8000fd2 <sioSynchronizeRX+0x42>
  while (sioIsRXEmptyX(siop)) {
 8000fba:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000fbc:	69db      	ldr	r3, [r3, #28]
 8000fbe:	069b      	lsls	r3, r3, #26
 8000fc0:	4629      	mov	r1, r5
 8000fc2:	f04f 0003 	mov.w	r0, #3
 8000fc6:	d40d      	bmi.n	8000fe4 <sioSynchronizeRX+0x54>
 8000fc8:	68f3      	ldr	r3, [r6, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8000fca:	2d00      	cmp	r5, #0
 8000fcc:	d1f0      	bne.n	8000fb0 <sioSynchronizeRX+0x20>
    return MSG_TIMEOUT;
 8000fce:	f04f 30ff 	mov.w	r0, #4294967295
 8000fd2:	2300      	movs	r3, #0
 8000fd4:	f383 8811 	msr	BASEPRI, r3
}
 8000fd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000fda:	2300      	movs	r3, #0
 8000fdc:	f383 8811 	msr	BASEPRI, r3
    return SIO_MSG_ERRORS;
 8000fe0:	2001      	movs	r0, #1
}
 8000fe2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000fe4:	2000      	movs	r0, #0
 8000fe6:	e7f4      	b.n	8000fd2 <sioSynchronizeRX+0x42>
 8000fe8:	20000a68 	.word	0x20000a68
 8000fec:	00000000 	.word	0x00000000

08000ff0 <__get>:
static msg_t __get(void *ip) {
 8000ff0:	b510      	push	{r4, lr}
  msg = sioSynchronizeRX(siop, TIME_INFINITE);
 8000ff2:	f04f 31ff 	mov.w	r1, #4294967295
static msg_t __get(void *ip) {
 8000ff6:	4604      	mov	r4, r0
  msg = sioSynchronizeRX(siop, TIME_INFINITE);
 8000ff8:	f7ff ffca 	bl	8000f90 <sioSynchronizeRX>
  if (msg != MSG_OK) {
 8000ffc:	b100      	cbz	r0, 8001000 <__get+0x10>
}
 8000ffe:	bd10      	pop	{r4, pc}
  msg = (msg_t)siop->usart->RDR;
 8001000:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001002:	6a58      	ldr	r0, [r3, #36]	; 0x24
  if (sio_lld_is_rx_empty(siop)) {
 8001004:	69da      	ldr	r2, [r3, #28]
 8001006:	0692      	lsls	r2, r2, #26
 8001008:	d4f9      	bmi.n	8000ffe <__get+0xe>
  if ((siop->enabled & SIO_EV_RXNOTEMPY) != 0U) {
 800100a:	68e2      	ldr	r2, [r4, #12]
 800100c:	0751      	lsls	r1, r2, #29
 800100e:	d503      	bpl.n	8001018 <__get+0x28>
    siop->usart->CR3 |= USART_CR3_RXFTIE;
 8001010:	6899      	ldr	r1, [r3, #8]
 8001012:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001016:	6099      	str	r1, [r3, #8]
  if ((siop->enabled & SIO_EV_RXIDLE) != 0U) {
 8001018:	0592      	lsls	r2, r2, #22
 800101a:	d5f0      	bpl.n	8000ffe <__get+0xe>
    siop->usart->CR1 |= USART_CR1_IDLEIE;
 800101c:	681a      	ldr	r2, [r3, #0]
 800101e:	f042 0210 	orr.w	r2, r2, #16
 8001022:	601a      	str	r2, [r3, #0]
 8001024:	bd10      	pop	{r4, pc}
 8001026:	bf00      	nop
	...

08001030 <__gett>:
static msg_t __gett(void *ip, sysinterval_t timeout) {
 8001030:	b510      	push	{r4, lr}
 8001032:	4604      	mov	r4, r0
  msg = sioSynchronizeRX(siop, timeout);
 8001034:	f7ff ffac 	bl	8000f90 <sioSynchronizeRX>
  if (msg != MSG_OK) {
 8001038:	b100      	cbz	r0, 800103c <__gett+0xc>
}
 800103a:	bd10      	pop	{r4, pc}
  msg = (msg_t)siop->usart->RDR;
 800103c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800103e:	6a58      	ldr	r0, [r3, #36]	; 0x24
  if (sio_lld_is_rx_empty(siop)) {
 8001040:	69da      	ldr	r2, [r3, #28]
 8001042:	0692      	lsls	r2, r2, #26
 8001044:	d4f9      	bmi.n	800103a <__gett+0xa>
  if ((siop->enabled & SIO_EV_RXNOTEMPY) != 0U) {
 8001046:	68e2      	ldr	r2, [r4, #12]
 8001048:	0751      	lsls	r1, r2, #29
 800104a:	d503      	bpl.n	8001054 <__gett+0x24>
    siop->usart->CR3 |= USART_CR3_RXFTIE;
 800104c:	6899      	ldr	r1, [r3, #8]
 800104e:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001052:	6099      	str	r1, [r3, #8]
  if ((siop->enabled & SIO_EV_RXIDLE) != 0U) {
 8001054:	0592      	lsls	r2, r2, #22
 8001056:	d5f0      	bpl.n	800103a <__gett+0xa>
    siop->usart->CR1 |= USART_CR1_IDLEIE;
 8001058:	681a      	ldr	r2, [r3, #0]
 800105a:	f042 0210 	orr.w	r2, r2, #16
 800105e:	601a      	str	r2, [r3, #0]
 8001060:	bd10      	pop	{r4, pc}
 8001062:	bf00      	nop
	...

08001070 <sync_read>:
                        sysinterval_t timeout) {
 8001070:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (i < n) {
 8001074:	4691      	mov	r9, r2
                        sysinterval_t timeout) {
 8001076:	b083      	sub	sp, #12
  while (i < n) {
 8001078:	2a00      	cmp	r2, #0
 800107a:	d068      	beq.n	800114e <sync_read+0xde>
 800107c:	461f      	mov	r7, r3
 800107e:	4e35      	ldr	r6, [pc, #212]	; (8001154 <sync_read+0xe4>)
  i = 0U;
 8001080:	2300      	movs	r3, #0
 8001082:	4604      	mov	r4, r0
 8001084:	4688      	mov	r8, r1
 8001086:	9301      	str	r3, [sp, #4]
 8001088:	f04f 0a30 	mov.w	sl, #48	; 0x30
 800108c:	f38a 8811 	msr	BASEPRI, sl
  if (sioHasRXErrorsX(siop)) {
 8001090:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001092:	69dd      	ldr	r5, [r3, #28]
 8001094:	f240 110f 	movw	r1, #271	; 0x10f
 8001098:	400d      	ands	r5, r1
 800109a:	d14f      	bne.n	800113c <sync_read+0xcc>
    msg = osalThreadSuspendTimeoutS(&siop->sync_rx, timeout);
 800109c:	f104 0b18 	add.w	fp, r4, #24
 80010a0:	e006      	b.n	80010b0 <sync_read+0x40>
  *trp = tp;
 80010a2:	61a3      	str	r3, [r4, #24]
  tp->u.wttrp = trp;
 80010a4:	f8c3 b050 	str.w	fp, [r3, #80]	; 0x50
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80010a8:	f7ff fd7a 	bl	8000ba0 <chSchGoSleepTimeoutS>
    if (msg != MSG_OK) {
 80010ac:	b958      	cbnz	r0, 80010c6 <sync_read+0x56>
  while (sioIsRXEmptyX(siop)) {
 80010ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80010b0:	69db      	ldr	r3, [r3, #28]
 80010b2:	069b      	lsls	r3, r3, #26
 80010b4:	4639      	mov	r1, r7
 80010b6:	f04f 0003 	mov.w	r0, #3
 80010ba:	d446      	bmi.n	800114a <sync_read+0xda>
 80010bc:	68f3      	ldr	r3, [r6, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 80010be:	2f00      	cmp	r7, #0
 80010c0:	d1ef      	bne.n	80010a2 <sync_read+0x32>
    return MSG_TIMEOUT;
 80010c2:	f04f 30ff 	mov.w	r0, #4294967295
 80010c6:	2300      	movs	r3, #0
 80010c8:	f383 8811 	msr	BASEPRI, r3
    if (msg != MSG_OK) {
 80010cc:	bb68      	cbnz	r0, 800112a <sync_read+0xba>
    read = sioAsyncRead(siop, bp, n - i);
 80010ce:	9b01      	ldr	r3, [sp, #4]
 80010d0:	eba9 0c03 	sub.w	ip, r9, r3
 80010d4:	f38a 8811 	msr	BASEPRI, sl
    if (sio_lld_is_rx_empty(siop)) {
 80010d8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80010da:	69d9      	ldr	r1, [r3, #28]
 80010dc:	068a      	lsls	r2, r1, #26
 80010de:	d511      	bpl.n	8001104 <sync_read+0x94>
 80010e0:	44c4      	add	ip, r8
 80010e2:	4641      	mov	r1, r8
 80010e4:	e001      	b.n	80010ea <sync_read+0x7a>
    if (rd >= n) {
 80010e6:	458c      	cmp	ip, r1
 80010e8:	d023      	beq.n	8001132 <sync_read+0xc2>
    *buffer++ = (uint8_t)siop->usart->RDR;
 80010ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80010ec:	f801 3b01 	strb.w	r3, [r1], #1
    if (sio_lld_is_rx_empty(siop)) {
 80010f0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80010f2:	69d8      	ldr	r0, [r3, #28]
 80010f4:	0682      	lsls	r2, r0, #26
    rd++;
 80010f6:	f105 0501 	add.w	r5, r5, #1
    if (sio_lld_is_rx_empty(siop)) {
 80010fa:	d4f4      	bmi.n	80010e6 <sync_read+0x76>
    i += read;
 80010fc:	9a01      	ldr	r2, [sp, #4]
 80010fe:	442a      	add	r2, r5
 8001100:	9201      	str	r2, [sp, #4]
    bp += read;
 8001102:	44a8      	add	r8, r5
  if ((siop->enabled & SIO_EV_RXNOTEMPY) != 0U) {
 8001104:	68e1      	ldr	r1, [r4, #12]
 8001106:	0748      	lsls	r0, r1, #29
 8001108:	d503      	bpl.n	8001112 <sync_read+0xa2>
    siop->usart->CR3 |= USART_CR3_RXFTIE;
 800110a:	6898      	ldr	r0, [r3, #8]
 800110c:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000
 8001110:	6098      	str	r0, [r3, #8]
  if ((siop->enabled & SIO_EV_RXIDLE) != 0U) {
 8001112:	0589      	lsls	r1, r1, #22
 8001114:	d503      	bpl.n	800111e <sync_read+0xae>
    siop->usart->CR1 |= USART_CR1_IDLEIE;
 8001116:	6819      	ldr	r1, [r3, #0]
 8001118:	f041 0110 	orr.w	r1, r1, #16
 800111c:	6019      	str	r1, [r3, #0]
 800111e:	2300      	movs	r3, #0
 8001120:	f383 8811 	msr	BASEPRI, r3
  while (i < n) {
 8001124:	9b01      	ldr	r3, [sp, #4]
 8001126:	4599      	cmp	r9, r3
 8001128:	d8b0      	bhi.n	800108c <sync_read+0x1c>
}
 800112a:	9801      	ldr	r0, [sp, #4]
 800112c:	b003      	add	sp, #12
 800112e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    i += read;
 8001132:	9b01      	ldr	r3, [sp, #4]
 8001134:	442b      	add	r3, r5
 8001136:	9301      	str	r3, [sp, #4]
    bp += read;
 8001138:	44a8      	add	r8, r5
 800113a:	e7f0      	b.n	800111e <sync_read+0xae>
 800113c:	2300      	movs	r3, #0
 800113e:	f383 8811 	msr	BASEPRI, r3
}
 8001142:	9801      	ldr	r0, [sp, #4]
 8001144:	b003      	add	sp, #12
 8001146:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800114a:	2000      	movs	r0, #0
 800114c:	e7bb      	b.n	80010c6 <sync_read+0x56>
  i = 0U;
 800114e:	9201      	str	r2, [sp, #4]
  return i;
 8001150:	e7eb      	b.n	800112a <sync_read+0xba>
 8001152:	bf00      	nop
 8001154:	20000a68 	.word	0x20000a68
	...

08001160 <__read>:
  return sync_read(ip, bp, n, TIME_INFINITE);
 8001160:	f04f 33ff 	mov.w	r3, #4294967295
 8001164:	f7ff bf84 	b.w	8001070 <sync_read>
	...

08001170 <__readt>:
  return sync_read(ip, bp, n, timeout);
 8001170:	f7ff bf7e 	b.w	8001070 <sync_read>
	...

08001180 <thdPWM>:
  0
};

#define WA_PWM_SIZE 512
THD_WORKING_AREA(waPWM, WA_PWM_SIZE);
THD_FUNCTION( thdPWM, arg ) {
 8001180:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 8001184:	4b73      	ldr	r3, [pc, #460]	; (8001354 <thdPWM+0x1d4>)
 8001186:	4a74      	ldr	r2, [pc, #464]	; (8001358 <thdPWM+0x1d8>)
 8001188:	68db      	ldr	r3, [r3, #12]
  (void)arg;
  chRegSetThreadName("pwm");

  palSetPadMode(GPIOB, 4, PAL_MODE_ALTERNATE(2)); //D5       T3-Ch1
 800118a:	4874      	ldr	r0, [pc, #464]	; (800135c <thdPWM+0x1dc>)
 800118c:	645a      	str	r2, [r3, #68]	; 0x44
 800118e:	2110      	movs	r1, #16
 8001190:	f44f 7281 	mov.w	r2, #258	; 0x102
 8001194:	f7ff f974 	bl	8000480 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 7, PAL_MODE_ALTERNATE(2)); //D9       T3-C2
 8001198:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800119c:	f44f 7281 	mov.w	r2, #258	; 0x102
 80011a0:	2180      	movs	r1, #128	; 0x80
 80011a2:	f7ff f96d 	bl	8000480 <_pal_lld_setgroupmode>

  palSetPadMode(GPIOC, 8, PAL_MODE_ALTERNATE(2)); //PC8      T3-C3
 80011a6:	f44f 7281 	mov.w	r2, #258	; 0x102
 80011aa:	f44f 7180 	mov.w	r1, #256	; 0x100
 80011ae:	f7ff f967 	bl	8000480 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 9, PAL_MODE_ALTERNATE(2)); //PC9      T3-C4
 80011b2:	f44f 7281 	mov.w	r2, #258	; 0x102
 80011b6:	f44f 7100 	mov.w	r1, #512	; 0x200
 80011ba:	f7ff f961 	bl	8000480 <_pal_lld_setgroupmode>
 80011be:	2330      	movs	r3, #48	; 0x30
 80011c0:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");

  pwmp->config = config;
 80011c4:	4c66      	ldr	r4, [pc, #408]	; (8001360 <thdPWM+0x1e0>)
 80011c6:	4a67      	ldr	r2, [pc, #412]	; (8001364 <thdPWM+0x1e4>)
 */
void pwm_lld_start(PWMDriver *pwmp) {
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 80011c8:	7821      	ldrb	r1, [r4, #0]
  pwmp->period = config->period;
 80011ca:	6850      	ldr	r0, [r2, #4]
  pwmp->enabled = 0U;
 80011cc:	2300      	movs	r3, #0
 80011ce:	2901      	cmp	r1, #1
  pwmp->period = config->period;
 80011d0:	e9c4 2001 	strd	r2, r0, [r4, #4]
  pwmp->enabled = 0U;
 80011d4:	60e3      	str	r3, [r4, #12]
 80011d6:	f000 81fc 	beq.w	80015d2 <thdPWM+0x452>
                       STM32_TIM_CCMR3_OC6M(6) | STM32_TIM_CCMR3_OC6PE;
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 80011da:	69e1      	ldr	r1, [r4, #28]
 80011dc:	600b      	str	r3, [r1, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
#if STM32_TIM_MAX_CHANNELS > 4
    if (pwmp->channels > 4) {
 80011de:	7c25      	ldrb	r5, [r4, #16]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 80011e0:	634b      	str	r3, [r1, #52]	; 0x34
    if (pwmp->channels > 4) {
 80011e2:	2d04      	cmp	r5, #4
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 80011e4:	638b      	str	r3, [r1, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 80011e6:	63cb      	str	r3, [r1, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 80011e8:	640b      	str	r3, [r1, #64]	; 0x40
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
 80011ea:	bf84      	itt	hi
 80011ec:	648b      	strhi	r3, [r1, #72]	; 0x48
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
 80011ee:	64cb      	strhi	r3, [r1, #76]	; 0x4c
    }
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 80011f0:	2300      	movs	r3, #0
 80011f2:	624b      	str	r3, [r1, #36]	; 0x24
  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
 80011f4:	69e6      	ldr	r6, [r4, #28]
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 80011f6:	6963      	ldr	r3, [r4, #20]
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 80011f8:	68d5      	ldr	r5, [r2, #12]
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 80011fa:	6811      	ldr	r1, [r2, #0]
 80011fc:	fbb3 f3f1 	udiv	r3, r3, r1
 8001200:	3b01      	subs	r3, #1
  pwmp->tim->PSC  = psc;
 8001202:	62b3      	str	r3, [r6, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 8001204:	3801      	subs	r0, #1
  pwmp->tim->CR2  = pwmp->config->cr2;
 8001206:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
  pwmp->tim->ARR  = pwmp->period - 1;
 8001208:	62f0      	str	r0, [r6, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 800120a:	6073      	str	r3, [r6, #4]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 800120c:	f005 030f 	and.w	r3, r5, #15
 8001210:	2b01      	cmp	r3, #1
 8001212:	d057      	beq.n	80012c4 <thdPWM+0x144>
 8001214:	2b02      	cmp	r3, #2
 8001216:	d056      	beq.n	80012c6 <thdPWM+0x146>
 8001218:	2300      	movs	r3, #0
    ccer |= STM32_TIM_CCER_CC1E;
    /* Falls through.*/
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 800121a:	6950      	ldr	r0, [r2, #20]
 800121c:	f000 010f 	and.w	r1, r0, #15
 8001220:	2901      	cmp	r1, #1
 8001222:	d003      	beq.n	800122c <thdPWM+0xac>
 8001224:	2902      	cmp	r1, #2
 8001226:	d103      	bne.n	8001230 <thdPWM+0xb0>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC2P;
 8001228:	f043 0320 	orr.w	r3, r3, #32
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
 800122c:	f043 0310 	orr.w	r3, r3, #16
    /* Falls through.*/
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 8001230:	69d1      	ldr	r1, [r2, #28]
 8001232:	f001 070f 	and.w	r7, r1, #15
 8001236:	2f01      	cmp	r7, #1
 8001238:	d003      	beq.n	8001242 <thdPWM+0xc2>
 800123a:	2f02      	cmp	r7, #2
 800123c:	d103      	bne.n	8001246 <thdPWM+0xc6>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC3P;
 800123e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
 8001242:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    /* Falls through.*/
  default:
    ;
  }
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 8001246:	6a57      	ldr	r7, [r2, #36]	; 0x24
 8001248:	f007 0c0f 	and.w	ip, r7, #15
 800124c:	f1bc 0f01 	cmp.w	ip, #1
 8001250:	d004      	beq.n	800125c <thdPWM+0xdc>
 8001252:	f1bc 0f02 	cmp.w	ip, #2
 8001256:	d103      	bne.n	8001260 <thdPWM+0xe0>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC4P;
 8001258:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC4E;
 800125c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    /* Falls through.*/
  default:
    ;
  }
  if (pwmp->has_bdtr) {
 8001260:	f894 c018 	ldrb.w	ip, [r4, #24]
 8001264:	f1bc 0f00 	cmp.w	ip, #0
 8001268:	d030      	beq.n	80012cc <thdPWM+0x14c>
    switch (pwmp->config->channels[0].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 800126a:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
 800126e:	2d10      	cmp	r5, #16
 8001270:	f000 8199 	beq.w	80015a6 <thdPWM+0x426>
 8001274:	2d20      	cmp	r5, #32
 8001276:	f000 8194 	beq.w	80015a2 <thdPWM+0x422>
      ccer |= STM32_TIM_CCER_CC1NE;
      /* Falls through.*/
    default:
      ;
    }
    switch (pwmp->config->channels[1].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 800127a:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
 800127e:	2810      	cmp	r0, #16
 8001280:	f000 81a4 	beq.w	80015cc <thdPWM+0x44c>
 8001284:	2820      	cmp	r0, #32
 8001286:	f000 819f 	beq.w	80015c8 <thdPWM+0x448>
      ccer |= STM32_TIM_CCER_CC2NE;
      /* Falls through.*/
    default:
      ;
    }
    switch (pwmp->config->channels[2].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 800128a:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
 800128e:	2910      	cmp	r1, #16
 8001290:	f000 818e 	beq.w	80015b0 <thdPWM+0x430>
 8001294:	2920      	cmp	r1, #32
 8001296:	f000 8189 	beq.w	80015ac <thdPWM+0x42c>
      ccer |= STM32_TIM_CCER_CC3NE;
      /* Falls through.*/
    default:
      ;
    }
    switch (pwmp->config->channels[3].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 800129a:	f007 07f0 	and.w	r7, r7, #240	; 0xf0
 800129e:	2f10      	cmp	r7, #16
 80012a0:	f040 818d 	bne.w	80015be <thdPWM+0x43e>
  }

  pwmp->tim->CCER  = ccer;
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 80012a4:	6c51      	ldr	r1, [r2, #68]	; 0x44
      ccer |= STM32_TIM_CCER_CC4NE;
 80012a6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  pwmp->tim->CCER  = ccer;
 80012aa:	6233      	str	r3, [r6, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 80012ac:	2001      	movs	r0, #1
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 80012ae:	2300      	movs	r3, #0
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 80012b0:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 80012b4:	6170      	str	r0, [r6, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 80012b6:	6133      	str	r3, [r6, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 80012b8:	60f1      	str	r1, [r6, #12]
                     ~STM32_TIM_DIER_IRQ_MASK;
  if (pwmp->has_bdtr) {
    pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
 80012ba:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80012bc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80012c0:	6473      	str	r3, [r6, #68]	; 0x44
 80012c2:	e00c      	b.n	80012de <thdPWM+0x15e>
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 80012c4:	2300      	movs	r3, #0
    ccer |= STM32_TIM_CCER_CC1E;
 80012c6:	f043 0301 	orr.w	r3, r3, #1
 80012ca:	e7a6      	b.n	800121a <thdPWM+0x9a>
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 80012cc:	6c52      	ldr	r2, [r2, #68]	; 0x44
  pwmp->tim->CCER  = ccer;
 80012ce:	6233      	str	r3, [r6, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 80012d0:	2101      	movs	r1, #1
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 80012d2:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 80012d6:	6171      	str	r1, [r6, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 80012d8:	f8c6 c010 	str.w	ip, [r6, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 80012dc:	60f2      	str	r2, [r6, #12]
  }
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 80012de:	2385      	movs	r3, #133	; 0x85
#else
  pwm_lld_start(pwmp);
  msg = HAL_RET_SUCCESS;
#endif
  if (msg == HAL_RET_SUCCESS) {
    pwmp->state = PWM_READY;
 80012e0:	2202      	movs	r2, #2
 80012e2:	6033      	str	r3, [r6, #0]
 80012e4:	2300      	movs	r3, #0
 80012e6:	7022      	strb	r2, [r4, #0]
 80012e8:	f383 8811 	msr	BASEPRI, r3
 80012ec:	2530      	movs	r5, #48	; 0x30
 80012ee:	f385 8811 	msr	BASEPRI, r5

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
 80012f2:	68e2      	ldr	r2, [r4, #12]
  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
#else
  if (channel < 4)
    pwmp->tim->CCR[channel] = width;
 80012f4:	69e1      	ldr	r1, [r4, #28]
 80012f6:	f042 0201 	orr.w	r2, r2, #1
 80012fa:	60e2      	str	r2, [r4, #12]
 80012fc:	634b      	str	r3, [r1, #52]	; 0x34
 80012fe:	f383 8811 	msr	BASEPRI, r3
 8001302:	f385 8811 	msr	BASEPRI, r5
 8001306:	68e2      	ldr	r2, [r4, #12]
 8001308:	69e1      	ldr	r1, [r4, #28]
 800130a:	f042 0202 	orr.w	r2, r2, #2
 800130e:	60e2      	str	r2, [r4, #12]
 8001310:	638b      	str	r3, [r1, #56]	; 0x38
 8001312:	f383 8811 	msr	BASEPRI, r3
 8001316:	f385 8811 	msr	BASEPRI, r5
 800131a:	68e2      	ldr	r2, [r4, #12]
 800131c:	69e1      	ldr	r1, [r4, #28]
 800131e:	f042 0204 	orr.w	r2, r2, #4
 8001322:	60e2      	str	r2, [r4, #12]
 8001324:	63cb      	str	r3, [r1, #60]	; 0x3c
 8001326:	f383 8811 	msr	BASEPRI, r3
 800132a:	f385 8811 	msr	BASEPRI, r5
 800132e:	68e2      	ldr	r2, [r4, #12]
 8001330:	69e1      	ldr	r1, [r4, #28]
 8001332:	f042 0208 	orr.w	r2, r2, #8
 8001336:	60e2      	str	r2, [r4, #12]
 8001338:	640b      	str	r3, [r1, #64]	; 0x40
 800133a:	f383 8811 	msr	BASEPRI, r3
 800133e:	f8df 9028 	ldr.w	r9, [pc, #40]	; 8001368 <thdPWM+0x1e8>
 8001342:	f8df a028 	ldr.w	sl, [pc, #40]	; 800136c <thdPWM+0x1ec>
 8001346:	f8df 8028 	ldr.w	r8, [pc, #40]	; 8001370 <thdPWM+0x1f0>
 800134a:	4f0a      	ldr	r7, [pc, #40]	; (8001374 <thdPWM+0x1f4>)
  uint16_t base_speed = 0, speed_reduction = 0;
  uint16_t left_speed = 0, right_speed = 0;

  while(true){
    base_speed = vel_front * 700;
    speed_reduction = (vel_gir * base_speed)/15;
 800134c:	f8df b028 	ldr.w	fp, [pc, #40]	; 8001378 <thdPWM+0x1f8>

    else if (gir == 2){ //SINISTRA
      left_speed = base_speed - (speed_reduction/2);
      right_speed = base_speed + (speed_reduction/2);

      pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * right_speed));
 8001350:	4e0a      	ldr	r6, [pc, #40]	; (800137c <thdPWM+0x1fc>)

  osalSysUnlock();
}
 8001352:	e075      	b.n	8001440 <thdPWM+0x2c0>
 8001354:	20000a68 	.word	0x20000a68
 8001358:	08003354 	.word	0x08003354
 800135c:	48000400 	.word	0x48000400
 8001360:	20000888 	.word	0x20000888
 8001364:	20000800 	.word	0x20000800
 8001368:	20000ca4 	.word	0x20000ca4
 800136c:	20000ca5 	.word	0x20000ca5
 8001370:	20000c61 	.word	0x20000c61
 8001374:	20000c60 	.word	0x20000c60
 8001378:	88888889 	.word	0x88888889
 800137c:	d1b71759 	.word	0xd1b71759
      pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * base_speed));
 8001380:	f897 c000 	ldrb.w	ip, [r7]
 8001384:	68a2      	ldr	r2, [r4, #8]
 8001386:	fb03 fc0c 	mul.w	ip, r3, ip
 800138a:	fb02 fc0c 	mul.w	ip, r2, ip
 800138e:	fba6 2c0c 	umull	r2, ip, r6, ip
 8001392:	ea4f 315c 	mov.w	r1, ip, lsr #13
 8001396:	f385 8811 	msr	BASEPRI, r5
  pwmEnableChannelI(pwmp, channel, width);
 800139a:	68e2      	ldr	r2, [r4, #12]
 800139c:	f042 0201 	orr.w	r2, r2, #1
 80013a0:	60e2      	str	r2, [r4, #12]
 80013a2:	69e2      	ldr	r2, [r4, #28]
 80013a4:	6351      	str	r1, [r2, #52]	; 0x34
 80013a6:	f380 8811 	msr	BASEPRI, r0
      pwmEnableChannel(&PWMD3, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, (1-front) * base_speed));
 80013aa:	f897 c000 	ldrb.w	ip, [r7]
 80013ae:	68a2      	ldr	r2, [r4, #8]
 80013b0:	f1cc 0c01 	rsb	ip, ip, #1
 80013b4:	fb03 fc0c 	mul.w	ip, r3, ip
 80013b8:	fb02 fc0c 	mul.w	ip, r2, ip
 80013bc:	fba6 2c0c 	umull	r2, ip, r6, ip
 80013c0:	ea4f 315c 	mov.w	r1, ip, lsr #13
 80013c4:	f385 8811 	msr	BASEPRI, r5
 80013c8:	68e2      	ldr	r2, [r4, #12]
 80013ca:	f042 0202 	orr.w	r2, r2, #2
 80013ce:	60e2      	str	r2, [r4, #12]
 80013d0:	69e2      	ldr	r2, [r4, #28]
 80013d2:	6391      	str	r1, [r2, #56]	; 0x38
 80013d4:	f380 8811 	msr	BASEPRI, r0
      pwmEnableChannel(&PWMD3, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * base_speed));
 80013d8:	f897 c000 	ldrb.w	ip, [r7]
 80013dc:	68a2      	ldr	r2, [r4, #8]
 80013de:	fb03 fc0c 	mul.w	ip, r3, ip
      pwmEnableChannel(&PWMD3, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, (1-front) * right_speed));

      pwmEnableChannel(&PWMD3, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * left_speed));
 80013e2:	fb02 fc0c 	mul.w	ip, r2, ip
 80013e6:	fba6 2c0c 	umull	r2, ip, r6, ip
 80013ea:	ea4f 315c 	mov.w	r1, ip, lsr #13
 80013ee:	f385 8811 	msr	BASEPRI, r5
 80013f2:	68e2      	ldr	r2, [r4, #12]
 80013f4:	f042 0204 	orr.w	r2, r2, #4
 80013f8:	60e2      	str	r2, [r4, #12]
 80013fa:	69e2      	ldr	r2, [r4, #28]
 80013fc:	63d1      	str	r1, [r2, #60]	; 0x3c
 80013fe:	f380 8811 	msr	BASEPRI, r0
      pwmEnableChannel(&PWMD3, 3, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, (1-front) * left_speed));
 8001402:	7839      	ldrb	r1, [r7, #0]
 8001404:	68a2      	ldr	r2, [r4, #8]
 8001406:	f1c1 0101 	rsb	r1, r1, #1
 800140a:	fb03 f101 	mul.w	r1, r3, r1
 800140e:	fb02 f101 	mul.w	r1, r2, r1
 8001412:	fba6 3101 	umull	r3, r1, r6, r1
 8001416:	0b49      	lsrs	r1, r1, #13
 8001418:	f385 8811 	msr	BASEPRI, r5
 800141c:	68e3      	ldr	r3, [r4, #12]
 800141e:	69e2      	ldr	r2, [r4, #28]
 8001420:	f043 0308 	orr.w	r3, r3, #8
 8001424:	60e3      	str	r3, [r4, #12]
 8001426:	6411      	str	r1, [r2, #64]	; 0x40
 8001428:	f380 8811 	msr	BASEPRI, r0
 800142c:	f385 8811 	msr	BASEPRI, r5
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8001430:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8001434:	2008      	movs	r0, #8
 8001436:	f7ff fbb3 	bl	8000ba0 <chSchGoSleepTimeoutS>
 800143a:	2300      	movs	r3, #0
 800143c:	f383 8811 	msr	BASEPRI, r3
    base_speed = vel_front * 700;
 8001440:	f899 3000 	ldrb.w	r3, [r9]
    speed_reduction = (vel_gir * base_speed)/15;
 8001444:	f89a 2000 	ldrb.w	r2, [sl]
    if(gir == 0){ // AVANTI RECTO
 8001448:	f898 1000 	ldrb.w	r1, [r8]
    base_speed = vel_front * 700;
 800144c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001450:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001454:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8001458:	009b      	lsls	r3, r3, #2
 800145a:	b29b      	uxth	r3, r3
    speed_reduction = (vel_gir * base_speed)/15;
 800145c:	b2d2      	uxtb	r2, r2
    if(gir == 0){ // AVANTI RECTO
 800145e:	f001 00ff 	and.w	r0, r1, #255	; 0xff
 8001462:	2900      	cmp	r1, #0
 8001464:	d08c      	beq.n	8001380 <thdPWM+0x200>
    else if ( gir == 1){ // DIESTRA
 8001466:	f898 1000 	ldrb.w	r1, [r8]
    speed_reduction = (vel_gir * base_speed)/15;
 800146a:	fb03 f202 	mul.w	r2, r3, r2
 800146e:	fbab 0202 	umull	r0, r2, fp, r2
    else if ( gir == 1){ // DIESTRA
 8001472:	2901      	cmp	r1, #1
    speed_reduction = (vel_gir * base_speed)/15;
 8001474:	f3c2 0ccf 	ubfx	ip, r2, #3, #16
    else if ( gir == 1){ // DIESTRA
 8001478:	d039      	beq.n	80014ee <thdPWM+0x36e>
    else if (gir == 2){ //SINISTRA
 800147a:	f898 2000 	ldrb.w	r2, [r8]
 800147e:	2a02      	cmp	r2, #2
 8001480:	d1d4      	bne.n	800142c <thdPWM+0x2ac>
      right_speed = base_speed + (speed_reduction/2);
 8001482:	eb03 015c 	add.w	r1, r3, ip, lsr #1
      pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * right_speed));
 8001486:	7838      	ldrb	r0, [r7, #0]
 8001488:	68a2      	ldr	r2, [r4, #8]
 800148a:	b289      	uxth	r1, r1
 800148c:	fb01 f000 	mul.w	r0, r1, r0
 8001490:	fb02 f000 	mul.w	r0, r2, r0
 8001494:	fba6 2000 	umull	r2, r0, r6, r0
      left_speed = base_speed - (speed_reduction/2);
 8001498:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
      pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * right_speed));
 800149c:	0b40      	lsrs	r0, r0, #13
 800149e:	f385 8811 	msr	BASEPRI, r5
 80014a2:	68e2      	ldr	r2, [r4, #12]
 80014a4:	f042 0201 	orr.w	r2, r2, #1
 80014a8:	60e2      	str	r2, [r4, #12]
 80014aa:	69e2      	ldr	r2, [r4, #28]
 80014ac:	6350      	str	r0, [r2, #52]	; 0x34
 80014ae:	2000      	movs	r0, #0
 80014b0:	f380 8811 	msr	BASEPRI, r0
      pwmEnableChannel(&PWMD3, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, (1-front) * right_speed));
 80014b4:	783a      	ldrb	r2, [r7, #0]
 80014b6:	f1c2 0201 	rsb	r2, r2, #1
 80014ba:	fb02 f101 	mul.w	r1, r2, r1
 80014be:	68a2      	ldr	r2, [r4, #8]
 80014c0:	fb02 f101 	mul.w	r1, r2, r1
 80014c4:	fba6 2101 	umull	r2, r1, r6, r1
 80014c8:	0b49      	lsrs	r1, r1, #13
 80014ca:	f385 8811 	msr	BASEPRI, r5
 80014ce:	68e2      	ldr	r2, [r4, #12]
 80014d0:	f042 0202 	orr.w	r2, r2, #2
 80014d4:	60e2      	str	r2, [r4, #12]
 80014d6:	69e2      	ldr	r2, [r4, #28]
 80014d8:	6391      	str	r1, [r2, #56]	; 0x38
 80014da:	f380 8811 	msr	BASEPRI, r0
      left_speed = base_speed - (speed_reduction/2);
 80014de:	eba3 030c 	sub.w	r3, r3, ip
      pwmEnableChannel(&PWMD3, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * left_speed));
 80014e2:	7839      	ldrb	r1, [r7, #0]
 80014e4:	68a2      	ldr	r2, [r4, #8]
 80014e6:	b29b      	uxth	r3, r3
 80014e8:	fb03 fc01 	mul.w	ip, r3, r1
 80014ec:	e779      	b.n	80013e2 <thdPWM+0x262>
      right_speed = base_speed - (speed_reduction/2);
 80014ee:	eba3 005c 	sub.w	r0, r3, ip, lsr #1
      pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * right_speed));
 80014f2:	7839      	ldrb	r1, [r7, #0]
 80014f4:	68a2      	ldr	r2, [r4, #8]
 80014f6:	b280      	uxth	r0, r0
 80014f8:	fb00 f101 	mul.w	r1, r0, r1
 80014fc:	fb02 f101 	mul.w	r1, r2, r1
 8001500:	fba6 2101 	umull	r2, r1, r6, r1
      left_speed = base_speed + (speed_reduction/2);
 8001504:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
      pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * right_speed));
 8001508:	0b49      	lsrs	r1, r1, #13
 800150a:	f385 8811 	msr	BASEPRI, r5
 800150e:	68e2      	ldr	r2, [r4, #12]
 8001510:	f042 0201 	orr.w	r2, r2, #1
 8001514:	60e2      	str	r2, [r4, #12]
 8001516:	69e2      	ldr	r2, [r4, #28]
 8001518:	6351      	str	r1, [r2, #52]	; 0x34
 800151a:	2100      	movs	r1, #0
 800151c:	f381 8811 	msr	BASEPRI, r1
      pwmEnableChannel(&PWMD3, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, (1-front) * right_speed));
 8001520:	783a      	ldrb	r2, [r7, #0]
 8001522:	f1c2 0201 	rsb	r2, r2, #1
 8001526:	fb02 f000 	mul.w	r0, r2, r0
 800152a:	68a2      	ldr	r2, [r4, #8]
 800152c:	fb02 f000 	mul.w	r0, r2, r0
 8001530:	fba6 2000 	umull	r2, r0, r6, r0
 8001534:	0b40      	lsrs	r0, r0, #13
 8001536:	f385 8811 	msr	BASEPRI, r5
 800153a:	68e2      	ldr	r2, [r4, #12]
 800153c:	f042 0202 	orr.w	r2, r2, #2
 8001540:	60e2      	str	r2, [r4, #12]
 8001542:	69e2      	ldr	r2, [r4, #28]
 8001544:	6390      	str	r0, [r2, #56]	; 0x38
 8001546:	f381 8811 	msr	BASEPRI, r1
      pwmEnableChannel(&PWMD3, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * left_speed));
 800154a:	7838      	ldrb	r0, [r7, #0]
      left_speed = base_speed + (speed_reduction/2);
 800154c:	449c      	add	ip, r3
      pwmEnableChannel(&PWMD3, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, front * left_speed));
 800154e:	fa1f fc8c 	uxth.w	ip, ip
 8001552:	68a3      	ldr	r3, [r4, #8]
 8001554:	fb0c f000 	mul.w	r0, ip, r0
 8001558:	fb03 f000 	mul.w	r0, r3, r0
 800155c:	fba6 3000 	umull	r3, r0, r6, r0
 8001560:	0b40      	lsrs	r0, r0, #13
 8001562:	f385 8811 	msr	BASEPRI, r5
 8001566:	68e3      	ldr	r3, [r4, #12]
 8001568:	69e2      	ldr	r2, [r4, #28]
 800156a:	f043 0304 	orr.w	r3, r3, #4
 800156e:	60e3      	str	r3, [r4, #12]
 8001570:	63d0      	str	r0, [r2, #60]	; 0x3c
 8001572:	f381 8811 	msr	BASEPRI, r1
      pwmEnableChannel(&PWMD3, 3, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, (1-front) * left_speed));
 8001576:	7838      	ldrb	r0, [r7, #0]
 8001578:	68a3      	ldr	r3, [r4, #8]
 800157a:	f1c0 0001 	rsb	r0, r0, #1
 800157e:	fb0c f000 	mul.w	r0, ip, r0
 8001582:	fb03 f000 	mul.w	r0, r3, r0
 8001586:	fba6 3000 	umull	r3, r0, r6, r0
 800158a:	0b40      	lsrs	r0, r0, #13
 800158c:	f385 8811 	msr	BASEPRI, r5
 8001590:	68e3      	ldr	r3, [r4, #12]
 8001592:	69e2      	ldr	r2, [r4, #28]
 8001594:	f043 0308 	orr.w	r3, r3, #8
 8001598:	60e3      	str	r3, [r4, #12]
 800159a:	6410      	str	r0, [r2, #64]	; 0x40
 800159c:	f381 8811 	msr	BASEPRI, r1
}
 80015a0:	e744      	b.n	800142c <thdPWM+0x2ac>
      ccer |= STM32_TIM_CCER_CC1NP;
 80015a2:	f043 0308 	orr.w	r3, r3, #8
      ccer |= STM32_TIM_CCER_CC1NE;
 80015a6:	f043 0304 	orr.w	r3, r3, #4
 80015aa:	e666      	b.n	800127a <thdPWM+0xfa>
      ccer |= STM32_TIM_CCER_CC3NP;
 80015ac:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    switch (pwmp->config->channels[3].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 80015b0:	f007 07f0 	and.w	r7, r7, #240	; 0xf0
 80015b4:	2f10      	cmp	r7, #16
      ccer |= STM32_TIM_CCER_CC3NE;
 80015b6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    switch (pwmp->config->channels[3].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 80015ba:	f43f ae73 	beq.w	80012a4 <thdPWM+0x124>
 80015be:	2f20      	cmp	r7, #32
 80015c0:	d12a      	bne.n	8001618 <thdPWM+0x498>
      ccer |= STM32_TIM_CCER_CC4NP;
 80015c2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80015c6:	e66d      	b.n	80012a4 <thdPWM+0x124>
      ccer |= STM32_TIM_CCER_CC2NP;
 80015c8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
      ccer |= STM32_TIM_CCER_CC2NE;
 80015cc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80015d0:	e65b      	b.n	800128a <thdPWM+0x10a>
      rccEnableTIM3(true);
 80015d2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80015d6:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80015da:	6d99      	ldr	r1, [r3, #88]	; 0x58
 80015dc:	f041 0102 	orr.w	r1, r1, #2
 80015e0:	6599      	str	r1, [r3, #88]	; 0x58
 80015e2:	6f99      	ldr	r1, [r3, #120]	; 0x78
 80015e4:	f041 0102 	orr.w	r1, r1, #2
 80015e8:	6799      	str	r1, [r3, #120]	; 0x78
 80015ea:	6f99      	ldr	r1, [r3, #120]	; 0x78
      rccResetTIM3();
 80015ec:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80015ee:	f041 0102 	orr.w	r1, r1, #2
 80015f2:	6399      	str	r1, [r3, #56]	; 0x38
 80015f4:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80015f6:	f021 0102 	bic.w	r1, r1, #2
 80015fa:	6399      	str	r1, [r3, #56]	; 0x38
 80015fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
      pwmp->clock = STM32_TIMCLK1;
 80015fe:	4907      	ldr	r1, [pc, #28]	; (800161c <thdPWM+0x49c>)
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8001600:	69e3      	ldr	r3, [r4, #28]
      pwmp->clock = STM32_TIMCLK1;
 8001602:	6161      	str	r1, [r4, #20]
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8001604:	f646 0168 	movw	r1, #26728	; 0x6868
 8001608:	6199      	str	r1, [r3, #24]
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 800160a:	61d9      	str	r1, [r3, #28]
    pwmp->tim->CCMR3 = STM32_TIM_CCMR3_OC5M(6) | STM32_TIM_CCMR3_OC5PE |
 800160c:	f101 7180 	add.w	r1, r1, #16777216	; 0x1000000
 8001610:	f501 3180 	add.w	r1, r1, #65536	; 0x10000
 8001614:	6519      	str	r1, [r3, #80]	; 0x50
 8001616:	e5ed      	b.n	80011f4 <thdPWM+0x74>
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8001618:	6c51      	ldr	r1, [r2, #68]	; 0x44
 800161a:	e646      	b.n	80012aa <thdPWM+0x12a>
 800161c:	0a21fe80 	.word	0x0a21fe80

08001620 <chThdCreateStatic.constprop.0.isra.0>:
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8001620:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001622:	4604      	mov	r4, r0
 8001624:	2530      	movs	r5, #48	; 0x30
 8001626:	f385 8811 	msr	BASEPRI, r5
  tp = threadref(((uint8_t *)wsp + size -
 800162a:	f1a1 0c70 	sub.w	ip, r1, #112	; 0x70
 800162e:	4460      	add	r0, ip
  tp->refs              = (trefs_t)1;
 8001630:	2101      	movs	r1, #1
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001632:	6143      	str	r3, [r0, #20]
  tp->name              = name;
 8001634:	4b2b      	ldr	r3, [pc, #172]	; (80016e4 <chThdCreateStatic.constprop.0.isra.0+0xc4>)
 8001636:	6443      	str	r3, [r0, #68]	; 0x44
  tp->owner             = oip;
 8001638:	4b2b      	ldr	r3, [pc, #172]	; (80016e8 <chThdCreateStatic.constprop.0.isra.0+0xc8>)
  tp->hdr.pqueue.prio   = prio;
 800163a:	6082      	str	r2, [r0, #8]
  tp->refs              = (trefs_t)1;
 800163c:	f880 104e 	strb.w	r1, [r0, #78]	; 0x4e
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001640:	f1a0 0e20 	sub.w	lr, r0, #32
 8001644:	4929      	ldr	r1, [pc, #164]	; (80016ec <chThdCreateStatic.constprop.0.isra.0+0xcc>)
  p->prev       = qp->prev;
 8001646:	6adf      	ldr	r7, [r3, #44]	; 0x2c
 8001648:	f840 1c08 	str.w	r1, [r0, #-8]
  thread_t *otp = __instance_get_currthread(oip);
 800164c:	68d9      	ldr	r1, [r3, #12]
 800164e:	f8c0 e00c 	str.w	lr, [r0, #12]
 8001652:	f06f 0e02 	mvn.w	lr, #2
 8001656:	f8c0 e034 	str.w	lr, [r0, #52]	; 0x34
 800165a:	f04f 7e80 	mov.w	lr, #16777216	; 0x1000000
 800165e:	6105      	str	r5, [r0, #16]
  REG_INSERT(oip, tp);
 8001660:	f100 0638 	add.w	r6, r0, #56	; 0x38
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001664:	f840 ec04 	str.w	lr, [r0, #-4]
  tp->realprio          = prio;
 8001668:	6682      	str	r2, [r0, #104]	; 0x68
  ch_queue_init(&tp->msgqueue);
 800166a:	f100 0558 	add.w	r5, r0, #88	; 0x58
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800166e:	2200      	movs	r2, #0
  p->next       = qp;
 8001670:	f103 0e28 	add.w	lr, r3, #40	; 0x28
 8001674:	6182      	str	r2, [r0, #24]
  tp->flags             = CH_FLAG_MODE_STATIC;
 8001676:	f880 204d 	strb.w	r2, [r0, #77]	; 0x4d
  p->prev       = qp->prev;
 800167a:	63c7      	str	r7, [r0, #60]	; 0x3c
  p->next       = qp;
 800167c:	f8c0 e038 	str.w	lr, [r0, #56]	; 0x38
  tp->epending          = (eventmask_t)0;
 8001680:	e9c0 2218 	strd	r2, r2, [r0, #96]	; 0x60
  tp->wabase = (stkalign_t *)wsp;
 8001684:	6484      	str	r4, [r0, #72]	; 0x48
  tp->owner             = oip;
 8001686:	6403      	str	r3, [r0, #64]	; 0x40
  p->prev->next = p;
 8001688:	603e      	str	r6, [r7, #0]
  qp->prev = qp;
 800168a:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
  ch_list_init(&tp->waiting);
 800168e:	f100 0554 	add.w	r5, r0, #84	; 0x54
  qp->prev      = p;
 8001692:	62de      	str	r6, [r3, #44]	; 0x2c
  lp->next = lp;
 8001694:	6545      	str	r5, [r0, #84]	; 0x54
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 8001696:	6886      	ldr	r6, [r0, #8]
 8001698:	688d      	ldr	r5, [r1, #8]
  ntp->u.rdymsg = msg;
 800169a:	6502      	str	r2, [r0, #80]	; 0x50
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 800169c:	42ae      	cmp	r6, r5
 800169e:	d914      	bls.n	80016ca <chThdCreateStatic.constprop.0.isra.0+0xaa>
  tp->state = CH_STATE_READY;
 80016a0:	f881 204c 	strb.w	r2, [r1, #76]	; 0x4c
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 80016a4:	6c0a      	ldr	r2, [r1, #64]	; 0x40
    pqp = pqp->next;
 80016a6:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio > p->prio));
 80016a8:	6894      	ldr	r4, [r2, #8]
 80016aa:	42a5      	cmp	r5, r4
 80016ac:	d3fb      	bcc.n	80016a6 <chThdCreateStatic.constprop.0.isra.0+0x86>
  p->prev       = pqp->prev;
 80016ae:	6854      	ldr	r4, [r2, #4]
 80016b0:	e9c1 2400 	strd	r2, r4, [r1]
  p->prev->next = p;
 80016b4:	6021      	str	r1, [r4, #0]
    ntp->state = CH_STATE_CURRENT;
 80016b6:	2401      	movs	r4, #1
  pqp->prev     = p;
 80016b8:	6051      	str	r1, [r2, #4]
 80016ba:	f880 404c 	strb.w	r4, [r0, #76]	; 0x4c
    __instance_set_currthread(oip, ntp);
 80016be:	60d8      	str	r0, [r3, #12]
    chSysSwitch(ntp, otp);
 80016c0:	df00      	svc	0
 80016c2:	2300      	movs	r3, #0
 80016c4:	f383 8811 	msr	BASEPRI, r3
}
 80016c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  tp->state = CH_STATE_READY;
 80016ca:	f880 204c 	strb.w	r2, [r0, #76]	; 0x4c
    pqp = pqp->next;
 80016ce:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80016d0:	689a      	ldr	r2, [r3, #8]
 80016d2:	4296      	cmp	r6, r2
 80016d4:	d9fb      	bls.n	80016ce <chThdCreateStatic.constprop.0.isra.0+0xae>
  p->prev       = pqp->prev;
 80016d6:	685a      	ldr	r2, [r3, #4]
  p->next       = pqp;
 80016d8:	f844 300c 	str.w	r3, [r4, ip]
  p->prev       = pqp->prev;
 80016dc:	6042      	str	r2, [r0, #4]
  p->prev->next = p;
 80016de:	6010      	str	r0, [r2, #0]
  pqp->prev     = p;
 80016e0:	6058      	str	r0, [r3, #4]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80016e2:	e7ee      	b.n	80016c2 <chThdCreateStatic.constprop.0.isra.0+0xa2>
 80016e4:	08003358 	.word	0x08003358
 80016e8:	20000a68 	.word	0x20000a68
 80016ec:	0800030d 	.word	0x0800030d

080016f0 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 80016f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80016f4:	b083      	sub	sp, #12
  qnotify_t nfy = iqp->q_notify;
 80016f6:	69c7      	ldr	r7, [r0, #28]
                     size_t n, sysinterval_t timeout) {
 80016f8:	9201      	str	r2, [sp, #4]
 80016fa:	469a      	mov	sl, r3
 80016fc:	f04f 0930 	mov.w	r9, #48	; 0x30
 8001700:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 8001704:	2a00      	cmp	r2, #0
 8001706:	d033      	beq.n	8001770 <iqReadTimeout+0x80>
 8001708:	f8dd b004 	ldr.w	fp, [sp, #4]
 800170c:	4604      	mov	r4, r0
 800170e:	460e      	mov	r6, r1
  if (n > iqGetFullI(iqp)) {
 8001710:	68a2      	ldr	r2, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8001712:	69a1      	ldr	r1, [r4, #24]
  if (n > iqGetFullI(iqp)) {
 8001714:	4593      	cmp	fp, r2
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8001716:	6922      	ldr	r2, [r4, #16]
    n = iqGetFullI(iqp);
 8001718:	bf8c      	ite	hi
 800171a:	68a5      	ldrhi	r5, [r4, #8]
 800171c:	465d      	movls	r5, fp
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 800171e:	eba2 0801 	sub.w	r8, r2, r1
  if (n < s1) {
 8001722:	45a8      	cmp	r8, r5
 8001724:	d831      	bhi.n	800178a <iqReadTimeout+0x9a>
  else if (n > s1) {
 8001726:	d22a      	bcs.n	800177e <iqReadTimeout+0x8e>
    s2 = n - s1;
 8001728:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 800172c:	4642      	mov	r2, r8
 800172e:	4630      	mov	r0, r6
    s2 = n - s1;
 8001730:	9300      	str	r3, [sp, #0]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8001732:	f7fe fdf5 	bl	8000320 <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8001736:	eb06 0008 	add.w	r0, r6, r8
 800173a:	f8dd 8000 	ldr.w	r8, [sp]
 800173e:	68e1      	ldr	r1, [r4, #12]
 8001740:	4642      	mov	r2, r8
 8001742:	f7fe fded 	bl	8000320 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8001746:	68e1      	ldr	r1, [r4, #12]
 8001748:	4441      	add	r1, r8
  iqp->q_counter -= n;
 800174a:	68a2      	ldr	r2, [r4, #8]
    iqp->q_rdptr += n;
 800174c:	61a1      	str	r1, [r4, #24]
  iqp->q_counter -= n;
 800174e:	1b52      	subs	r2, r2, r5
 8001750:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 8001752:	b30d      	cbz	r5, 8001798 <iqReadTimeout+0xa8>
      if (nfy != NULL) {
 8001754:	b10f      	cbz	r7, 800175a <iqReadTimeout+0x6a>
        nfy(iqp);
 8001756:	4620      	mov	r0, r4
 8001758:	47b8      	blx	r7
 800175a:	2300      	movs	r3, #0
 800175c:	f383 8811 	msr	BASEPRI, r3
      n  -= done;
 8001760:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 8001764:	442e      	add	r6, r5
 8001766:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 800176a:	f1bb 0f00 	cmp.w	fp, #0
 800176e:	d1cf      	bne.n	8001710 <iqReadTimeout+0x20>
 8001770:	9801      	ldr	r0, [sp, #4]
 8001772:	2300      	movs	r3, #0
 8001774:	f383 8811 	msr	BASEPRI, r3
}
 8001778:	b003      	add	sp, #12
 800177a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800177e:	462a      	mov	r2, r5
 8001780:	4630      	mov	r0, r6
 8001782:	f7fe fdcd 	bl	8000320 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8001786:	68e1      	ldr	r1, [r4, #12]
 8001788:	e7df      	b.n	800174a <iqReadTimeout+0x5a>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800178a:	462a      	mov	r2, r5
 800178c:	4630      	mov	r0, r6
 800178e:	f7fe fdc7 	bl	8000320 <memcpy>
    iqp->q_rdptr += n;
 8001792:	69a1      	ldr	r1, [r4, #24]
 8001794:	4429      	add	r1, r5
 8001796:	e7d8      	b.n	800174a <iqReadTimeout+0x5a>
  return __sch_get_currthread();
 8001798:	4b0c      	ldr	r3, [pc, #48]	; (80017cc <iqReadTimeout+0xdc>)
 800179a:	68da      	ldr	r2, [r3, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 800179c:	f1ba 0f00 	cmp.w	sl, #0
 80017a0:	d00a      	beq.n	80017b8 <iqReadTimeout+0xc8>
  p->prev       = qp->prev;
 80017a2:	6861      	ldr	r1, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80017a4:	2004      	movs	r0, #4
 80017a6:	e9c2 4100 	strd	r4, r1, [r2]
  p->prev->next = p;
 80017aa:	600a      	str	r2, [r1, #0]
 80017ac:	4651      	mov	r1, sl
  qp->prev      = p;
 80017ae:	6062      	str	r2, [r4, #4]
 80017b0:	f7ff f9f6 	bl	8000ba0 <chSchGoSleepTimeoutS>
      if (msg != MSG_OK) {
 80017b4:	2800      	cmp	r0, #0
 80017b6:	d0ab      	beq.n	8001710 <iqReadTimeout+0x20>
  return max - n;
 80017b8:	9b01      	ldr	r3, [sp, #4]
 80017ba:	eba3 000b 	sub.w	r0, r3, fp
 80017be:	2300      	movs	r3, #0
 80017c0:	f383 8811 	msr	BASEPRI, r3
}
 80017c4:	b003      	add	sp, #12
 80017c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80017ca:	bf00      	nop
 80017cc:	20000a68 	.word	0x20000a68

080017d0 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80017d0:	f04f 33ff 	mov.w	r3, #4294967295
 80017d4:	300c      	adds	r0, #12
 80017d6:	f7ff bf8b 	b.w	80016f0 <iqReadTimeout>
 80017da:	bf00      	nop
 80017dc:	0000      	movs	r0, r0
	...

080017e0 <_readt>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80017e0:	300c      	adds	r0, #12
 80017e2:	f7ff bf85 	b.w	80016f0 <iqReadTimeout>
 80017e6:	bf00      	nop
	...

080017f0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 80017f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80017f4:	b083      	sub	sp, #12
  qnotify_t nfy = oqp->q_notify;
 80017f6:	f8d0 801c 	ldr.w	r8, [r0, #28]
                      size_t n, sysinterval_t timeout) {
 80017fa:	9201      	str	r2, [sp, #4]
 80017fc:	469a      	mov	sl, r3
 80017fe:	f04f 0930 	mov.w	r9, #48	; 0x30
 8001802:	f389 8811 	msr	BASEPRI, r9

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8001806:	b382      	cbz	r2, 800186a <oqWriteTimeout+0x7a>
 8001808:	f8dd b004 	ldr.w	fp, [sp, #4]
 800180c:	4604      	mov	r4, r0
 800180e:	460f      	mov	r7, r1
  if (n > oqGetEmptyI(oqp)) {
 8001810:	68a3      	ldr	r3, [r4, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8001812:	e9d4 6004 	ldrd	r6, r0, [r4, #16]
  if (n > oqGetEmptyI(oqp)) {
 8001816:	459b      	cmp	fp, r3
    n = oqGetEmptyI(oqp);
 8001818:	bf8c      	ite	hi
 800181a:	68a5      	ldrhi	r5, [r4, #8]
 800181c:	465d      	movls	r5, fp
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 800181e:	1a36      	subs	r6, r6, r0
  if (n < s1) {
 8001820:	42ae      	cmp	r6, r5
 8001822:	d82f      	bhi.n	8001884 <oqWriteTimeout+0x94>
  else if (n > s1) {
 8001824:	d228      	bcs.n	8001878 <oqWriteTimeout+0x88>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8001826:	4632      	mov	r2, r6
 8001828:	4639      	mov	r1, r7
 800182a:	f7fe fd79 	bl	8000320 <memcpy>
    s2 = n - s1;
 800182e:	1baa      	subs	r2, r5, r6
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8001830:	68e0      	ldr	r0, [r4, #12]
 8001832:	9200      	str	r2, [sp, #0]
 8001834:	19b9      	adds	r1, r7, r6
 8001836:	f7fe fd73 	bl	8000320 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 800183a:	68e3      	ldr	r3, [r4, #12]
 800183c:	9a00      	ldr	r2, [sp, #0]
 800183e:	441a      	add	r2, r3
  oqp->q_counter -= n;
 8001840:	68a3      	ldr	r3, [r4, #8]
    oqp->q_wrptr += n;
 8001842:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
 8001844:	1b5b      	subs	r3, r3, r5
 8001846:	60a3      	str	r3, [r4, #8]
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
 8001848:	b31d      	cbz	r5, 8001892 <oqWriteTimeout+0xa2>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 800184a:	f1b8 0f00 	cmp.w	r8, #0
 800184e:	d001      	beq.n	8001854 <oqWriteTimeout+0x64>
        nfy(oqp);
 8001850:	4620      	mov	r0, r4
 8001852:	47c0      	blx	r8
 8001854:	2300      	movs	r3, #0
 8001856:	f383 8811 	msr	BASEPRI, r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 800185a:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 800185e:	442f      	add	r7, r5
 8001860:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 8001864:	f1bb 0f00 	cmp.w	fp, #0
 8001868:	d1d2      	bne.n	8001810 <oqWriteTimeout+0x20>
 800186a:	9801      	ldr	r0, [sp, #4]
 800186c:	2300      	movs	r3, #0
 800186e:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 8001872:	b003      	add	sp, #12
 8001874:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8001878:	462a      	mov	r2, r5
 800187a:	4639      	mov	r1, r7
 800187c:	f7fe fd50 	bl	8000320 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8001880:	68e2      	ldr	r2, [r4, #12]
 8001882:	e7dd      	b.n	8001840 <oqWriteTimeout+0x50>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8001884:	462a      	mov	r2, r5
 8001886:	4639      	mov	r1, r7
 8001888:	f7fe fd4a 	bl	8000320 <memcpy>
    oqp->q_wrptr += n;
 800188c:	6962      	ldr	r2, [r4, #20]
 800188e:	442a      	add	r2, r5
 8001890:	e7d6      	b.n	8001840 <oqWriteTimeout+0x50>
 8001892:	4b0c      	ldr	r3, [pc, #48]	; (80018c4 <oqWriteTimeout+0xd4>)
 8001894:	68db      	ldr	r3, [r3, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8001896:	f1ba 0f00 	cmp.w	sl, #0
 800189a:	d00a      	beq.n	80018b2 <oqWriteTimeout+0xc2>
  p->prev       = qp->prev;
 800189c:	6862      	ldr	r2, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800189e:	4651      	mov	r1, sl
 80018a0:	e9c3 4200 	strd	r4, r2, [r3]
 80018a4:	2004      	movs	r0, #4
  p->prev->next = p;
 80018a6:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
 80018a8:	6063      	str	r3, [r4, #4]
 80018aa:	f7ff f979 	bl	8000ba0 <chSchGoSleepTimeoutS>
      if (msg != MSG_OK) {
 80018ae:	2800      	cmp	r0, #0
 80018b0:	d0ae      	beq.n	8001810 <oqWriteTimeout+0x20>
  return max - n;
 80018b2:	9b01      	ldr	r3, [sp, #4]
 80018b4:	eba3 000b 	sub.w	r0, r3, fp
 80018b8:	2300      	movs	r3, #0
 80018ba:	f383 8811 	msr	BASEPRI, r3
}
 80018be:	b003      	add	sp, #12
 80018c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80018c4:	20000a68 	.word	0x20000a68
	...

080018d0 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80018d0:	f04f 33ff 	mov.w	r3, #4294967295
 80018d4:	3030      	adds	r0, #48	; 0x30
 80018d6:	f7ff bf8b 	b.w	80017f0 <oqWriteTimeout>
 80018da:	bf00      	nop
 80018dc:	0000      	movs	r0, r0
	...

080018e0 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80018e0:	3030      	adds	r0, #48	; 0x30
 80018e2:	f7ff bf85 	b.w	80017f0 <oqWriteTimeout>
 80018e6:	bf00      	nop
	...

080018f0 <__put>:
static msg_t __put(void *ip, uint8_t b) {
 80018f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80018f2:	4684      	mov	ip, r0
 80018f4:	460f      	mov	r7, r1
 80018f6:	2330      	movs	r3, #48	; 0x30
 80018f8:	f383 8811 	msr	BASEPRI, r3
 80018fc:	4b13      	ldr	r3, [pc, #76]	; (800194c <__put+0x5c>)
    msg = osalThreadSuspendTimeoutS(&siop->sync_tx, timeout);
 80018fe:	f100 0620 	add.w	r6, r0, #32
  otp->state = newstate;
 8001902:	2503      	movs	r5, #3
  ntp->state = CH_STATE_CURRENT;
 8001904:	f04f 0e01 	mov.w	lr, #1
  while (sioIsTXFullX(siop)) {
 8001908:	e00f      	b.n	800192a <__put+0x3a>
 800190a:	68d9      	ldr	r1, [r3, #12]
  ch_priority_queue_t *p = pqp->next;
 800190c:	6818      	ldr	r0, [r3, #0]
  *trp = tp;
 800190e:	f8cc 1020 	str.w	r1, [ip, #32]
  otp->state = newstate;
 8001912:	f881 504c 	strb.w	r5, [r1, #76]	; 0x4c
  pqp->next       = p->next;
 8001916:	6802      	ldr	r2, [r0, #0]
 8001918:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 800191a:	650e      	str	r6, [r1, #80]	; 0x50
  pqp->next->prev = pqp;
 800191c:	6053      	str	r3, [r2, #4]
  ntp->state = CH_STATE_CURRENT;
 800191e:	f880 e04c 	strb.w	lr, [r0, #76]	; 0x4c
  __instance_set_currthread(oip, ntp);
 8001922:	60d8      	str	r0, [r3, #12]
  chSysSwitch(ntp, otp);
 8001924:	df00      	svc	0
  return tp->u.rdymsg;
 8001926:	6d0c      	ldr	r4, [r1, #80]	; 0x50
    if (msg != MSG_OK) {
 8001928:	b92c      	cbnz	r4, 8001936 <__put+0x46>
  while (sioIsTXFullX(siop)) {
 800192a:	f8dc 2028 	ldr.w	r2, [ip, #40]	; 0x28
 800192e:	69d2      	ldr	r2, [r2, #28]
 8001930:	0612      	lsls	r2, r2, #24
 8001932:	d5ea      	bpl.n	800190a <__put+0x1a>
 8001934:	2400      	movs	r4, #0
 8001936:	2300      	movs	r3, #0
 8001938:	f383 8811 	msr	BASEPRI, r3
  if (msg != MSG_OK) {
 800193c:	b91c      	cbnz	r4, 8001946 <__put+0x56>
  sioPutX(siop, b);
 800193e:	4639      	mov	r1, r7
 8001940:	4660      	mov	r0, ip
 8001942:	f7fe fdf5 	bl	8000530 <sio_lld_put>
}
 8001946:	4620      	mov	r0, r4
 8001948:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800194a:	bf00      	nop
 800194c:	20000a68 	.word	0x20000a68

08001950 <chprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001950:	b40e      	push	{r1, r2, r3}
 8001952:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001956:	b086      	sub	sp, #24
 8001958:	ab0f      	add	r3, sp, #60	; 0x3c
 800195a:	f853 6b04 	ldr.w	r6, [r3], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800195e:	9302      	str	r3, [sp, #8]
    c = *fmt++;
 8001960:	4635      	mov	r5, r6
 8001962:	9301      	str	r3, [sp, #4]
 8001964:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 8001968:	2900      	cmp	r1, #0
 800196a:	f000 8201 	beq.w	8001d70 <chprintf+0x420>
 800196e:	4604      	mov	r4, r0
  int n = 0;
 8001970:	f04f 0900 	mov.w	r9, #0
 8001974:	e00c      	b.n	8001990 <chprintf+0x40>
      streamPut(chp, (uint8_t)c);
 8001976:	6823      	ldr	r3, [r4, #0]
 8001978:	4620      	mov	r0, r4
 800197a:	68db      	ldr	r3, [r3, #12]
 800197c:	4798      	blx	r3
      n++;
 800197e:	f109 0901 	add.w	r9, r9, #1
      continue;
 8001982:	462e      	mov	r6, r5
    c = *fmt++;
 8001984:	4635      	mov	r5, r6
 8001986:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 800198a:	2900      	cmp	r1, #0
 800198c:	f000 80d9 	beq.w	8001b42 <chprintf+0x1f2>
    if (c != '%') {
 8001990:	2925      	cmp	r1, #37	; 0x25
 8001992:	d1f0      	bne.n	8001976 <chprintf+0x26>
    if (*fmt == '-') {
 8001994:	7873      	ldrb	r3, [r6, #1]
 8001996:	2b2d      	cmp	r3, #45	; 0x2d
      fmt++;
 8001998:	bf04      	itt	eq
 800199a:	1cb5      	addeq	r5, r6, #2
      left_align = true;
 800199c:	f04f 0c01 	moveq.w	ip, #1
    if (*fmt == '+') {
 80019a0:	782b      	ldrb	r3, [r5, #0]
    left_align = false;
 80019a2:	bf18      	it	ne
 80019a4:	f04f 0c00 	movne.w	ip, #0
    if (*fmt == '+') {
 80019a8:	2b2b      	cmp	r3, #43	; 0x2b
    if (*fmt == '0') {
 80019aa:	bf03      	ittte	eq
 80019ac:	786b      	ldrbeq	r3, [r5, #1]
      do_sign = true;
 80019ae:	f04f 0e01 	moveq.w	lr, #1
      fmt++;
 80019b2:	3501      	addeq	r5, #1
    do_sign = false;
 80019b4:	f04f 0e00 	movne.w	lr, #0
    if (*fmt == '0') {
 80019b8:	2b30      	cmp	r3, #48	; 0x30
      fmt++;
 80019ba:	bf03      	ittte	eq
 80019bc:	3501      	addeq	r5, #1
      filler = '0';
 80019be:	461f      	moveq	r7, r3
    if ( *fmt == '*') {
 80019c0:	782b      	ldrbeq	r3, [r5, #0]
    filler = ' ';
 80019c2:	2720      	movne	r7, #32
    if ( *fmt == '*') {
 80019c4:	2b2a      	cmp	r3, #42	; 0x2a
 80019c6:	d149      	bne.n	8001a5c <chprintf+0x10c>
      c = *fmt++;
 80019c8:	786b      	ldrb	r3, [r5, #1]
      width = va_arg(ap, int);
 80019ca:	f8dd b004 	ldr.w	fp, [sp, #4]
    if (c == '.') {
 80019ce:	2b2e      	cmp	r3, #46	; 0x2e
      width = va_arg(ap, int);
 80019d0:	f85b 2b04 	ldr.w	r2, [fp], #4
      c = *fmt++;
 80019d4:	f105 0602 	add.w	r6, r5, #2
    if (c == '.') {
 80019d8:	d056      	beq.n	8001a88 <chprintf+0x138>
    precision = 0;
 80019da:	2000      	movs	r0, #0
    if (c == 'l' || c == 'L') {
 80019dc:	f003 01df 	and.w	r1, r3, #223	; 0xdf
 80019e0:	294c      	cmp	r1, #76	; 0x4c
 80019e2:	d05f      	beq.n	8001aa4 <chprintf+0x154>
    switch (c) {
 80019e4:	f1a3 0544 	sub.w	r5, r3, #68	; 0x44
 80019e8:	2d34      	cmp	r5, #52	; 0x34
 80019ea:	f200 80b0 	bhi.w	8001b4e <chprintf+0x1fe>
 80019ee:	e8df f015 	tbh	[pc, r5, lsl #1]
 80019f2:	00dc      	.short	0x00dc
 80019f4:	00ae00ae 	.word	0x00ae00ae
 80019f8:	00ae00ae 	.word	0x00ae00ae
 80019fc:	00ae00dc 	.word	0x00ae00dc
 8001a00:	00ae00ae 	.word	0x00ae00ae
 8001a04:	00ae00ae 	.word	0x00ae00ae
 8001a08:	0112014d 	.word	0x0112014d
 8001a0c:	00ae00ae 	.word	0x00ae00ae
 8001a10:	00ae00ae 	.word	0x00ae00ae
 8001a14:	00ae01b4 	.word	0x00ae01b4
 8001a18:	011200ae 	.word	0x011200ae
 8001a1c:	00ae00ae 	.word	0x00ae00ae
 8001a20:	00ae00ae 	.word	0x00ae00ae
 8001a24:	00ae00ae 	.word	0x00ae00ae
 8001a28:	00ae00ae 	.word	0x00ae00ae
 8001a2c:	00ae00ae 	.word	0x00ae00ae
 8001a30:	00dc016f 	.word	0x00dc016f
 8001a34:	00ae00ae 	.word	0x00ae00ae
 8001a38:	00ae00ae 	.word	0x00ae00ae
 8001a3c:	00ae00dc 	.word	0x00ae00dc
 8001a40:	00ae00ae 	.word	0x00ae00ae
 8001a44:	00ae00ae 	.word	0x00ae00ae
 8001a48:	0112014d 	.word	0x0112014d
 8001a4c:	00ae00ae 	.word	0x00ae00ae
 8001a50:	00ae0150 	.word	0x00ae0150
 8001a54:	00ae01b4 	.word	0x00ae01b4
 8001a58:	011200ae 	.word	0x011200ae
        c = *fmt++;
 8001a5c:	1c6e      	adds	r6, r5, #1
        if (c == 0) {
 8001a5e:	2b00      	cmp	r3, #0
 8001a60:	d06f      	beq.n	8001b42 <chprintf+0x1f2>
      width = 0;
 8001a62:	2200      	movs	r2, #0
 8001a64:	e005      	b.n	8001a72 <chprintf+0x122>
        c = *fmt++;
 8001a66:	f816 3b01 	ldrb.w	r3, [r6], #1
          width = width * 10 + c;
 8001a6a:	eb01 0240 	add.w	r2, r1, r0, lsl #1
        if (c == 0) {
 8001a6e:	2b00      	cmp	r3, #0
 8001a70:	d067      	beq.n	8001b42 <chprintf+0x1f2>
        if (c >= '0' && c <= '9') {
 8001a72:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8001a76:	b2c9      	uxtb	r1, r1
 8001a78:	2909      	cmp	r1, #9
          width = width * 10 + c;
 8001a7a:	eb02 0082 	add.w	r0, r2, r2, lsl #2
        if (c >= '0' && c <= '9') {
 8001a7e:	d9f2      	bls.n	8001a66 <chprintf+0x116>
    if (c == '.') {
 8001a80:	2b2e      	cmp	r3, #46	; 0x2e
 8001a82:	f8dd b004 	ldr.w	fp, [sp, #4]
 8001a86:	d1a8      	bne.n	80019da <chprintf+0x8a>
      c = *fmt++;
 8001a88:	7833      	ldrb	r3, [r6, #0]
      if (c == 0) {
 8001a8a:	2b00      	cmp	r3, #0
 8001a8c:	d059      	beq.n	8001b42 <chprintf+0x1f2>
      if (c == '*') {
 8001a8e:	2b2a      	cmp	r3, #42	; 0x2a
 8001a90:	d147      	bne.n	8001b22 <chprintf+0x1d2>
        c = *fmt++;
 8001a92:	7873      	ldrb	r3, [r6, #1]
        precision = va_arg(ap, int);
 8001a94:	f85b 0b04 	ldr.w	r0, [fp], #4
    if (c == 'l' || c == 'L') {
 8001a98:	f003 01df 	and.w	r1, r3, #223	; 0xdf
 8001a9c:	294c      	cmp	r1, #76	; 0x4c
        c = *fmt++;
 8001a9e:	f106 0602 	add.w	r6, r6, #2
    if (c == 'l' || c == 'L') {
 8001aa2:	d19f      	bne.n	80019e4 <chprintf+0x94>
      c = *fmt++;
 8001aa4:	f816 3b01 	ldrb.w	r3, [r6], #1
      if (c == 0) {
 8001aa8:	2b00      	cmp	r3, #0
 8001aaa:	d04a      	beq.n	8001b42 <chprintf+0x1f2>
    switch (c) {
 8001aac:	f1a3 0144 	sub.w	r1, r3, #68	; 0x44
 8001ab0:	2934      	cmp	r1, #52	; 0x34
 8001ab2:	d84c      	bhi.n	8001b4e <chprintf+0x1fe>
 8001ab4:	e8df f011 	tbh	[pc, r1, lsl #1]
 8001ab8:	004b0079 	.word	0x004b0079
 8001abc:	004b004b 	.word	0x004b004b
 8001ac0:	0079004b 	.word	0x0079004b
 8001ac4:	004b004b 	.word	0x004b004b
 8001ac8:	004b004b 	.word	0x004b004b
 8001acc:	00ea004b 	.word	0x00ea004b
 8001ad0:	004b00af 	.word	0x004b00af
 8001ad4:	004b004b 	.word	0x004b004b
 8001ad8:	0151004b 	.word	0x0151004b
 8001adc:	004b004b 	.word	0x004b004b
 8001ae0:	004b00af 	.word	0x004b00af
 8001ae4:	004b004b 	.word	0x004b004b
 8001ae8:	004b004b 	.word	0x004b004b
 8001aec:	004b004b 	.word	0x004b004b
 8001af0:	004b004b 	.word	0x004b004b
 8001af4:	010c004b 	.word	0x010c004b
 8001af8:	004b0079 	.word	0x004b0079
 8001afc:	004b004b 	.word	0x004b004b
 8001b00:	0079004b 	.word	0x0079004b
 8001b04:	004b004b 	.word	0x004b004b
 8001b08:	004b004b 	.word	0x004b004b
 8001b0c:	00ea004b 	.word	0x00ea004b
 8001b10:	004b00af 	.word	0x004b00af
 8001b14:	00ed004b 	.word	0x00ed004b
 8001b18:	0151004b 	.word	0x0151004b
 8001b1c:	004b004b 	.word	0x004b004b
 8001b20:	00af      	.short	0x00af
      c = *fmt++;
 8001b22:	3601      	adds	r6, #1
    precision = 0;
 8001b24:	2000      	movs	r0, #0
        while (c >= '0' && c <= '9') {
 8001b26:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8001b2a:	b2c9      	uxtb	r1, r1
 8001b2c:	2909      	cmp	r1, #9
          precision = precision * 10 + c;
 8001b2e:	eb00 0580 	add.w	r5, r0, r0, lsl #2
        while (c >= '0' && c <= '9') {
 8001b32:	f63f af53 	bhi.w	80019dc <chprintf+0x8c>
          c = *fmt++;
 8001b36:	f816 3b01 	ldrb.w	r3, [r6], #1
          precision = precision * 10 + c;
 8001b3a:	eb01 0045 	add.w	r0, r1, r5, lsl #1
          if (c == 0) {
 8001b3e:	2b00      	cmp	r3, #0
 8001b40:	d1f1      	bne.n	8001b26 <chprintf+0x1d6>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8001b42:	4648      	mov	r0, r9
 8001b44:	b006      	add	sp, #24
 8001b46:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001b4a:	b003      	add	sp, #12
 8001b4c:	4770      	bx	lr
      *p++ = c;
 8001b4e:	f88d 300c 	strb.w	r3, [sp, #12]
      break;
 8001b52:	3a01      	subs	r2, #1
 8001b54:	f8cd b004 	str.w	fp, [sp, #4]
    if ((width -= i) < 0) {
 8001b58:	ea22 7ae2 	bic.w	sl, r2, r2, asr #31
    if (left_align == false) {
 8001b5c:	f1bc 0f00 	cmp.w	ip, #0
 8001b60:	d104      	bne.n	8001b6c <chprintf+0x21c>
    if (width < 0) {
 8001b62:	2a00      	cmp	r2, #0
      width = -width;
 8001b64:	f1ca 0a00 	rsb	sl, sl, #0
    if (width < 0) {
 8001b68:	f300 80e4 	bgt.w	8001d34 <chprintf+0x3e4>
    if (left_align == false) {
 8001b6c:	2500      	movs	r5, #0
 8001b6e:	f10d 0b0c 	add.w	fp, sp, #12
 8001b72:	f105 0801 	add.w	r8, r5, #1
 8001b76:	44d8      	add	r8, fp
      streamPut(chp, (uint8_t)*s++);
 8001b78:	6823      	ldr	r3, [r4, #0]
 8001b7a:	f81b 1b01 	ldrb.w	r1, [fp], #1
 8001b7e:	68db      	ldr	r3, [r3, #12]
 8001b80:	4620      	mov	r0, r4
 8001b82:	4798      	blx	r3
    while (--i >= 0) {
 8001b84:	45c3      	cmp	fp, r8
 8001b86:	d1f7      	bne.n	8001b78 <chprintf+0x228>
 8001b88:	f109 0901 	add.w	r9, r9, #1
      n++;
 8001b8c:	44a9      	add	r9, r5
    while (width) {
 8001b8e:	f1ba 0f00 	cmp.w	sl, #0
 8001b92:	f43f aef7 	beq.w	8001984 <chprintf+0x34>
 8001b96:	4655      	mov	r5, sl
      streamPut(chp, (uint8_t)filler);
 8001b98:	6823      	ldr	r3, [r4, #0]
 8001b9a:	4639      	mov	r1, r7
 8001b9c:	68db      	ldr	r3, [r3, #12]
 8001b9e:	4620      	mov	r0, r4
 8001ba0:	4798      	blx	r3
    while (width) {
 8001ba2:	3d01      	subs	r5, #1
 8001ba4:	d1f8      	bne.n	8001b98 <chprintf+0x248>
      n++;
 8001ba6:	44d1      	add	r9, sl
 8001ba8:	e6ec      	b.n	8001984 <chprintf+0x34>
        l = va_arg(ap, int);
 8001baa:	465b      	mov	r3, fp
 8001bac:	f853 0b04 	ldr.w	r0, [r3], #4
 8001bb0:	9301      	str	r3, [sp, #4]
      if (l < 0) {
 8001bb2:	2800      	cmp	r0, #0
 8001bb4:	f2c0 80b6 	blt.w	8001d24 <chprintf+0x3d4>
        if (do_sign) {
 8001bb8:	f1be 0f00 	cmp.w	lr, #0
 8001bbc:	f000 80d5 	beq.w	8001d6a <chprintf+0x41a>
          *p++ = '+';
 8001bc0:	232b      	movs	r3, #43	; 0x2b
 8001bc2:	f88d 300c 	strb.w	r3, [sp, #12]
 8001bc6:	f10d 0e0d 	add.w	lr, sp, #13
 8001bca:	ab03      	add	r3, sp, #12
  q = p + MAX_FILLER;
 8001bcc:	f10e 0b0b 	add.w	fp, lr, #11
 8001bd0:	465d      	mov	r5, fp
    i = (int)(l % radix);
 8001bd2:	496b      	ldr	r1, [pc, #428]	; (8001d80 <chprintf+0x430>)
 8001bd4:	fba1 8100 	umull	r8, r1, r1, r0
 8001bd8:	08c9      	lsrs	r1, r1, #3
 8001bda:	eb01 0a81 	add.w	sl, r1, r1, lsl #2
 8001bde:	4688      	mov	r8, r1
 8001be0:	eba0 014a 	sub.w	r1, r0, sl, lsl #1
    i += '0';
 8001be4:	3130      	adds	r1, #48	; 0x30
    i = (int)(l % radix);
 8001be6:	4682      	mov	sl, r0
    *--q = i;
 8001be8:	b2c9      	uxtb	r1, r1
  } while ((ll /= radix) != 0);
 8001bea:	f1ba 0f09 	cmp.w	sl, #9
    *--q = i;
 8001bee:	f805 1d01 	strb.w	r1, [r5, #-1]!
    l /= radix;
 8001bf2:	4640      	mov	r0, r8
  } while ((ll /= radix) != 0);
 8001bf4:	dced      	bgt.n	8001bd2 <chprintf+0x282>
  i = (int)(p + MAX_FILLER - q);
 8001bf6:	ebab 0005 	sub.w	r0, fp, r5
 8001bfa:	4470      	add	r0, lr
 8001bfc:	e001      	b.n	8001c02 <chprintf+0x2b2>
    *p++ = *q++;
 8001bfe:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8001c02:	f80e 1b01 	strb.w	r1, [lr], #1
  while (--i);
 8001c06:	4586      	cmp	lr, r0
 8001c08:	d1f9      	bne.n	8001bfe <chprintf+0x2ae>
    i = (int)(p - s);
 8001c0a:	ebae 0503 	sub.w	r5, lr, r3
    if ((width -= i) < 0) {
 8001c0e:	1b52      	subs	r2, r2, r5
    s = tmpbuf;
 8001c10:	469b      	mov	fp, r3
        i--;
 8001c12:	3d01      	subs	r5, #1
 8001c14:	e02d      	b.n	8001c72 <chprintf+0x322>
    switch (c) {
 8001c16:	f04f 0810 	mov.w	r8, #16
        l = va_arg(ap, unsigned int);
 8001c1a:	465b      	mov	r3, fp
 8001c1c:	f853 0b04 	ldr.w	r0, [r3], #4
 8001c20:	9301      	str	r3, [sp, #4]
  q = p + MAX_FILLER;
 8001c22:	f10d 0317 	add.w	r3, sp, #23
 8001c26:	e000      	b.n	8001c2a <chprintf+0x2da>
 8001c28:	462b      	mov	r3, r5
    i = (int)(l % radix);
 8001c2a:	4686      	mov	lr, r0
 8001c2c:	fbb0 f0f8 	udiv	r0, r0, r8
 8001c30:	fb08 ea10 	mls	sl, r8, r0, lr
    i += '0';
 8001c34:	f10a 0130 	add.w	r1, sl, #48	; 0x30
    if (i > '9') {
 8001c38:	2939      	cmp	r1, #57	; 0x39
      i += 'A' - '0' - 10;
 8001c3a:	bfc8      	it	gt
 8001c3c:	f10a 0137 	addgt.w	r1, sl, #55	; 0x37
    *--q = i;
 8001c40:	b2c9      	uxtb	r1, r1
  } while ((ll /= radix) != 0);
 8001c42:	45c6      	cmp	lr, r8
    *--q = i;
 8001c44:	f103 35ff 	add.w	r5, r3, #4294967295
 8001c48:	f803 1c01 	strb.w	r1, [r3, #-1]
  } while ((ll /= radix) != 0);
 8001c4c:	d2ec      	bcs.n	8001c28 <chprintf+0x2d8>
  i = (int)(p + MAX_FILLER - q);
 8001c4e:	f10d 0017 	add.w	r0, sp, #23
 8001c52:	1b45      	subs	r5, r0, r5
 8001c54:	4618      	mov	r0, r3
 8001c56:	ab03      	add	r3, sp, #12
 8001c58:	f10d 0817 	add.w	r8, sp, #23
 8001c5c:	469e      	mov	lr, r3
 8001c5e:	e001      	b.n	8001c64 <chprintf+0x314>
    *p++ = *q++;
 8001c60:	f810 1b01 	ldrb.w	r1, [r0], #1
 8001c64:	f80e 1b01 	strb.w	r1, [lr], #1
  while (--i);
 8001c68:	4540      	cmp	r0, r8
 8001c6a:	d1f9      	bne.n	8001c60 <chprintf+0x310>
    if ((width -= i) < 0) {
 8001c6c:	1b52      	subs	r2, r2, r5
    s = tmpbuf;
 8001c6e:	469b      	mov	fp, r3
        i--;
 8001c70:	3d01      	subs	r5, #1
    if ((width -= i) < 0) {
 8001c72:	ea22 7ae2 	bic.w	sl, r2, r2, asr #31
    if (left_align == false) {
 8001c76:	f1bc 0f00 	cmp.w	ip, #0
 8001c7a:	d103      	bne.n	8001c84 <chprintf+0x334>
    if (width < 0) {
 8001c7c:	2a00      	cmp	r2, #0
      width = -width;
 8001c7e:	f1ca 0a00 	rsb	sl, sl, #0
    if (width < 0) {
 8001c82:	dc2e      	bgt.n	8001ce2 <chprintf+0x392>
    while (--i >= 0) {
 8001c84:	2d00      	cmp	r5, #0
 8001c86:	f6bf af74 	bge.w	8001b72 <chprintf+0x222>
 8001c8a:	e780      	b.n	8001b8e <chprintf+0x23e>
    switch (c) {
 8001c8c:	f04f 0808 	mov.w	r8, #8
 8001c90:	e7c3      	b.n	8001c1a <chprintf+0x2ca>
      if ((s = va_arg(ap, char *)) == 0) {
 8001c92:	465b      	mov	r3, fp
 8001c94:	f853 bb04 	ldr.w	fp, [r3], #4
 8001c98:	9301      	str	r3, [sp, #4]
 8001c9a:	f1bb 0f00 	cmp.w	fp, #0
 8001c9e:	d05f      	beq.n	8001d60 <chprintf+0x410>
      for (p = s; *p && (--precision >= 0); p++)
 8001ca0:	f89b 1000 	ldrb.w	r1, [fp]
      if (precision == 0) {
 8001ca4:	2800      	cmp	r0, #0
 8001ca6:	d14a      	bne.n	8001d3e <chprintf+0x3ee>
      for (p = s; *p && (--precision >= 0); p++)
 8001ca8:	2900      	cmp	r1, #0
 8001caa:	d04b      	beq.n	8001d44 <chprintf+0x3f4>
 8001cac:	f647 70fe 	movw	r0, #32766	; 0x7ffe
 8001cb0:	4659      	mov	r1, fp
 8001cb2:	e001      	b.n	8001cb8 <chprintf+0x368>
 8001cb4:	42c5      	cmn	r5, r0
 8001cb6:	d405      	bmi.n	8001cc4 <chprintf+0x374>
 8001cb8:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8001cbc:	ebab 0501 	sub.w	r5, fp, r1
 8001cc0:	2b00      	cmp	r3, #0
 8001cc2:	d1f7      	bne.n	8001cb4 <chprintf+0x364>
    i = (int)(p - s);
 8001cc4:	eba1 010b 	sub.w	r1, r1, fp
    if ((width -= i) < 0) {
 8001cc8:	1a52      	subs	r2, r2, r1
        i--;
 8001cca:	1e4d      	subs	r5, r1, #1
      filler = ' ';
 8001ccc:	2720      	movs	r7, #32
 8001cce:	e7d0      	b.n	8001c72 <chprintf+0x322>
      *p++ = va_arg(ap, int);
 8001cd0:	f85b 3b04 	ldr.w	r3, [fp], #4
 8001cd4:	f8cd b004 	str.w	fp, [sp, #4]
 8001cd8:	3a01      	subs	r2, #1
 8001cda:	f88d 300c 	strb.w	r3, [sp, #12]
      filler = ' ';
 8001cde:	2720      	movs	r7, #32
      break;
 8001ce0:	e73a      	b.n	8001b58 <chprintf+0x208>
      width = -width;
 8001ce2:	46d0      	mov	r8, sl
      if ((*s == '-' || *s == '+') && filler == '0') {
 8001ce4:	f89b 1000 	ldrb.w	r1, [fp]
 8001ce8:	292d      	cmp	r1, #45	; 0x2d
 8001cea:	d00f      	beq.n	8001d0c <chprintf+0x3bc>
 8001cec:	292b      	cmp	r1, #43	; 0x2b
 8001cee:	d00d      	beq.n	8001d0c <chprintf+0x3bc>
        streamPut(chp, (uint8_t)filler);
 8001cf0:	6823      	ldr	r3, [r4, #0]
 8001cf2:	4639      	mov	r1, r7
 8001cf4:	68db      	ldr	r3, [r3, #12]
 8001cf6:	4620      	mov	r0, r4
 8001cf8:	4798      	blx	r3
      } while (++width != 0);
 8001cfa:	f11a 0a01 	adds.w	sl, sl, #1
 8001cfe:	d1f7      	bne.n	8001cf0 <chprintf+0x3a0>
    while (--i >= 0) {
 8001d00:	2d00      	cmp	r5, #0
 8001d02:	eba9 0908 	sub.w	r9, r9, r8
 8001d06:	f6bf af34 	bge.w	8001b72 <chprintf+0x222>
 8001d0a:	e63b      	b.n	8001984 <chprintf+0x34>
      if ((*s == '-' || *s == '+') && filler == '0') {
 8001d0c:	2f30      	cmp	r7, #48	; 0x30
 8001d0e:	d1ef      	bne.n	8001cf0 <chprintf+0x3a0>
        streamPut(chp, (uint8_t)*s++);
 8001d10:	6822      	ldr	r2, [r4, #0]
 8001d12:	4620      	mov	r0, r4
 8001d14:	68d2      	ldr	r2, [r2, #12]
 8001d16:	f10b 0b01 	add.w	fp, fp, #1
        n++;
 8001d1a:	f109 0901 	add.w	r9, r9, #1
    while (--i >= 0) {
 8001d1e:	3d01      	subs	r5, #1
        streamPut(chp, (uint8_t)*s++);
 8001d20:	4790      	blx	r2
        i--;
 8001d22:	e7e5      	b.n	8001cf0 <chprintf+0x3a0>
        *p++ = '-';
 8001d24:	232d      	movs	r3, #45	; 0x2d
 8001d26:	f88d 300c 	strb.w	r3, [sp, #12]
        l = -l;
 8001d2a:	4240      	negs	r0, r0
        *p++ = '-';
 8001d2c:	f10d 0e0d 	add.w	lr, sp, #13
 8001d30:	ab03      	add	r3, sp, #12
 8001d32:	e74b      	b.n	8001bcc <chprintf+0x27c>
    if (width < 0) {
 8001d34:	4665      	mov	r5, ip
      width = -width;
 8001d36:	46d0      	mov	r8, sl
    if (width < 0) {
 8001d38:	f10d 0b0c 	add.w	fp, sp, #12
 8001d3c:	e7d2      	b.n	8001ce4 <chprintf+0x394>
      for (p = s; *p && (--precision >= 0); p++)
 8001d3e:	b109      	cbz	r1, 8001d44 <chprintf+0x3f4>
 8001d40:	3801      	subs	r0, #1
 8001d42:	d5b5      	bpl.n	8001cb0 <chprintf+0x360>
    if ((width -= i) < 0) {
 8001d44:	ea22 7ae2 	bic.w	sl, r2, r2, asr #31
    if (left_align == false) {
 8001d48:	f1bc 0f00 	cmp.w	ip, #0
 8001d4c:	d103      	bne.n	8001d56 <chprintf+0x406>
    if (width < 0) {
 8001d4e:	2a00      	cmp	r2, #0
      width = -width;
 8001d50:	f1ca 0a00 	rsb	sl, sl, #0
    if (width < 0) {
 8001d54:	dc0e      	bgt.n	8001d74 <chprintf+0x424>
    if (left_align == false) {
 8001d56:	2720      	movs	r7, #32
 8001d58:	e719      	b.n	8001b8e <chprintf+0x23e>
    switch (c) {
 8001d5a:	f04f 080a 	mov.w	r8, #10
 8001d5e:	e75c      	b.n	8001c1a <chprintf+0x2ca>
        s = "(null)";
 8001d60:	f8df b020 	ldr.w	fp, [pc, #32]	; 8001d84 <chprintf+0x434>
      if (precision == 0) {
 8001d64:	2800      	cmp	r0, #0
 8001d66:	d0a1      	beq.n	8001cac <chprintf+0x35c>
 8001d68:	e7ea      	b.n	8001d40 <chprintf+0x3f0>
    p = tmpbuf;
 8001d6a:	ab03      	add	r3, sp, #12
 8001d6c:	469e      	mov	lr, r3
 8001d6e:	e72d      	b.n	8001bcc <chprintf+0x27c>
  int n = 0;
 8001d70:	4689      	mov	r9, r1
  return formatted_bytes;
 8001d72:	e6e6      	b.n	8001b42 <chprintf+0x1f2>
      width = -width;
 8001d74:	46d0      	mov	r8, sl
    if (width < 0) {
 8001d76:	2720      	movs	r7, #32
 8001d78:	f04f 35ff 	mov.w	r5, #4294967295
 8001d7c:	e7b2      	b.n	8001ce4 <chprintf+0x394>
 8001d7e:	bf00      	nop
 8001d80:	cccccccd 	.word	0xcccccccd
 8001d84:	08003360 	.word	0x08003360
	...

08001d90 <thdSerial>:
}


#define WA_SERIAL_SIZE 256
THD_WORKING_AREA(waSerial, WA_SERIAL_SIZE);
THD_FUNCTION( thdSerial, arg ) {
 8001d90:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8001d94:	4b64      	ldr	r3, [pc, #400]	; (8001f28 <thdSerial+0x198>)
 8001d96:	4a65      	ldr	r2, [pc, #404]	; (8001f2c <thdSerial+0x19c>)
 8001d98:	68db      	ldr	r3, [r3, #12]
  (void)arg;
  chRegSetThreadName("serial");

  /* Port configuration. */
  palSetPadMode(GPIOC, 4, PAL_MODE_ALTERNATE(7));   //PC4 - TX
 8001d9a:	4865      	ldr	r0, [pc, #404]	; (8001f30 <thdSerial+0x1a0>)
 8001d9c:	645a      	str	r2, [r3, #68]	; 0x44
THD_FUNCTION( thdSerial, arg ) {
 8001d9e:	b085      	sub	sp, #20
  palSetPadMode(GPIOC, 4, PAL_MODE_ALTERNATE(7));   //PC4 - TX
 8001da0:	f240 3282 	movw	r2, #898	; 0x382
 8001da4:	2110      	movs	r1, #16
 8001da6:	f7fe fb6b 	bl	8000480 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 5, PAL_MODE_ALTERNATE(7));   //PC5 - RX
 8001daa:	f240 3282 	movw	r2, #898	; 0x382
 8001dae:	2120      	movs	r1, #32
 8001db0:	f7fe fb66 	bl	8000480 <_pal_lld_setgroupmode>

  palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));   //TERMINAL PC
 8001db4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001db8:	f240 3282 	movw	r2, #898	; 0x382
 8001dbc:	2104      	movs	r1, #4
 8001dbe:	f7fe fb5f 	bl	8000480 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));
 8001dc2:	f240 3282 	movw	r2, #898	; 0x382
 8001dc6:	2108      	movs	r1, #8
 8001dc8:	f7fe fb5a 	bl	8000480 <_pal_lld_setgroupmode>
 8001dcc:	2530      	movs	r5, #48	; 0x30
 8001dce:	f385 8811 	msr	BASEPRI, r5
  sd_lld_start(sdp, config);
 8001dd2:	4f58      	ldr	r7, [pc, #352]	; (8001f34 <thdSerial+0x1a4>)
    sdp->state = SD_READY;
 8001dd4:	f04f 0802 	mov.w	r8, #2
  sd_lld_start(sdp, config);
 8001dd8:	4638      	mov	r0, r7
 8001dda:	f7fe fc29 	bl	8000630 <sd_lld_start.constprop.0>
 8001dde:	2400      	movs	r4, #0
    sdp->state = SD_READY;
 8001de0:	f887 8008 	strb.w	r8, [r7, #8]
 8001de4:	f384 8811 	msr	BASEPRI, r4
 8001de8:	f385 8811 	msr	BASEPRI, r5
  sd_lld_start(sdp, config);
 8001dec:	4e52      	ldr	r6, [pc, #328]	; (8001f38 <thdSerial+0x1a8>)
 8001dee:	4630      	mov	r0, r6
 8001df0:	f7fe fc1e 	bl	8000630 <sd_lld_start.constprop.0>
    sdp->state = SD_READY;
 8001df4:	f886 8008 	strb.w	r8, [r6, #8]
 8001df8:	f384 8811 	msr	BASEPRI, r4
 8001dfc:	f385 8811 	msr	BASEPRI, r5
  chMtxLockS(mp);
 8001e00:	f7fe fe26 	bl	8000a50 <chMtxLockS.constprop.0>
 8001e04:	f384 8811 	msr	BASEPRI, r4

  sdStart(&SD1, NULL);
  sdStart(&SD2, NULL);

  chMtxLock(&serial_mtx);
  chprintf(chp,"Waiting 5 seconds for the modules to pair...\r\n");
 8001e08:	494c      	ldr	r1, [pc, #304]	; (8001f3c <thdSerial+0x1ac>)
 8001e0a:	4630      	mov	r0, r6
 8001e0c:	f7ff fda0 	bl	8001950 <chprintf>
  chMtxUnlock(&serial_mtx);
 8001e10:	f7fe fdbe 	bl	8000990 <chMtxUnlock.constprop.0>
 8001e14:	f385 8811 	msr	BASEPRI, r5
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8001e18:	f24c 3150 	movw	r1, #50000	; 0xc350
 8001e1c:	2008      	movs	r0, #8
 8001e1e:	f7fe febf 	bl	8000ba0 <chSchGoSleepTimeoutS>
 8001e22:	f384 8811 	msr	BASEPRI, r4
 8001e26:	f385 8811 	msr	BASEPRI, r5
 8001e2a:	f7fe fe11 	bl	8000a50 <chMtxLockS.constprop.0>
 8001e2e:	f384 8811 	msr	BASEPRI, r4

  chThdSleepMilliseconds(5000);

  chMtxLock(&serial_mtx);
  chprintf(chp, "Beginning the communication...\r\n");
 8001e32:	4943      	ldr	r1, [pc, #268]	; (8001f40 <thdSerial+0x1b0>)
 8001e34:	f8df 910c 	ldr.w	r9, [pc, #268]	; 8001f44 <thdSerial+0x1b4>
 8001e38:	f8df b10c 	ldr.w	fp, [pc, #268]	; 8001f48 <thdSerial+0x1b8>
 8001e3c:	f8df 810c 	ldr.w	r8, [pc, #268]	; 8001f4c <thdSerial+0x1bc>
 8001e40:	4630      	mov	r0, r6
 8001e42:	f7ff fd85 	bl	8001950 <chprintf>

  int d1, d2, d3, d4;
  while (true) {
    char buf[16] = {0};

    sdGet((SerialDriver* )HC05Slave);
 8001e46:	370c      	adds	r7, #12
  chMtxUnlock(&serial_mtx);
 8001e48:	f7fe fda2 	bl	8000990 <chMtxUnlock.constprop.0>
    char buf[16] = {0};
 8001e4c:	4626      	mov	r6, r4
 8001e4e:	e022      	b.n	8001e96 <thdSerial+0x106>
      d4 = buf[3] - '0';

      if(d1 == 1){
        front = 1;
      }
      else if(d1 == 9 || d1 == 0){
 8001e50:	f1bc 0f09 	cmp.w	ip, #9
 8001e54:	d002      	beq.n	8001e5c <thdSerial+0xcc>
 8001e56:	f1bc 0f00 	cmp.w	ip, #0
 8001e5a:	d101      	bne.n	8001e60 <thdSerial+0xd0>
        front = 0;
 8001e5c:	f889 4000 	strb.w	r4, [r9]
      }

      if(d2 >= 0 && d2 <= 9){
 8001e60:	2909      	cmp	r1, #9
        vel_front = d2;
 8001e62:	bf9c      	itt	ls
 8001e64:	b2c9      	uxtbls	r1, r1
 8001e66:	f88b 1000 	strbls.w	r1, [fp]
      }

      if(d3 == 1){
 8001e6a:	2b01      	cmp	r3, #1
 8001e6c:	d059      	beq.n	8001f22 <thdSerial+0x192>
        gir = 1;
      }
      else if(d3 == 9 || d3 == 0){
 8001e6e:	2b09      	cmp	r3, #9
 8001e70:	d054      	beq.n	8001f1c <thdSerial+0x18c>
 8001e72:	2b00      	cmp	r3, #0
 8001e74:	d052      	beq.n	8001f1c <thdSerial+0x18c>
        gir = 0;
      }
      else if(d3 == 2){
 8001e76:	2b02      	cmp	r3, #2
 8001e78:	d053      	beq.n	8001f22 <thdSerial+0x192>
        gir = 2;
      }

      if(d4 >= 0 && d4 <= 9){
 8001e7a:	2a09      	cmp	r2, #9
 8001e7c:	d802      	bhi.n	8001e84 <thdSerial+0xf4>
        vel_gir = d4;
 8001e7e:	4b34      	ldr	r3, [pc, #208]	; (8001f50 <thdSerial+0x1c0>)
 8001e80:	b2d2      	uxtb	r2, r2
 8001e82:	701a      	strb	r2, [r3, #0]
 8001e84:	f385 8811 	msr	BASEPRI, r5
 8001e88:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8001e8c:	2008      	movs	r0, #8
 8001e8e:	f7fe fe87 	bl	8000ba0 <chSchGoSleepTimeoutS>
 8001e92:	f386 8811 	msr	BASEPRI, r6
    sdGet((SerialDriver* )HC05Slave);
 8001e96:	f04f 31ff 	mov.w	r1, #4294967295
 8001e9a:	4638      	mov	r0, r7
    char buf[16] = {0};
 8001e9c:	e9cd 4400 	strd	r4, r4, [sp]
 8001ea0:	e9cd 4402 	strd	r4, r4, [sp, #8]
    sdGet((SerialDriver* )HC05Slave);
 8001ea4:	f7fe ff3c 	bl	8000d20 <iqGetTimeout>
    size_t n = sdReadTimeout((SerialDriver* )HC05Slave, (uint8_t* ) buf, 15, TIME_MS2I(100));
 8001ea8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001eac:	220f      	movs	r2, #15
 8001eae:	4669      	mov	r1, sp
 8001eb0:	4638      	mov	r0, r7
 8001eb2:	f7ff fc1d 	bl	80016f0 <iqReadTimeout>
 8001eb6:	4682      	mov	sl, r0
 8001eb8:	f385 8811 	msr	BASEPRI, r5
 8001ebc:	f7fe fdc8 	bl	8000a50 <chMtxLockS.constprop.0>
 8001ec0:	f386 8811 	msr	BASEPRI, r6
    chprintf( chp, "[DBG]: %s\r\n", buf );
 8001ec4:	4923      	ldr	r1, [pc, #140]	; (8001f54 <thdSerial+0x1c4>)
 8001ec6:	481c      	ldr	r0, [pc, #112]	; (8001f38 <thdSerial+0x1a8>)
 8001ec8:	466a      	mov	r2, sp
 8001eca:	f7ff fd41 	bl	8001950 <chprintf>
    chMtxUnlock(&serial_mtx);
 8001ece:	f7fe fd5f 	bl	8000990 <chMtxUnlock.constprop.0>
    if (n >= 4) {
 8001ed2:	f1ba 0f03 	cmp.w	sl, #3
 8001ed6:	d9d5      	bls.n	8001e84 <thdSerial+0xf4>
 8001ed8:	f385 8811 	msr	BASEPRI, r5
 8001edc:	f7fe fdb8 	bl	8000a50 <chMtxLockS.constprop.0>
 8001ee0:	f386 8811 	msr	BASEPRI, r6
      chprintf( chp, "Enter", buf );
 8001ee4:	491c      	ldr	r1, [pc, #112]	; (8001f58 <thdSerial+0x1c8>)
 8001ee6:	4814      	ldr	r0, [pc, #80]	; (8001f38 <thdSerial+0x1a8>)
 8001ee8:	466a      	mov	r2, sp
 8001eea:	f7ff fd31 	bl	8001950 <chprintf>
      chMtxUnlock(&serial_mtx);
 8001eee:	f7fe fd4f 	bl	8000990 <chMtxUnlock.constprop.0>
      d1 = buf[0] - '0';
 8001ef2:	f89d 0000 	ldrb.w	r0, [sp]
      d2 = buf[1] - '0';
 8001ef6:	f89d 1001 	ldrb.w	r1, [sp, #1]
      d3 = buf[2] - '0';
 8001efa:	f89d 3002 	ldrb.w	r3, [sp, #2]
      d4 = buf[3] - '0';
 8001efe:	f89d 2003 	ldrb.w	r2, [sp, #3]
      if(d1 == 1){
 8001f02:	2831      	cmp	r0, #49	; 0x31
      d1 = buf[0] - '0';
 8001f04:	f1a0 0c30 	sub.w	ip, r0, #48	; 0x30
      d2 = buf[1] - '0';
 8001f08:	f1a1 0130 	sub.w	r1, r1, #48	; 0x30
      d3 = buf[2] - '0';
 8001f0c:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
      d4 = buf[3] - '0';
 8001f10:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
      if(d1 == 1){
 8001f14:	d19c      	bne.n	8001e50 <thdSerial+0xc0>
        front = 1;
 8001f16:	f889 c000 	strb.w	ip, [r9]
 8001f1a:	e7a1      	b.n	8001e60 <thdSerial+0xd0>
        gir = 0;
 8001f1c:	f888 4000 	strb.w	r4, [r8]
 8001f20:	e7ab      	b.n	8001e7a <thdSerial+0xea>
        gir = 2;
 8001f22:	f888 3000 	strb.w	r3, [r8]
 8001f26:	e7a8      	b.n	8001e7a <thdSerial+0xea>
 8001f28:	20000a68 	.word	0x20000a68
 8001f2c:	08003368 	.word	0x08003368
 8001f30:	48000800 	.word	0x48000800
 8001f34:	200008a8 	.word	0x200008a8
 8001f38:	20000908 	.word	0x20000908
 8001f3c:	08003370 	.word	0x08003370
 8001f40:	080033a0 	.word	0x080033a0
 8001f44:	20000c60 	.word	0x20000c60
 8001f48:	20000ca4 	.word	0x20000ca4
 8001f4c:	20000c61 	.word	0x20000c61
 8001f50:	20000ca5 	.word	0x20000ca5
 8001f54:	080033c4 	.word	0x080033c4
 8001f58:	080033d0 	.word	0x080033d0
 8001f5c:	00000000 	.word	0x00000000

08001f60 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8001f60:	4770      	bx	lr
 8001f62:	bf00      	nop
	...

08001f70 <__late_init>:
 8001f70:	4770      	bx	lr
 8001f72:	bf00      	nop
	...

08001f80 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 8001f80:	e7fe      	b.n	8001f80 <__default_exit>
 8001f82:	bf00      	nop
	...

08001f90 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001f92:	4d15      	ldr	r5, [pc, #84]	; (8001fe8 <__init_ram_areas+0x58>)
 8001f94:	4f15      	ldr	r7, [pc, #84]	; (8001fec <__init_ram_areas+0x5c>)
 8001f96:	4916      	ldr	r1, [pc, #88]	; (8001ff0 <__init_ram_areas+0x60>)
 8001f98:	4816      	ldr	r0, [pc, #88]	; (8001ff4 <__init_ram_areas+0x64>)
 8001f9a:	4a17      	ldr	r2, [pc, #92]	; (8001ff8 <__init_ram_areas+0x68>)
 8001f9c:	f105 0470 	add.w	r4, r5, #112	; 0x70
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001fa0:	4281      	cmp	r1, r0
 8001fa2:	d90d      	bls.n	8001fc0 <__init_ram_areas+0x30>
 8001fa4:	3a04      	subs	r2, #4
 8001fa6:	4603      	mov	r3, r0
      *p = *tp;
 8001fa8:	f852 6f04 	ldr.w	r6, [r2, #4]!
 8001fac:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->clear_area) {
 8001fb0:	4299      	cmp	r1, r3
 8001fb2:	d8f9      	bhi.n	8001fa8 <__init_ram_areas+0x18>
      p++;
 8001fb4:	1e4b      	subs	r3, r1, #1
 8001fb6:	1a1b      	subs	r3, r3, r0
 8001fb8:	f023 0303 	bic.w	r3, r3, #3
 8001fbc:	3304      	adds	r3, #4
 8001fbe:	4418      	add	r0, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001fc0:	4287      	cmp	r7, r0
 8001fc2:	d907      	bls.n	8001fd4 <__init_ram_areas+0x44>
      *p = 0;
 8001fc4:	1e7a      	subs	r2, r7, #1
 8001fc6:	1a12      	subs	r2, r2, r0
 8001fc8:	f022 0203 	bic.w	r2, r2, #3
 8001fcc:	3204      	adds	r2, #4
 8001fce:	2100      	movs	r1, #0
 8001fd0:	f001 f96e 	bl	80032b0 <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8001fd4:	42a5      	cmp	r5, r4
 8001fd6:	d005      	beq.n	8001fe4 <__init_ram_areas+0x54>
    uint32_t *p = rap->init_area;
 8001fd8:	e9d5 2004 	ldrd	r2, r0, [r5, #16]
    while (p < rap->no_init_area) {
 8001fdc:	e9d5 1706 	ldrd	r1, r7, [r5, #24]
 8001fe0:	3510      	adds	r5, #16
 8001fe2:	e7dd      	b.n	8001fa0 <__init_ram_areas+0x10>
#endif
}
 8001fe4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001fe6:	bf00      	nop
 8001fe8:	08003424 	.word	0x08003424
 8001fec:	200010c8 	.word	0x200010c8
 8001ff0:	200010c8 	.word	0x200010c8
 8001ff4:	200010c8 	.word	0x200010c8
 8001ff8:	0800354c 	.word	0x0800354c
 8001ffc:	00000000 	.word	0x00000000

08002000 <Vector58>:
OSAL_IRQ_HANDLER(STM32_EXTI0_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 0, pr);
 8002000:	4a19      	ldr	r2, [pc, #100]	; (8002068 <Vector58+0x68>)
 8002002:	6953      	ldr	r3, [r2, #20]
 8002004:	f003 0301 	and.w	r3, r3, #1
 8002008:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 0);
 800200a:	b343      	cbz	r3, 800205e <Vector58+0x5e>
OSAL_IRQ_HANDLER(STM32_EXTI0_HANDLER) {
 800200c:	b570      	push	{r4, r5, r6, lr}
  exti_serve_irq(pr, 0);
 800200e:	4c17      	ldr	r4, [pc, #92]	; (800206c <Vector58+0x6c>)
 8002010:	68a3      	ldr	r3, [r4, #8]
 8002012:	b10b      	cbz	r3, 8002018 <Vector58+0x18>
 8002014:	68e0      	ldr	r0, [r4, #12]
 8002016:	4798      	blx	r3
 8002018:	2330      	movs	r3, #48	; 0x30
 800201a:	f383 8811 	msr	BASEPRI, r3
  return (bool)(qp->next != qp);
 800201e:	6821      	ldr	r1, [r4, #0]
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (ch_queue_notempty(&tqp->queue)) {
 8002020:	42a1      	cmp	r1, r4
 8002022:	d014      	beq.n	800204e <Vector58+0x4e>
  tp->u.rdymsg = msg;
 8002024:	2600      	movs	r6, #0
 8002026:	460b      	mov	r3, r1
  qp->next       = p->next;
 8002028:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800202a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 800202c:	689d      	ldr	r5, [r3, #8]
  qp->next       = p->next;
 800202e:	6021      	str	r1, [r4, #0]
  qp->next->prev = qp;
 8002030:	604c      	str	r4, [r1, #4]
 8002032:	651e      	str	r6, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8002034:	f883 604c 	strb.w	r6, [r3, #76]	; 0x4c
    pqp = pqp->next;
 8002038:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800203a:	6890      	ldr	r0, [r2, #8]
 800203c:	42a8      	cmp	r0, r5
 800203e:	d2fb      	bcs.n	8002038 <Vector58+0x38>
  p->prev       = pqp->prev;
 8002040:	6850      	ldr	r0, [r2, #4]
 8002042:	42a1      	cmp	r1, r4
 8002044:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 8002048:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 800204a:	6053      	str	r3, [r2, #4]
 800204c:	d1eb      	bne.n	8002026 <Vector58+0x26>
 800204e:	2300      	movs	r3, #0
 8002050:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
 8002054:	4b06      	ldr	r3, [pc, #24]	; (8002070 <Vector58+0x70>)
 8002056:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800205a:	605a      	str	r2, [r3, #4]
}
 800205c:	bd70      	pop	{r4, r5, r6, pc}
  OSAL_IRQ_EPILOGUE();
 800205e:	4b04      	ldr	r3, [pc, #16]	; (8002070 <Vector58+0x70>)
 8002060:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002064:	605a      	str	r2, [r3, #4]
 8002066:	4770      	bx	lr
 8002068:	40010400 	.word	0x40010400
 800206c:	20000968 	.word	0x20000968
 8002070:	e000ed00 	.word	0xe000ed00
	...

08002080 <Vector5C>:
OSAL_IRQ_HANDLER(STM32_EXTI1_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 1, pr);
 8002080:	4a17      	ldr	r2, [pc, #92]	; (80020e0 <Vector5C+0x60>)
OSAL_IRQ_HANDLER(STM32_EXTI1_HANDLER) {
 8002082:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  extiGetAndClearGroup1(1U << 1, pr);
 8002084:	6953      	ldr	r3, [r2, #20]
 8002086:	f003 0302 	and.w	r3, r3, #2
 800208a:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 1);
 800208c:	b31b      	cbz	r3, 80020d6 <Vector5C+0x56>
 800208e:	4f15      	ldr	r7, [pc, #84]	; (80020e4 <Vector5C+0x64>)
 8002090:	69bb      	ldr	r3, [r7, #24]
 8002092:	b10b      	cbz	r3, 8002098 <Vector5C+0x18>
 8002094:	69f8      	ldr	r0, [r7, #28]
 8002096:	4798      	blx	r3
 8002098:	2330      	movs	r3, #48	; 0x30
 800209a:	f383 8811 	msr	BASEPRI, r3
 800209e:	4c12      	ldr	r4, [pc, #72]	; (80020e8 <Vector5C+0x68>)
  return (bool)(qp->next != qp);
 80020a0:	6939      	ldr	r1, [r7, #16]
 80020a2:	42a1      	cmp	r1, r4
 80020a4:	d014      	beq.n	80020d0 <Vector5C+0x50>
 80020a6:	2600      	movs	r6, #0
 80020a8:	460b      	mov	r3, r1
  qp->next       = p->next;
 80020aa:	6809      	ldr	r1, [r1, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80020ac:	689d      	ldr	r5, [r3, #8]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80020ae:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  qp->next       = p->next;
 80020b0:	6139      	str	r1, [r7, #16]
  qp->next->prev = qp;
 80020b2:	604c      	str	r4, [r1, #4]
 80020b4:	651e      	str	r6, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 80020b6:	f883 604c 	strb.w	r6, [r3, #76]	; 0x4c
    pqp = pqp->next;
 80020ba:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80020bc:	6890      	ldr	r0, [r2, #8]
 80020be:	42a8      	cmp	r0, r5
 80020c0:	d2fb      	bcs.n	80020ba <Vector5C+0x3a>
  p->prev       = pqp->prev;
 80020c2:	6850      	ldr	r0, [r2, #4]
 80020c4:	42a1      	cmp	r1, r4
 80020c6:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 80020ca:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 80020cc:	6053      	str	r3, [r2, #4]
 80020ce:	d1eb      	bne.n	80020a8 <Vector5C+0x28>
 80020d0:	2300      	movs	r3, #0
 80020d2:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
 80020d6:	4b05      	ldr	r3, [pc, #20]	; (80020ec <Vector5C+0x6c>)
 80020d8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80020dc:	605a      	str	r2, [r3, #4]
}
 80020de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80020e0:	40010400 	.word	0x40010400
 80020e4:	20000968 	.word	0x20000968
 80020e8:	20000978 	.word	0x20000978
 80020ec:	e000ed00 	.word	0xe000ed00

080020f0 <Vector60>:
OSAL_IRQ_HANDLER(STM32_EXTI2_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 2, pr);
 80020f0:	4a17      	ldr	r2, [pc, #92]	; (8002150 <Vector60+0x60>)
OSAL_IRQ_HANDLER(STM32_EXTI2_HANDLER) {
 80020f2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  extiGetAndClearGroup1(1U << 2, pr);
 80020f4:	6953      	ldr	r3, [r2, #20]
 80020f6:	f003 0304 	and.w	r3, r3, #4
 80020fa:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 2);
 80020fc:	b31b      	cbz	r3, 8002146 <Vector60+0x56>
 80020fe:	4f15      	ldr	r7, [pc, #84]	; (8002154 <Vector60+0x64>)
 8002100:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002102:	b10b      	cbz	r3, 8002108 <Vector60+0x18>
 8002104:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8002106:	4798      	blx	r3
 8002108:	2330      	movs	r3, #48	; 0x30
 800210a:	f383 8811 	msr	BASEPRI, r3
 800210e:	4c12      	ldr	r4, [pc, #72]	; (8002158 <Vector60+0x68>)
  return (bool)(qp->next != qp);
 8002110:	6a39      	ldr	r1, [r7, #32]
 8002112:	42a1      	cmp	r1, r4
 8002114:	d014      	beq.n	8002140 <Vector60+0x50>
 8002116:	2600      	movs	r6, #0
 8002118:	460b      	mov	r3, r1
  qp->next       = p->next;
 800211a:	6809      	ldr	r1, [r1, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800211c:	689d      	ldr	r5, [r3, #8]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800211e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  qp->next       = p->next;
 8002120:	6239      	str	r1, [r7, #32]
  qp->next->prev = qp;
 8002122:	604c      	str	r4, [r1, #4]
 8002124:	651e      	str	r6, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8002126:	f883 604c 	strb.w	r6, [r3, #76]	; 0x4c
    pqp = pqp->next;
 800212a:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800212c:	6890      	ldr	r0, [r2, #8]
 800212e:	42a8      	cmp	r0, r5
 8002130:	d2fb      	bcs.n	800212a <Vector60+0x3a>
  p->prev       = pqp->prev;
 8002132:	6850      	ldr	r0, [r2, #4]
 8002134:	42a1      	cmp	r1, r4
 8002136:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 800213a:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 800213c:	6053      	str	r3, [r2, #4]
 800213e:	d1eb      	bne.n	8002118 <Vector60+0x28>
 8002140:	2300      	movs	r3, #0
 8002142:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
 8002146:	4b05      	ldr	r3, [pc, #20]	; (800215c <Vector60+0x6c>)
 8002148:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800214c:	605a      	str	r2, [r3, #4]
}
 800214e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002150:	40010400 	.word	0x40010400
 8002154:	20000968 	.word	0x20000968
 8002158:	20000988 	.word	0x20000988
 800215c:	e000ed00 	.word	0xe000ed00

08002160 <Vector64>:
OSAL_IRQ_HANDLER(STM32_EXTI3_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 3, pr);
 8002160:	4a17      	ldr	r2, [pc, #92]	; (80021c0 <Vector64+0x60>)
OSAL_IRQ_HANDLER(STM32_EXTI3_HANDLER) {
 8002162:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  extiGetAndClearGroup1(1U << 3, pr);
 8002164:	6953      	ldr	r3, [r2, #20]
 8002166:	f003 0308 	and.w	r3, r3, #8
 800216a:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 3);
 800216c:	b31b      	cbz	r3, 80021b6 <Vector64+0x56>
 800216e:	4f15      	ldr	r7, [pc, #84]	; (80021c4 <Vector64+0x64>)
 8002170:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8002172:	b10b      	cbz	r3, 8002178 <Vector64+0x18>
 8002174:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8002176:	4798      	blx	r3
 8002178:	2330      	movs	r3, #48	; 0x30
 800217a:	f383 8811 	msr	BASEPRI, r3
 800217e:	4c12      	ldr	r4, [pc, #72]	; (80021c8 <Vector64+0x68>)
  return (bool)(qp->next != qp);
 8002180:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8002182:	42a1      	cmp	r1, r4
 8002184:	d014      	beq.n	80021b0 <Vector64+0x50>
 8002186:	2600      	movs	r6, #0
 8002188:	460b      	mov	r3, r1
  qp->next       = p->next;
 800218a:	6809      	ldr	r1, [r1, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800218c:	689d      	ldr	r5, [r3, #8]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800218e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  qp->next       = p->next;
 8002190:	6339      	str	r1, [r7, #48]	; 0x30
  qp->next->prev = qp;
 8002192:	604c      	str	r4, [r1, #4]
 8002194:	651e      	str	r6, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8002196:	f883 604c 	strb.w	r6, [r3, #76]	; 0x4c
    pqp = pqp->next;
 800219a:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800219c:	6890      	ldr	r0, [r2, #8]
 800219e:	42a8      	cmp	r0, r5
 80021a0:	d2fb      	bcs.n	800219a <Vector64+0x3a>
  p->prev       = pqp->prev;
 80021a2:	6850      	ldr	r0, [r2, #4]
 80021a4:	42a1      	cmp	r1, r4
 80021a6:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 80021aa:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 80021ac:	6053      	str	r3, [r2, #4]
 80021ae:	d1eb      	bne.n	8002188 <Vector64+0x28>
 80021b0:	2300      	movs	r3, #0
 80021b2:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
 80021b6:	4b05      	ldr	r3, [pc, #20]	; (80021cc <Vector64+0x6c>)
 80021b8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80021bc:	605a      	str	r2, [r3, #4]
}
 80021be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80021c0:	40010400 	.word	0x40010400
 80021c4:	20000968 	.word	0x20000968
 80021c8:	20000998 	.word	0x20000998
 80021cc:	e000ed00 	.word	0xe000ed00

080021d0 <Vector68>:
OSAL_IRQ_HANDLER(STM32_EXTI4_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 4, pr);
 80021d0:	4a17      	ldr	r2, [pc, #92]	; (8002230 <Vector68+0x60>)
OSAL_IRQ_HANDLER(STM32_EXTI4_HANDLER) {
 80021d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  extiGetAndClearGroup1(1U << 4, pr);
 80021d4:	6953      	ldr	r3, [r2, #20]
 80021d6:	f003 0310 	and.w	r3, r3, #16
 80021da:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 4);
 80021dc:	b31b      	cbz	r3, 8002226 <Vector68+0x56>
 80021de:	4f15      	ldr	r7, [pc, #84]	; (8002234 <Vector68+0x64>)
 80021e0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80021e2:	b10b      	cbz	r3, 80021e8 <Vector68+0x18>
 80021e4:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80021e6:	4798      	blx	r3
 80021e8:	2330      	movs	r3, #48	; 0x30
 80021ea:	f383 8811 	msr	BASEPRI, r3
 80021ee:	4c12      	ldr	r4, [pc, #72]	; (8002238 <Vector68+0x68>)
  return (bool)(qp->next != qp);
 80021f0:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80021f2:	42a1      	cmp	r1, r4
 80021f4:	d014      	beq.n	8002220 <Vector68+0x50>
 80021f6:	2600      	movs	r6, #0
 80021f8:	460b      	mov	r3, r1
  qp->next       = p->next;
 80021fa:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80021fc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 80021fe:	689d      	ldr	r5, [r3, #8]
  qp->next       = p->next;
 8002200:	6439      	str	r1, [r7, #64]	; 0x40
  qp->next->prev = qp;
 8002202:	604c      	str	r4, [r1, #4]
 8002204:	651e      	str	r6, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8002206:	f883 604c 	strb.w	r6, [r3, #76]	; 0x4c
    pqp = pqp->next;
 800220a:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800220c:	6890      	ldr	r0, [r2, #8]
 800220e:	42a8      	cmp	r0, r5
 8002210:	d2fb      	bcs.n	800220a <Vector68+0x3a>
  p->prev       = pqp->prev;
 8002212:	6850      	ldr	r0, [r2, #4]
 8002214:	42a1      	cmp	r1, r4
 8002216:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 800221a:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 800221c:	6053      	str	r3, [r2, #4]
 800221e:	d1eb      	bne.n	80021f8 <Vector68+0x28>
 8002220:	2300      	movs	r3, #0
 8002222:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
 8002226:	4b05      	ldr	r3, [pc, #20]	; (800223c <Vector68+0x6c>)
 8002228:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800222c:	605a      	str	r2, [r3, #4]
}
 800222e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002230:	40010400 	.word	0x40010400
 8002234:	20000968 	.word	0x20000968
 8002238:	200009a8 	.word	0x200009a8
 800223c:	e000ed00 	.word	0xe000ed00

08002240 <Vector9C>:
/**
 * @brief   EXTI[5]..EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI5_9_HANDLER) {
 8002240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 8002242:	4b6c      	ldr	r3, [pc, #432]	; (80023f4 <Vector9C+0x1b4>)
 8002244:	695d      	ldr	r5, [r3, #20]
 8002246:	f405 7278 	and.w	r2, r5, #992	; 0x3e0
                        (1U << 9), pr);

  exti_serve_irq(pr, 5);
 800224a:	06ac      	lsls	r4, r5, #26
  extiGetAndClearGroup1((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 800224c:	615a      	str	r2, [r3, #20]
  exti_serve_irq(pr, 5);
 800224e:	d525      	bpl.n	800229c <Vector9C+0x5c>
 8002250:	4c69      	ldr	r4, [pc, #420]	; (80023f8 <Vector9C+0x1b8>)
 8002252:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002254:	b10b      	cbz	r3, 800225a <Vector9C+0x1a>
 8002256:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8002258:	4798      	blx	r3
 800225a:	2330      	movs	r3, #48	; 0x30
 800225c:	f383 8811 	msr	BASEPRI, r3
 8002260:	4e66      	ldr	r6, [pc, #408]	; (80023fc <Vector9C+0x1bc>)
  return (bool)(qp->next != qp);
 8002262:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8002264:	42b1      	cmp	r1, r6
 8002266:	d016      	beq.n	8002296 <Vector9C+0x56>
 8002268:	f04f 0c00 	mov.w	ip, #0
 800226c:	460b      	mov	r3, r1
  qp->next       = p->next;
 800226e:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8002270:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 8002272:	689f      	ldr	r7, [r3, #8]
  qp->next       = p->next;
 8002274:	6521      	str	r1, [r4, #80]	; 0x50
  qp->next->prev = qp;
 8002276:	604e      	str	r6, [r1, #4]
 8002278:	f8c3 c050 	str.w	ip, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 800227c:	f883 c04c 	strb.w	ip, [r3, #76]	; 0x4c
    pqp = pqp->next;
 8002280:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8002282:	6890      	ldr	r0, [r2, #8]
 8002284:	42b8      	cmp	r0, r7
 8002286:	d2fb      	bcs.n	8002280 <Vector9C+0x40>
  p->prev       = pqp->prev;
 8002288:	6850      	ldr	r0, [r2, #4]
 800228a:	42b1      	cmp	r1, r6
 800228c:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 8002290:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 8002292:	6053      	str	r3, [r2, #4]
 8002294:	d1ea      	bne.n	800226c <Vector9C+0x2c>
 8002296:	2300      	movs	r3, #0
 8002298:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 6);
 800229c:	0668      	lsls	r0, r5, #25
 800229e:	d525      	bpl.n	80022ec <Vector9C+0xac>
 80022a0:	4c55      	ldr	r4, [pc, #340]	; (80023f8 <Vector9C+0x1b8>)
 80022a2:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80022a4:	b10b      	cbz	r3, 80022aa <Vector9C+0x6a>
 80022a6:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80022a8:	4798      	blx	r3
 80022aa:	2330      	movs	r3, #48	; 0x30
 80022ac:	f383 8811 	msr	BASEPRI, r3
 80022b0:	4e53      	ldr	r6, [pc, #332]	; (8002400 <Vector9C+0x1c0>)
  return (bool)(qp->next != qp);
 80022b2:	6e21      	ldr	r1, [r4, #96]	; 0x60
 80022b4:	42b1      	cmp	r1, r6
 80022b6:	d016      	beq.n	80022e6 <Vector9C+0xa6>
 80022b8:	f04f 0c00 	mov.w	ip, #0
 80022bc:	460b      	mov	r3, r1
  qp->next       = p->next;
 80022be:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80022c0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 80022c2:	689f      	ldr	r7, [r3, #8]
  qp->next       = p->next;
 80022c4:	6621      	str	r1, [r4, #96]	; 0x60
  qp->next->prev = qp;
 80022c6:	604e      	str	r6, [r1, #4]
 80022c8:	f8c3 c050 	str.w	ip, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 80022cc:	f883 c04c 	strb.w	ip, [r3, #76]	; 0x4c
    pqp = pqp->next;
 80022d0:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80022d2:	6890      	ldr	r0, [r2, #8]
 80022d4:	42b8      	cmp	r0, r7
 80022d6:	d2fb      	bcs.n	80022d0 <Vector9C+0x90>
  p->prev       = pqp->prev;
 80022d8:	6850      	ldr	r0, [r2, #4]
 80022da:	42b1      	cmp	r1, r6
 80022dc:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 80022e0:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 80022e2:	6053      	str	r3, [r2, #4]
 80022e4:	d1ea      	bne.n	80022bc <Vector9C+0x7c>
 80022e6:	2300      	movs	r3, #0
 80022e8:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 7);
 80022ec:	0629      	lsls	r1, r5, #24
 80022ee:	d525      	bpl.n	800233c <Vector9C+0xfc>
 80022f0:	4c41      	ldr	r4, [pc, #260]	; (80023f8 <Vector9C+0x1b8>)
 80022f2:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80022f4:	b10b      	cbz	r3, 80022fa <Vector9C+0xba>
 80022f6:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80022f8:	4798      	blx	r3
 80022fa:	2330      	movs	r3, #48	; 0x30
 80022fc:	f383 8811 	msr	BASEPRI, r3
 8002300:	4e40      	ldr	r6, [pc, #256]	; (8002404 <Vector9C+0x1c4>)
  return (bool)(qp->next != qp);
 8002302:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8002304:	42b1      	cmp	r1, r6
 8002306:	d016      	beq.n	8002336 <Vector9C+0xf6>
 8002308:	f04f 0c00 	mov.w	ip, #0
 800230c:	460b      	mov	r3, r1
  qp->next       = p->next;
 800230e:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8002310:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 8002312:	689f      	ldr	r7, [r3, #8]
  qp->next       = p->next;
 8002314:	6721      	str	r1, [r4, #112]	; 0x70
  qp->next->prev = qp;
 8002316:	604e      	str	r6, [r1, #4]
 8002318:	f8c3 c050 	str.w	ip, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 800231c:	f883 c04c 	strb.w	ip, [r3, #76]	; 0x4c
    pqp = pqp->next;
 8002320:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8002322:	6890      	ldr	r0, [r2, #8]
 8002324:	42b8      	cmp	r0, r7
 8002326:	d2fb      	bcs.n	8002320 <Vector9C+0xe0>
  p->prev       = pqp->prev;
 8002328:	6850      	ldr	r0, [r2, #4]
 800232a:	42b1      	cmp	r1, r6
 800232c:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 8002330:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 8002332:	6053      	str	r3, [r2, #4]
 8002334:	d1ea      	bne.n	800230c <Vector9C+0xcc>
 8002336:	2300      	movs	r3, #0
 8002338:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 8);
 800233c:	05ea      	lsls	r2, r5, #23
 800233e:	d529      	bpl.n	8002394 <Vector9C+0x154>
 8002340:	4c2d      	ldr	r4, [pc, #180]	; (80023f8 <Vector9C+0x1b8>)
 8002342:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8002346:	b113      	cbz	r3, 800234e <Vector9C+0x10e>
 8002348:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 800234c:	4798      	blx	r3
 800234e:	2330      	movs	r3, #48	; 0x30
 8002350:	f383 8811 	msr	BASEPRI, r3
 8002354:	4e2c      	ldr	r6, [pc, #176]	; (8002408 <Vector9C+0x1c8>)
  return (bool)(qp->next != qp);
 8002356:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 800235a:	42b1      	cmp	r1, r6
 800235c:	d017      	beq.n	800238e <Vector9C+0x14e>
 800235e:	f04f 0c00 	mov.w	ip, #0
 8002362:	460b      	mov	r3, r1
  qp->next       = p->next;
 8002364:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8002366:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 8002368:	689f      	ldr	r7, [r3, #8]
  qp->next       = p->next;
 800236a:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
  qp->next->prev = qp;
 800236e:	604e      	str	r6, [r1, #4]
 8002370:	f8c3 c050 	str.w	ip, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8002374:	f883 c04c 	strb.w	ip, [r3, #76]	; 0x4c
    pqp = pqp->next;
 8002378:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800237a:	6890      	ldr	r0, [r2, #8]
 800237c:	42b8      	cmp	r0, r7
 800237e:	d2fb      	bcs.n	8002378 <Vector9C+0x138>
  p->prev       = pqp->prev;
 8002380:	6850      	ldr	r0, [r2, #4]
 8002382:	42b1      	cmp	r1, r6
 8002384:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 8002388:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 800238a:	6053      	str	r3, [r2, #4]
 800238c:	d1e9      	bne.n	8002362 <Vector9C+0x122>
 800238e:	2300      	movs	r3, #0
 8002390:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 9);
 8002394:	05ab      	lsls	r3, r5, #22
 8002396:	d527      	bpl.n	80023e8 <Vector9C+0x1a8>
 8002398:	4c17      	ldr	r4, [pc, #92]	; (80023f8 <Vector9C+0x1b8>)
 800239a:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800239e:	b113      	cbz	r3, 80023a6 <Vector9C+0x166>
 80023a0:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
 80023a4:	4798      	blx	r3
 80023a6:	2330      	movs	r3, #48	; 0x30
 80023a8:	f383 8811 	msr	BASEPRI, r3
 80023ac:	4d17      	ldr	r5, [pc, #92]	; (800240c <Vector9C+0x1cc>)
  return (bool)(qp->next != qp);
 80023ae:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 80023b2:	42a9      	cmp	r1, r5
 80023b4:	d015      	beq.n	80023e2 <Vector9C+0x1a2>
 80023b6:	2700      	movs	r7, #0
 80023b8:	460b      	mov	r3, r1
  qp->next       = p->next;
 80023ba:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80023bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 80023be:	689e      	ldr	r6, [r3, #8]
  qp->next       = p->next;
 80023c0:	f8c4 1090 	str.w	r1, [r4, #144]	; 0x90
  qp->next->prev = qp;
 80023c4:	604d      	str	r5, [r1, #4]
 80023c6:	651f      	str	r7, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 80023c8:	f883 704c 	strb.w	r7, [r3, #76]	; 0x4c
    pqp = pqp->next;
 80023cc:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80023ce:	6890      	ldr	r0, [r2, #8]
 80023d0:	42b0      	cmp	r0, r6
 80023d2:	d2fb      	bcs.n	80023cc <Vector9C+0x18c>
  p->prev       = pqp->prev;
 80023d4:	6850      	ldr	r0, [r2, #4]
 80023d6:	42a9      	cmp	r1, r5
 80023d8:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 80023dc:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 80023de:	6053      	str	r3, [r2, #4]
 80023e0:	d1ea      	bne.n	80023b8 <Vector9C+0x178>
 80023e2:	2300      	movs	r3, #0
 80023e4:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
 80023e8:	4b09      	ldr	r3, [pc, #36]	; (8002410 <Vector9C+0x1d0>)
 80023ea:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80023ee:	605a      	str	r2, [r3, #4]
}
 80023f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80023f2:	bf00      	nop
 80023f4:	40010400 	.word	0x40010400
 80023f8:	20000968 	.word	0x20000968
 80023fc:	200009b8 	.word	0x200009b8
 8002400:	200009c8 	.word	0x200009c8
 8002404:	200009d8 	.word	0x200009d8
 8002408:	200009e8 	.word	0x200009e8
 800240c:	200009f8 	.word	0x200009f8
 8002410:	e000ed00 	.word	0xe000ed00
	...

08002420 <VectorE0>:
/**
 * @brief   EXTI[10]..EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_EXTI10_15_HANDLER) {
 8002420:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 8002422:	4b88      	ldr	r3, [pc, #544]	; (8002644 <VectorE0+0x224>)
 8002424:	695d      	ldr	r5, [r3, #20]
 8002426:	f405 427c 	and.w	r2, r5, #64512	; 0xfc00
                        (1U << 14) | (1U << 15), pr);

  exti_serve_irq(pr, 10);
 800242a:	056e      	lsls	r6, r5, #21
  extiGetAndClearGroup1((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 800242c:	615a      	str	r2, [r3, #20]
  exti_serve_irq(pr, 10);
 800242e:	d529      	bpl.n	8002484 <VectorE0+0x64>
 8002430:	4c85      	ldr	r4, [pc, #532]	; (8002648 <VectorE0+0x228>)
 8002432:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 8002436:	b113      	cbz	r3, 800243e <VectorE0+0x1e>
 8002438:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
 800243c:	4798      	blx	r3
 800243e:	2330      	movs	r3, #48	; 0x30
 8002440:	f383 8811 	msr	BASEPRI, r3
 8002444:	4e81      	ldr	r6, [pc, #516]	; (800264c <VectorE0+0x22c>)
  return (bool)(qp->next != qp);
 8002446:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 800244a:	42b1      	cmp	r1, r6
 800244c:	d017      	beq.n	800247e <VectorE0+0x5e>
 800244e:	f04f 0c00 	mov.w	ip, #0
 8002452:	460b      	mov	r3, r1
  qp->next       = p->next;
 8002454:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8002456:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 8002458:	689f      	ldr	r7, [r3, #8]
  qp->next       = p->next;
 800245a:	f8c4 10a0 	str.w	r1, [r4, #160]	; 0xa0
  qp->next->prev = qp;
 800245e:	604e      	str	r6, [r1, #4]
 8002460:	f8c3 c050 	str.w	ip, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8002464:	f883 c04c 	strb.w	ip, [r3, #76]	; 0x4c
    pqp = pqp->next;
 8002468:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800246a:	6890      	ldr	r0, [r2, #8]
 800246c:	42b8      	cmp	r0, r7
 800246e:	d2fb      	bcs.n	8002468 <VectorE0+0x48>
  p->prev       = pqp->prev;
 8002470:	6850      	ldr	r0, [r2, #4]
 8002472:	42b1      	cmp	r1, r6
 8002474:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 8002478:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 800247a:	6053      	str	r3, [r2, #4]
 800247c:	d1e9      	bne.n	8002452 <VectorE0+0x32>
 800247e:	2300      	movs	r3, #0
 8002480:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 11);
 8002484:	052c      	lsls	r4, r5, #20
 8002486:	d529      	bpl.n	80024dc <VectorE0+0xbc>
 8002488:	4c6f      	ldr	r4, [pc, #444]	; (8002648 <VectorE0+0x228>)
 800248a:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
 800248e:	b113      	cbz	r3, 8002496 <VectorE0+0x76>
 8002490:	f8d4 00bc 	ldr.w	r0, [r4, #188]	; 0xbc
 8002494:	4798      	blx	r3
 8002496:	2330      	movs	r3, #48	; 0x30
 8002498:	f383 8811 	msr	BASEPRI, r3
 800249c:	4e6c      	ldr	r6, [pc, #432]	; (8002650 <VectorE0+0x230>)
  return (bool)(qp->next != qp);
 800249e:	f8d4 10b0 	ldr.w	r1, [r4, #176]	; 0xb0
 80024a2:	42b1      	cmp	r1, r6
 80024a4:	d017      	beq.n	80024d6 <VectorE0+0xb6>
 80024a6:	f04f 0c00 	mov.w	ip, #0
 80024aa:	460b      	mov	r3, r1
  qp->next       = p->next;
 80024ac:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80024ae:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 80024b0:	689f      	ldr	r7, [r3, #8]
  qp->next       = p->next;
 80024b2:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
  qp->next->prev = qp;
 80024b6:	604e      	str	r6, [r1, #4]
 80024b8:	f8c3 c050 	str.w	ip, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 80024bc:	f883 c04c 	strb.w	ip, [r3, #76]	; 0x4c
    pqp = pqp->next;
 80024c0:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80024c2:	6890      	ldr	r0, [r2, #8]
 80024c4:	42b8      	cmp	r0, r7
 80024c6:	d2fb      	bcs.n	80024c0 <VectorE0+0xa0>
  p->prev       = pqp->prev;
 80024c8:	6850      	ldr	r0, [r2, #4]
 80024ca:	42b1      	cmp	r1, r6
 80024cc:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 80024d0:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 80024d2:	6053      	str	r3, [r2, #4]
 80024d4:	d1e9      	bne.n	80024aa <VectorE0+0x8a>
 80024d6:	2300      	movs	r3, #0
 80024d8:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 12);
 80024dc:	04e8      	lsls	r0, r5, #19
 80024de:	d529      	bpl.n	8002534 <VectorE0+0x114>
 80024e0:	4c59      	ldr	r4, [pc, #356]	; (8002648 <VectorE0+0x228>)
 80024e2:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 80024e6:	b113      	cbz	r3, 80024ee <VectorE0+0xce>
 80024e8:	f8d4 00cc 	ldr.w	r0, [r4, #204]	; 0xcc
 80024ec:	4798      	blx	r3
 80024ee:	2330      	movs	r3, #48	; 0x30
 80024f0:	f383 8811 	msr	BASEPRI, r3
 80024f4:	4e57      	ldr	r6, [pc, #348]	; (8002654 <VectorE0+0x234>)
  return (bool)(qp->next != qp);
 80024f6:	f8d4 10c0 	ldr.w	r1, [r4, #192]	; 0xc0
 80024fa:	42b1      	cmp	r1, r6
 80024fc:	d017      	beq.n	800252e <VectorE0+0x10e>
 80024fe:	f04f 0c00 	mov.w	ip, #0
 8002502:	460b      	mov	r3, r1
  qp->next       = p->next;
 8002504:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8002506:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 8002508:	689f      	ldr	r7, [r3, #8]
  qp->next       = p->next;
 800250a:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
  qp->next->prev = qp;
 800250e:	604e      	str	r6, [r1, #4]
 8002510:	f8c3 c050 	str.w	ip, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8002514:	f883 c04c 	strb.w	ip, [r3, #76]	; 0x4c
    pqp = pqp->next;
 8002518:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800251a:	6890      	ldr	r0, [r2, #8]
 800251c:	42b8      	cmp	r0, r7
 800251e:	d2fb      	bcs.n	8002518 <VectorE0+0xf8>
  p->prev       = pqp->prev;
 8002520:	6850      	ldr	r0, [r2, #4]
 8002522:	42b1      	cmp	r1, r6
 8002524:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 8002528:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 800252a:	6053      	str	r3, [r2, #4]
 800252c:	d1e9      	bne.n	8002502 <VectorE0+0xe2>
 800252e:	2300      	movs	r3, #0
 8002530:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 13);
 8002534:	04a9      	lsls	r1, r5, #18
 8002536:	d529      	bpl.n	800258c <VectorE0+0x16c>
 8002538:	4c43      	ldr	r4, [pc, #268]	; (8002648 <VectorE0+0x228>)
 800253a:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 800253e:	b113      	cbz	r3, 8002546 <VectorE0+0x126>
 8002540:	f8d4 00dc 	ldr.w	r0, [r4, #220]	; 0xdc
 8002544:	4798      	blx	r3
 8002546:	2330      	movs	r3, #48	; 0x30
 8002548:	f383 8811 	msr	BASEPRI, r3
 800254c:	4e42      	ldr	r6, [pc, #264]	; (8002658 <VectorE0+0x238>)
  return (bool)(qp->next != qp);
 800254e:	f8d4 10d0 	ldr.w	r1, [r4, #208]	; 0xd0
 8002552:	42b1      	cmp	r1, r6
 8002554:	d017      	beq.n	8002586 <VectorE0+0x166>
 8002556:	f04f 0c00 	mov.w	ip, #0
 800255a:	460b      	mov	r3, r1
  qp->next       = p->next;
 800255c:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800255e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 8002560:	689f      	ldr	r7, [r3, #8]
  qp->next       = p->next;
 8002562:	f8c4 10d0 	str.w	r1, [r4, #208]	; 0xd0
  qp->next->prev = qp;
 8002566:	604e      	str	r6, [r1, #4]
 8002568:	f8c3 c050 	str.w	ip, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 800256c:	f883 c04c 	strb.w	ip, [r3, #76]	; 0x4c
    pqp = pqp->next;
 8002570:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8002572:	6890      	ldr	r0, [r2, #8]
 8002574:	42b8      	cmp	r0, r7
 8002576:	d2fb      	bcs.n	8002570 <VectorE0+0x150>
  p->prev       = pqp->prev;
 8002578:	6850      	ldr	r0, [r2, #4]
 800257a:	42b1      	cmp	r1, r6
 800257c:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 8002580:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 8002582:	6053      	str	r3, [r2, #4]
 8002584:	d1e9      	bne.n	800255a <VectorE0+0x13a>
 8002586:	2300      	movs	r3, #0
 8002588:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 14);
 800258c:	046a      	lsls	r2, r5, #17
 800258e:	d529      	bpl.n	80025e4 <VectorE0+0x1c4>
 8002590:	4c2d      	ldr	r4, [pc, #180]	; (8002648 <VectorE0+0x228>)
 8002592:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8002596:	b113      	cbz	r3, 800259e <VectorE0+0x17e>
 8002598:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
 800259c:	4798      	blx	r3
 800259e:	2330      	movs	r3, #48	; 0x30
 80025a0:	f383 8811 	msr	BASEPRI, r3
 80025a4:	4e2d      	ldr	r6, [pc, #180]	; (800265c <VectorE0+0x23c>)
  return (bool)(qp->next != qp);
 80025a6:	f8d4 10e0 	ldr.w	r1, [r4, #224]	; 0xe0
 80025aa:	42b1      	cmp	r1, r6
 80025ac:	d017      	beq.n	80025de <VectorE0+0x1be>
 80025ae:	f04f 0c00 	mov.w	ip, #0
 80025b2:	460b      	mov	r3, r1
  qp->next       = p->next;
 80025b4:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80025b6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 80025b8:	689f      	ldr	r7, [r3, #8]
  qp->next       = p->next;
 80025ba:	f8c4 10e0 	str.w	r1, [r4, #224]	; 0xe0
  qp->next->prev = qp;
 80025be:	604e      	str	r6, [r1, #4]
 80025c0:	f8c3 c050 	str.w	ip, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 80025c4:	f883 c04c 	strb.w	ip, [r3, #76]	; 0x4c
    pqp = pqp->next;
 80025c8:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80025ca:	6890      	ldr	r0, [r2, #8]
 80025cc:	42b8      	cmp	r0, r7
 80025ce:	d2fb      	bcs.n	80025c8 <VectorE0+0x1a8>
  p->prev       = pqp->prev;
 80025d0:	6850      	ldr	r0, [r2, #4]
 80025d2:	42b1      	cmp	r1, r6
 80025d4:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 80025d8:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 80025da:	6053      	str	r3, [r2, #4]
 80025dc:	d1e9      	bne.n	80025b2 <VectorE0+0x192>
 80025de:	2300      	movs	r3, #0
 80025e0:	f383 8811 	msr	BASEPRI, r3
  exti_serve_irq(pr, 15);
 80025e4:	042b      	lsls	r3, r5, #16
 80025e6:	d527      	bpl.n	8002638 <VectorE0+0x218>
 80025e8:	4c17      	ldr	r4, [pc, #92]	; (8002648 <VectorE0+0x228>)
 80025ea:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 80025ee:	b113      	cbz	r3, 80025f6 <VectorE0+0x1d6>
 80025f0:	f8d4 00fc 	ldr.w	r0, [r4, #252]	; 0xfc
 80025f4:	4798      	blx	r3
 80025f6:	2330      	movs	r3, #48	; 0x30
 80025f8:	f383 8811 	msr	BASEPRI, r3
 80025fc:	4d18      	ldr	r5, [pc, #96]	; (8002660 <VectorE0+0x240>)
  return (bool)(qp->next != qp);
 80025fe:	f8d4 10f0 	ldr.w	r1, [r4, #240]	; 0xf0
 8002602:	42a9      	cmp	r1, r5
 8002604:	d015      	beq.n	8002632 <VectorE0+0x212>
 8002606:	2700      	movs	r7, #0
 8002608:	460b      	mov	r3, r1
  qp->next       = p->next;
 800260a:	6809      	ldr	r1, [r1, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800260c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 800260e:	689e      	ldr	r6, [r3, #8]
  qp->next       = p->next;
 8002610:	f8c4 10f0 	str.w	r1, [r4, #240]	; 0xf0
  qp->next->prev = qp;
 8002614:	604d      	str	r5, [r1, #4]
 8002616:	651f      	str	r7, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8002618:	f883 704c 	strb.w	r7, [r3, #76]	; 0x4c
    pqp = pqp->next;
 800261c:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800261e:	6890      	ldr	r0, [r2, #8]
 8002620:	42b0      	cmp	r0, r6
 8002622:	d2fb      	bcs.n	800261c <VectorE0+0x1fc>
  p->prev       = pqp->prev;
 8002624:	6850      	ldr	r0, [r2, #4]
 8002626:	42a9      	cmp	r1, r5
 8002628:	e9c3 2000 	strd	r2, r0, [r3]
  p->prev->next = p;
 800262c:	6003      	str	r3, [r0, #0]
  pqp->prev     = p;
 800262e:	6053      	str	r3, [r2, #4]
 8002630:	d1ea      	bne.n	8002608 <VectorE0+0x1e8>
 8002632:	2300      	movs	r3, #0
 8002634:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
 8002638:	4b0a      	ldr	r3, [pc, #40]	; (8002664 <VectorE0+0x244>)
 800263a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800263e:	605a      	str	r2, [r3, #4]
}
 8002640:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002642:	bf00      	nop
 8002644:	40010400 	.word	0x40010400
 8002648:	20000968 	.word	0x20000968
 800264c:	20000a08 	.word	0x20000a08
 8002650:	20000a18 	.word	0x20000a18
 8002654:	20000a28 	.word	0x20000a28
 8002658:	20000a38 	.word	0x20000a38
 800265c:	20000a48 	.word	0x20000a48
 8002660:	20000a58 	.word	0x20000a58
 8002664:	e000ed00 	.word	0xe000ed00
	...

08002670 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8002670:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

#if HAL_USE_SERIAL
#if STM32_SERIAL_USE_USART1
  sd_lld_serve_interrupt(&SD1);
 8002672:	4804      	ldr	r0, [pc, #16]	; (8002684 <VectorD4+0x14>)
 8002674:	f7fe f89c 	bl	80007b0 <sd_lld_serve_interrupt>
#if STM32_UART_USE_USART1
  uart_lld_serve_interrupt(&UARTD1);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8002678:	4b03      	ldr	r3, [pc, #12]	; (8002688 <VectorD4+0x18>)
 800267a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800267e:	605a      	str	r2, [r3, #4]
}
 8002680:	bd08      	pop	{r3, pc}
 8002682:	bf00      	nop
 8002684:	200008a8 	.word	0x200008a8
 8002688:	e000ed00 	.word	0xe000ed00
 800268c:	00000000 	.word	0x00000000

08002690 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8002690:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

#if HAL_USE_SERIAL
#if STM32_SERIAL_USE_USART2
  sd_lld_serve_interrupt(&SD2);
 8002692:	4804      	ldr	r0, [pc, #16]	; (80026a4 <VectorD8+0x14>)
 8002694:	f7fe f88c 	bl	80007b0 <sd_lld_serve_interrupt>
#if STM32_UART_USE_USART2
  uart_lld_serve_interrupt(&UARTD2);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8002698:	4b03      	ldr	r3, [pc, #12]	; (80026a8 <VectorD8+0x18>)
 800269a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800269e:	605a      	str	r2, [r3, #4]
}
 80026a0:	bd08      	pop	{r3, pc}
 80026a2:	bf00      	nop
 80026a4:	20000908 	.word	0x20000908
 80026a8:	e000ed00 	.word	0xe000ed00
 80026ac:	00000000 	.word	0x00000000

080026b0 <Vector1AC>:
 * @param[in] siop      pointer to the @p SIODriver object
 *
 * @notapi
 */
void sio_lld_serve_interrupt(SIODriver *siop) {
  USART_TypeDef *u = siop->usart;
 80026b0:	486f      	ldr	r0, [pc, #444]	; (8002870 <Vector1AC+0x1c0>)
 80026b2:	6a81      	ldr	r1, [r0, #40]	; 0x28
/**
 * @brief   LPUART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_LPUART1_HANDLER) {
 80026b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t cr1, cr3;

  osalDbgAssert(siop->state == SIO_READY, "invalid state");

  /* Read on control registers.*/
  cr1 = u->CR1;
 80026b6:	680d      	ldr	r5, [r1, #0]
  cr3 = u->CR3;
 80026b8:	688c      	ldr	r4, [r1, #8]
  isr = siop->usart->ISR & (SIO_LLD_ISR_RX_ERRORS |
 80026ba:	69ca      	ldr	r2, [r1, #28]
 80026bc:	f3c2 0208 	ubfx	r2, r2, #0, #9
           __sio_reloc_field(isr, USART_ISR_IONFP_Msk, USART_ISR_IONFP_Pos, SIO_EV_ALL_ERRORS_POS) |
 80026c0:	0153      	lsls	r3, r2, #5
           __sio_reloc_field(isr, USART_ISR_LBDF_Msk,  USART_ISR_LBDF_Pos,  SIO_EV_RXBREAK_POS);
 80026c2:	ea4f 2c12 	mov.w	ip, r2, lsr #8
           __sio_reloc_field(isr, USART_ISR_IONFP_Msk, USART_ISR_IONFP_Pos, SIO_EV_ALL_ERRORS_POS) |
 80026c6:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
  events = __sio_reloc_field(isr, USART_ISR_RXNE_Msk,  USART_ISR_RXNE_Pos,  SIO_EV_RXNOTEMPY_POS)  |
 80026ca:	ea43 238c 	orr.w	r3, r3, ip, lsl #10
 80026ce:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
 80026d2:	f00c 0c04 	and.w	ip, ip, #4
 80026d6:	ea43 030c 	orr.w	r3, r3, ip
           __sio_reloc_field(isr, USART_ISR_TXE_Msk,   USART_ISR_TXE_Pos,   SIO_EV_TXNOTFULL_POS)  |
 80026da:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 80026de:	f00c 0c08 	and.w	ip, ip, #8
           __sio_reloc_field(isr, USART_ISR_TC_Msk,    USART_ISR_TC_Pos,    SIO_EV_TXDONE_POS)     |
 80026e2:	0892      	lsrs	r2, r2, #2
 80026e4:	f002 0210 	and.w	r2, r2, #16
  events = __sio_reloc_field(isr, USART_ISR_RXNE_Msk,  USART_ISR_RXNE_Pos,  SIO_EV_RXNOTEMPY_POS)  |
 80026e8:	ea43 030c 	orr.w	r3, r3, ip
 80026ec:	4313      	orrs	r3, r2

  /* Events to be processed.*/
  events = sio_lld_get_events(siop) & siop->enabled;
 80026ee:	68c2      	ldr	r2, [r0, #12]
  if (events != 0U) {
 80026f0:	4013      	ands	r3, r2
 80026f2:	d012      	beq.n	800271a <Vector1AC+0x6a>

    /* Error events handled as a group.*/
    if ((events & SIO_EV_ALL_ERRORS) != 0U) {
 80026f4:	f413 66bc 	ands.w	r6, r3, #1504	; 0x5e0
 80026f8:	d114      	bne.n	8002724 <Vector1AC+0x74>
      __sio_wakeup_errors(siop);
    }
    /* If there are no errors then we check for the other RX events.*/
    else {
      /* Idle RX event.*/
      if ((events & SIO_EV_RXIDLE) != 0U) {
 80026fa:	059f      	lsls	r7, r3, #22
 80026fc:	f100 809d 	bmi.w	800283a <Vector1AC+0x18a>
        /* Waiting thread woken, if any.*/
        __sio_wakeup_rxidle(siop);
      }

      /* RX FIFO is non-empty.*/
      if ((events & SIO_EV_RXNOTEMPY) != 0U) {
 8002700:	075e      	lsls	r6, r3, #29
 8002702:	f100 8083 	bmi.w	800280c <Vector1AC+0x15c>
        __sio_wakeup_rx(siop);
      }
    }

    /* TX FIFO is non-full.*/
    if ((events & SIO_EV_TXNOTFULL) != 0U) {
 8002706:	071a      	lsls	r2, r3, #28
 8002708:	d448      	bmi.n	800279c <Vector1AC+0xec>
      /* Waiting thread woken, if any.*/
      __sio_wakeup_tx(siop);
    }

    /* Physical transmission end.*/
    if ((events & SIO_EV_TXDONE) != 0U) {
 800270a:	06db      	lsls	r3, r3, #27
 800270c:	d463      	bmi.n	80027d6 <Vector1AC+0x126>
    /* Updating control registers, some sources could have been disabled.*/
    u->CR1 = cr1;
    u->CR3 = cr3;

    /* The callback is invoked.*/
    __sio_callback(siop);
 800270e:	6903      	ldr	r3, [r0, #16]
    u->CR1 = cr1;
 8002710:	600d      	str	r5, [r1, #0]
    u->CR3 = cr3;
 8002712:	608c      	str	r4, [r1, #8]
    __sio_callback(siop);
 8002714:	b10b      	cbz	r3, 800271a <Vector1AC+0x6a>
 8002716:	4856      	ldr	r0, [pc, #344]	; (8002870 <Vector1AC+0x1c0>)
 8002718:	4798      	blx	r3
#if STM32_SIO_USE_LPUART1
  sio_lld_serve_interrupt(&LPSIOD1);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 800271a:	4b56      	ldr	r3, [pc, #344]	; (8002874 <Vector1AC+0x1c4>)
 800271c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002720:	605a      	str	r2, [r3, #4]
}
 8002722:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      u->ICR = USART_ICR_IDLECF;
 8002724:	2210      	movs	r2, #16
 8002726:	620a      	str	r2, [r1, #32]
      u->CR2 &= ~(USART_CR2_LBDIE);
 8002728:	684a      	ldr	r2, [r1, #4]
      cr3    &= ~(USART_CR3_EIE | USART_CR3_RXFTIE);
 800272a:	f024 5480 	bic.w	r4, r4, #268435456	; 0x10000000
      u->CR2 &= ~(USART_CR2_LBDIE);
 800272e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002732:	604a      	str	r2, [r1, #4]
      cr3    &= ~(USART_CR3_EIE | USART_CR3_RXFTIE);
 8002734:	f024 0401 	bic.w	r4, r4, #1
      cr1    &= ~(USART_CR1_PEIE | USART_CR1_IDLEIE);
 8002738:	f425 7588 	bic.w	r5, r5, #272	; 0x110
 800273c:	2230      	movs	r2, #48	; 0x30
 800273e:	f382 8811 	msr	BASEPRI, r2
  if (*trp != NULL) {
 8002742:	6982      	ldr	r2, [r0, #24]
 8002744:	b18a      	cbz	r2, 800276a <Vector1AC+0xba>
    *trp = NULL;
 8002746:	2600      	movs	r6, #0
 8002748:	6186      	str	r6, [r0, #24]
 800274a:	f882 604c 	strb.w	r6, [r2, #76]	; 0x4c
    tp->u.rdymsg = msg;
 800274e:	2601      	movs	r6, #1
 8002750:	6516      	str	r6, [r2, #80]	; 0x50
  } while (unlikely(pqp->prio >= p->prio));
 8002752:	6897      	ldr	r7, [r2, #8]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8002754:	6c16      	ldr	r6, [r2, #64]	; 0x40
    pqp = pqp->next;
 8002756:	6836      	ldr	r6, [r6, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8002758:	f8d6 c008 	ldr.w	ip, [r6, #8]
 800275c:	45bc      	cmp	ip, r7
 800275e:	d2fa      	bcs.n	8002756 <Vector1AC+0xa6>
  p->prev       = pqp->prev;
 8002760:	6877      	ldr	r7, [r6, #4]
  p->next       = pqp;
 8002762:	6016      	str	r6, [r2, #0]
  p->prev       = pqp->prev;
 8002764:	6057      	str	r7, [r2, #4]
  p->prev->next = p;
 8002766:	603a      	str	r2, [r7, #0]
  pqp->prev     = p;
 8002768:	6072      	str	r2, [r6, #4]
  if (*trp != NULL) {
 800276a:	69c2      	ldr	r2, [r0, #28]
 800276c:	b18a      	cbz	r2, 8002792 <Vector1AC+0xe2>
    *trp = NULL;
 800276e:	2600      	movs	r6, #0
 8002770:	61c6      	str	r6, [r0, #28]
  tp->state = CH_STATE_READY;
 8002772:	f882 604c 	strb.w	r6, [r2, #76]	; 0x4c
    tp->u.rdymsg = msg;
 8002776:	2601      	movs	r6, #1
 8002778:	6516      	str	r6, [r2, #80]	; 0x50
  } while (unlikely(pqp->prio >= p->prio));
 800277a:	6897      	ldr	r7, [r2, #8]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800277c:	6c16      	ldr	r6, [r2, #64]	; 0x40
    pqp = pqp->next;
 800277e:	6836      	ldr	r6, [r6, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8002780:	f8d6 c008 	ldr.w	ip, [r6, #8]
 8002784:	45bc      	cmp	ip, r7
 8002786:	d2fa      	bcs.n	800277e <Vector1AC+0xce>
  p->next       = pqp;
 8002788:	6016      	str	r6, [r2, #0]
  p->prev       = pqp->prev;
 800278a:	6877      	ldr	r7, [r6, #4]
 800278c:	6057      	str	r7, [r2, #4]
  p->prev->next = p;
 800278e:	603a      	str	r2, [r7, #0]
  pqp->prev     = p;
 8002790:	6072      	str	r2, [r6, #4]
 8002792:	2200      	movs	r2, #0
 8002794:	f382 8811 	msr	BASEPRI, r2
    if ((events & SIO_EV_TXNOTFULL) != 0U) {
 8002798:	071a      	lsls	r2, r3, #28
 800279a:	d5b6      	bpl.n	800270a <Vector1AC+0x5a>
      cr3 &= ~USART_CR3_TXFTIE;
 800279c:	f424 0400 	bic.w	r4, r4, #8388608	; 0x800000
 80027a0:	2230      	movs	r2, #48	; 0x30
 80027a2:	f382 8811 	msr	BASEPRI, r2
  if (*trp != NULL) {
 80027a6:	6a02      	ldr	r2, [r0, #32]
 80027a8:	b182      	cbz	r2, 80027cc <Vector1AC+0x11c>
    *trp = NULL;
 80027aa:	2600      	movs	r6, #0
 80027ac:	6206      	str	r6, [r0, #32]
    tp->u.rdymsg = msg;
 80027ae:	6516      	str	r6, [r2, #80]	; 0x50
  tp->state = CH_STATE_READY;
 80027b0:	f882 604c 	strb.w	r6, [r2, #76]	; 0x4c
  } while (unlikely(pqp->prio >= p->prio));
 80027b4:	6897      	ldr	r7, [r2, #8]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80027b6:	6c16      	ldr	r6, [r2, #64]	; 0x40
    pqp = pqp->next;
 80027b8:	6836      	ldr	r6, [r6, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80027ba:	f8d6 c008 	ldr.w	ip, [r6, #8]
 80027be:	45bc      	cmp	ip, r7
 80027c0:	d2fa      	bcs.n	80027b8 <Vector1AC+0x108>
  p->prev       = pqp->prev;
 80027c2:	6877      	ldr	r7, [r6, #4]
  p->next       = pqp;
 80027c4:	6016      	str	r6, [r2, #0]
  p->prev       = pqp->prev;
 80027c6:	6057      	str	r7, [r2, #4]
  p->prev->next = p;
 80027c8:	603a      	str	r2, [r7, #0]
  pqp->prev     = p;
 80027ca:	6072      	str	r2, [r6, #4]
 80027cc:	2200      	movs	r2, #0
 80027ce:	f382 8811 	msr	BASEPRI, r2
    if ((events & SIO_EV_TXDONE) != 0U) {
 80027d2:	06db      	lsls	r3, r3, #27
 80027d4:	d59b      	bpl.n	800270e <Vector1AC+0x5e>
      cr1 &= ~USART_CR1_TCIE;
 80027d6:	f025 0540 	bic.w	r5, r5, #64	; 0x40
 80027da:	2330      	movs	r3, #48	; 0x30
 80027dc:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 80027e0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80027e2:	b17b      	cbz	r3, 8002804 <Vector1AC+0x154>
    *trp = NULL;
 80027e4:	2200      	movs	r2, #0
 80027e6:	6242      	str	r2, [r0, #36]	; 0x24
    tp->u.rdymsg = msg;
 80027e8:	651a      	str	r2, [r3, #80]	; 0x50
  tp->state = CH_STATE_READY;
 80027ea:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  } while (unlikely(pqp->prio >= p->prio));
 80027ee:	689f      	ldr	r7, [r3, #8]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80027f0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    pqp = pqp->next;
 80027f2:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80027f4:	6896      	ldr	r6, [r2, #8]
 80027f6:	42be      	cmp	r6, r7
 80027f8:	d2fb      	bcs.n	80027f2 <Vector1AC+0x142>
  p->prev       = pqp->prev;
 80027fa:	6856      	ldr	r6, [r2, #4]
  p->next       = pqp;
 80027fc:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 80027fe:	605e      	str	r6, [r3, #4]
  p->prev->next = p;
 8002800:	6033      	str	r3, [r6, #0]
  pqp->prev     = p;
 8002802:	6053      	str	r3, [r2, #4]
 8002804:	2300      	movs	r3, #0
 8002806:	f383 8811 	msr	BASEPRI, r3
}
 800280a:	e780      	b.n	800270e <Vector1AC+0x5e>
        u->ICR = USART_ICR_IDLECF;
 800280c:	2210      	movs	r2, #16
 800280e:	620a      	str	r2, [r1, #32]
        cr3 &= ~USART_CR3_RXFTIE;
 8002810:	f024 5480 	bic.w	r4, r4, #268435456	; 0x10000000
 8002814:	2230      	movs	r2, #48	; 0x30
 8002816:	f382 8811 	msr	BASEPRI, r2
  if (*trp != NULL) {
 800281a:	6982      	ldr	r2, [r0, #24]
 800281c:	2a00      	cmp	r2, #0
 800281e:	d0b8      	beq.n	8002792 <Vector1AC+0xe2>
    *trp = NULL;
 8002820:	2600      	movs	r6, #0
 8002822:	6186      	str	r6, [r0, #24]
    tp->u.rdymsg = msg;
 8002824:	6516      	str	r6, [r2, #80]	; 0x50
  tp->state = CH_STATE_READY;
 8002826:	f882 604c 	strb.w	r6, [r2, #76]	; 0x4c
  } while (unlikely(pqp->prio >= p->prio));
 800282a:	6897      	ldr	r7, [r2, #8]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800282c:	6c16      	ldr	r6, [r2, #64]	; 0x40
    pqp = pqp->next;
 800282e:	6836      	ldr	r6, [r6, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8002830:	f8d6 c008 	ldr.w	ip, [r6, #8]
 8002834:	45bc      	cmp	ip, r7
 8002836:	d3a7      	bcc.n	8002788 <Vector1AC+0xd8>
 8002838:	e7f9      	b.n	800282e <Vector1AC+0x17e>
        cr1 &= ~USART_CR1_IDLEIE;
 800283a:	f025 0510 	bic.w	r5, r5, #16
 800283e:	2230      	movs	r2, #48	; 0x30
 8002840:	f382 8811 	msr	BASEPRI, r2
  if (*trp != NULL) {
 8002844:	69c2      	ldr	r2, [r0, #28]
 8002846:	b17a      	cbz	r2, 8002868 <Vector1AC+0x1b8>
    *trp = NULL;
 8002848:	61c6      	str	r6, [r0, #28]
    tp->u.rdymsg = msg;
 800284a:	6516      	str	r6, [r2, #80]	; 0x50
  tp->state = CH_STATE_READY;
 800284c:	f882 604c 	strb.w	r6, [r2, #76]	; 0x4c
 8002850:	6897      	ldr	r7, [r2, #8]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8002852:	6c16      	ldr	r6, [r2, #64]	; 0x40
    pqp = pqp->next;
 8002854:	6836      	ldr	r6, [r6, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8002856:	f8d6 c008 	ldr.w	ip, [r6, #8]
 800285a:	45bc      	cmp	ip, r7
 800285c:	d2fa      	bcs.n	8002854 <Vector1AC+0x1a4>
  p->prev       = pqp->prev;
 800285e:	6877      	ldr	r7, [r6, #4]
  p->next       = pqp;
 8002860:	6016      	str	r6, [r2, #0]
  p->prev       = pqp->prev;
 8002862:	6057      	str	r7, [r2, #4]
  p->prev->next = p;
 8002864:	603a      	str	r2, [r7, #0]
  pqp->prev     = p;
 8002866:	6072      	str	r2, [r6, #4]
 8002868:	2200      	movs	r2, #0
 800286a:	f382 8811 	msr	BASEPRI, r2
 800286e:	e747      	b.n	8002700 <Vector1AC+0x50>
 8002870:	20000858 	.word	0x20000858
 8002874:	e000ed00 	.word	0xe000ed00
	...

08002880 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8002880:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 8002884:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 8002888:	6933      	ldr	r3, [r6, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 800288a:	68f2      	ldr	r2, [r6, #12]
 800288c:	4013      	ands	r3, r2
 800288e:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;
 8002890:	43d2      	mvns	r2, r2

  if ((sr & TIM_SR_CC1IF) != 0U)
 8002892:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 8002894:	6132      	str	r2, [r6, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 8002896:	d405      	bmi.n	80028a4 <VectorB0+0x24>
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8002898:	4b45      	ldr	r3, [pc, #276]	; (80029b0 <VectorB0+0x130>)
 800289a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800289e:	605a      	str	r2, [r3, #4]
}
 80028a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80028a4:	2330      	movs	r3, #48	; 0x30
 80028a6:	f383 8811 	msr	BASEPRI, r3
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 80028aa:	4d42      	ldr	r5, [pc, #264]	; (80029b4 <VectorB0+0x134>)
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
 80028ac:	f04f 0a00 	mov.w	sl, #0
 80028b0:	f105 0710 	add.w	r7, r5, #16
 80028b4:	f04f 0830 	mov.w	r8, #48	; 0x30
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 80028b8:	692c      	ldr	r4, [r5, #16]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80028ba:	69ea      	ldr	r2, [r5, #28]
 80028bc:	6a71      	ldr	r1, [r6, #36]	; 0x24
    if (nowdelta < vtp->dlist.delta) {
 80028be:	68a3      	ldr	r3, [r4, #8]
 80028c0:	1a88      	subs	r0, r1, r2
 80028c2:	4298      	cmp	r0, r3
  return systime + (systime_t)interval;
 80028c4:	eb02 0903 	add.w	r9, r2, r3
 80028c8:	d334      	bcc.n	8002934 <VectorB0+0xb4>
  dlp->prev->next = dlp->next;
 80028ca:	e9d4 3200 	ldrd	r3, r2, [r4]
    vtlp->lasttime = lasttime;
 80028ce:	f8c5 901c 	str.w	r9, [r5, #28]
 80028d2:	6013      	str	r3, [r2, #0]
  dlp->next->prev = dlp->prev;
 80028d4:	605a      	str	r2, [r3, #4]
    vtp->dlist.next = NULL;
 80028d6:	f8c4 a000 	str.w	sl, [r4]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 80028da:	692b      	ldr	r3, [r5, #16]
 80028dc:	42bb      	cmp	r3, r7
  STM32_ST_TIM->DIER = 0U;
 80028de:	bf08      	it	eq
 80028e0:	f8c6 a00c 	streq.w	sl, [r6, #12]
 80028e4:	f38a 8811 	msr	BASEPRI, sl
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
 80028e8:	e9d4 3103 	ldrd	r3, r1, [r4, #12]
 80028ec:	4620      	mov	r0, r4
 80028ee:	4798      	blx	r3
 80028f0:	f388 8811 	msr	BASEPRI, r8

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 80028f4:	6963      	ldr	r3, [r4, #20]
 80028f6:	2b00      	cmp	r3, #0
 80028f8:	d0de      	beq.n	80028b8 <VectorB0+0x38>
  return (systime_t)STM32_ST_TIM->CNT;
 80028fa:	6a71      	ldr	r1, [r6, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80028fc:	eba1 0009 	sub.w	r0, r1, r9
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8002900:	4283      	cmp	r3, r0
 8002902:	d32f      	bcc.n	8002964 <VectorB0+0xe4>
  return (bool)(dlhp == dlhp->next);
 8002904:	692a      	ldr	r2, [r5, #16]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8002906:	42ba      	cmp	r2, r7
 8002908:	d046      	beq.n	8002998 <VectorB0+0x118>
  while (likely(dlp->delta < delta)) {
 800290a:	6891      	ldr	r1, [r2, #8]
 800290c:	428b      	cmp	r3, r1
 800290e:	d904      	bls.n	800291a <VectorB0+0x9a>
    dlp = dlp->next;
 8002910:	6812      	ldr	r2, [r2, #0]
    delta -= dlp->delta;
 8002912:	1a5b      	subs	r3, r3, r1
  while (likely(dlp->delta < delta)) {
 8002914:	6891      	ldr	r1, [r2, #8]
 8002916:	4299      	cmp	r1, r3
 8002918:	d3fa      	bcc.n	8002910 <VectorB0+0x90>
  dlp->delta      = delta;
 800291a:	60a3      	str	r3, [r4, #8]
  dlp->delta -= delta;
 800291c:	6891      	ldr	r1, [r2, #8]
  dlp->next       = dlhp;
 800291e:	6022      	str	r2, [r4, #0]
  dlp->delta -= delta;
 8002920:	1ac9      	subs	r1, r1, r3
  dlp->prev       = dlp->next->prev;
 8002922:	6853      	ldr	r3, [r2, #4]
 8002924:	6063      	str	r3, [r4, #4]
  dlp->prev->next = dlp;
 8002926:	601c      	str	r4, [r3, #0]
  dlhp->delta = (sysinterval_t)-1;
 8002928:	f04f 33ff 	mov.w	r3, #4294967295
  dlp->delta -= delta;
 800292c:	e9c2 4101 	strd	r4, r1, [r2, #4]
  dlhp->delta = (sysinterval_t)-1;
 8002930:	61ab      	str	r3, [r5, #24]
}
 8002932:	e7bf      	b.n	80028b4 <VectorB0+0x34>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8002934:	42bc      	cmp	r4, r7
 8002936:	d00c      	beq.n	8002952 <VectorB0+0xd2>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;
 8002938:	1a5b      	subs	r3, r3, r1
 800293a:	4413      	add	r3, r2
 800293c:	2b02      	cmp	r3, #2
  vtlp->lasttime += nowdelta;
 800293e:	61e9      	str	r1, [r5, #28]
  vtp->dlist.delta -= nowdelta;
 8002940:	60a3      	str	r3, [r4, #8]
  if (delay < currdelta) {
 8002942:	bf38      	it	cc
 8002944:	2302      	movcc	r3, #2
  return systime + (systime_t)interval;
 8002946:	18ca      	adds	r2, r1, r3
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8002948:	6372      	str	r2, [r6, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 800294a:	6a72      	ldr	r2, [r6, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 800294c:	1a51      	subs	r1, r2, r1
    if (likely(nowdelta < delay)) {
 800294e:	428b      	cmp	r3, r1
 8002950:	d911      	bls.n	8002976 <VectorB0+0xf6>
 8002952:	2300      	movs	r3, #0
 8002954:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
 8002958:	4b15      	ldr	r3, [pc, #84]	; (80029b0 <VectorB0+0x130>)
 800295a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800295e:	605a      	str	r2, [r3, #4]
}
 8002960:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  currcore->rfcu.mask |= mask;
 8002964:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  return (bool)(dlhp == dlhp->next);
 8002966:	692a      	ldr	r2, [r5, #16]
 8002968:	f043 0302 	orr.w	r3, r3, #2
      if (ch_dlist_isempty(&vtlp->dlist)) {
 800296c:	42ba      	cmp	r2, r7
 800296e:	636b      	str	r3, [r5, #52]	; 0x34
 8002970:	d019      	beq.n	80029a6 <VectorB0+0x126>
 8002972:	4603      	mov	r3, r0
 8002974:	e7c9      	b.n	800290a <VectorB0+0x8a>
    if (likely(nowdelta < delay)) {
 8002976:	2302      	movs	r3, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8002978:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    currdelta += (sysinterval_t)1;
 800297c:	3301      	adds	r3, #1
  return systime + (systime_t)interval;
 800297e:	18d0      	adds	r0, r2, r3
 8002980:	6348      	str	r0, [r1, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8002982:	6a48      	ldr	r0, [r1, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8002984:	1a82      	subs	r2, r0, r2
    if (likely(nowdelta < delay)) {
 8002986:	429a      	cmp	r2, r3
 8002988:	d20f      	bcs.n	80029aa <VectorB0+0x12a>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 800298a:	2b02      	cmp	r3, #2
 800298c:	d9e1      	bls.n	8002952 <VectorB0+0xd2>
 800298e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002990:	f043 0301 	orr.w	r3, r3, #1
 8002994:	636b      	str	r3, [r5, #52]	; 0x34
}
 8002996:	e7dc      	b.n	8002952 <VectorB0+0xd2>
        delay = vtp->reload - nowdelta;
 8002998:	1a5b      	subs	r3, r3, r1
 800299a:	eb03 0209 	add.w	r2, r3, r9
        vt_insert_first(vtlp, vtp, now, delay);
 800299e:	4620      	mov	r0, r4
 80029a0:	f7fe f8ce 	bl	8000b40 <vt_insert_first.constprop.0>
        return;
 80029a4:	e7d5      	b.n	8002952 <VectorB0+0xd2>
        delay = (sysinterval_t)0;
 80029a6:	2200      	movs	r2, #0
 80029a8:	e7f9      	b.n	800299e <VectorB0+0x11e>
 80029aa:	4602      	mov	r2, r0
 80029ac:	e7e6      	b.n	800297c <VectorB0+0xfc>
 80029ae:	bf00      	nop
 80029b0:	e000ed00 	.word	0xe000ed00
 80029b4:	20000a68 	.word	0x20000a68
	...

080029c0 <VectorB4>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 80029c0:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 80029c2:	4d18      	ldr	r5, [pc, #96]	; (8002a24 <VectorB4+0x64>)
 80029c4:	69eb      	ldr	r3, [r5, #28]
 80029c6:	691c      	ldr	r4, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 80029c8:	68da      	ldr	r2, [r3, #12]
 80029ca:	4014      	ands	r4, r2
 80029cc:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 80029ce:	43d2      	mvns	r2, r2
 80029d0:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80029d2:	07a3      	lsls	r3, r4, #30
 80029d4:	d504      	bpl.n	80029e0 <VectorB4+0x20>
      (pwmp->config->channels[0].callback != NULL))
 80029d6:	686b      	ldr	r3, [r5, #4]
 80029d8:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80029da:	b10b      	cbz	r3, 80029e0 <VectorB4+0x20>
    pwmp->config->channels[0].callback(pwmp);
 80029dc:	4628      	mov	r0, r5
 80029de:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80029e0:	0760      	lsls	r0, r4, #29
 80029e2:	d504      	bpl.n	80029ee <VectorB4+0x2e>
      (pwmp->config->channels[1].callback != NULL))
 80029e4:	686b      	ldr	r3, [r5, #4]
 80029e6:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80029e8:	b10b      	cbz	r3, 80029ee <VectorB4+0x2e>
    pwmp->config->channels[1].callback(pwmp);
 80029ea:	480e      	ldr	r0, [pc, #56]	; (8002a24 <VectorB4+0x64>)
 80029ec:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 80029ee:	0721      	lsls	r1, r4, #28
 80029f0:	d504      	bpl.n	80029fc <VectorB4+0x3c>
      (pwmp->config->channels[2].callback != NULL))
 80029f2:	686b      	ldr	r3, [r5, #4]
 80029f4:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 80029f6:	b10b      	cbz	r3, 80029fc <VectorB4+0x3c>
    pwmp->config->channels[2].callback(pwmp);
 80029f8:	480a      	ldr	r0, [pc, #40]	; (8002a24 <VectorB4+0x64>)
 80029fa:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 80029fc:	06e2      	lsls	r2, r4, #27
 80029fe:	d504      	bpl.n	8002a0a <VectorB4+0x4a>
      (pwmp->config->channels[3].callback != NULL))
 8002a00:	686b      	ldr	r3, [r5, #4]
 8002a02:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8002a04:	b10b      	cbz	r3, 8002a0a <VectorB4+0x4a>
    pwmp->config->channels[3].callback(pwmp);
 8002a06:	4807      	ldr	r0, [pc, #28]	; (8002a24 <VectorB4+0x64>)
 8002a08:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8002a0a:	07e3      	lsls	r3, r4, #31
 8002a0c:	d504      	bpl.n	8002a18 <VectorB4+0x58>
 8002a0e:	686b      	ldr	r3, [r5, #4]
 8002a10:	689b      	ldr	r3, [r3, #8]
 8002a12:	b10b      	cbz	r3, 8002a18 <VectorB4+0x58>
    pwmp->config->callback(pwmp);
 8002a14:	4803      	ldr	r0, [pc, #12]	; (8002a24 <VectorB4+0x64>)
 8002a16:	4798      	blx	r3
#if STM32_ST_USE_TIM3
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8002a18:	4b03      	ldr	r3, [pc, #12]	; (8002a28 <VectorB4+0x68>)
 8002a1a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002a1e:	605a      	str	r2, [r3, #4]
}
 8002a20:	bd38      	pop	{r3, r4, r5, pc}
 8002a22:	bf00      	nop
 8002a24:	20000888 	.word	0x20000888
 8002a28:	e000ed00 	.word	0xe000ed00
 8002a2c:	00000000 	.word	0x00000000

08002a30 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB2(STM32_GPIO_EN_MASK);
 8002a30:	4a98      	ldr	r2, [pc, #608]	; (8002c94 <__early_init+0x264>)
  gpiop->OTYPER  = config->otyper;
 8002a32:	4899      	ldr	r0, [pc, #612]	; (8002c98 <__early_init+0x268>)
  rccResetAHB2(STM32_GPIO_EN_MASK);
 8002a34:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8002a36:	f043 037f 	orr.w	r3, r3, #127	; 0x7f
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8002a3a:	b430      	push	{r4, r5}
  rccResetAHB2(STM32_GPIO_EN_MASK);
 8002a3c:	62d3      	str	r3, [r2, #44]	; 0x2c
 8002a3e:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
 8002a40:	f024 047f 	bic.w	r4, r4, #127	; 0x7f
 8002a44:	62d4      	str	r4, [r2, #44]	; 0x2c
 8002a46:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 8002a48:	6cd4      	ldr	r4, [r2, #76]	; 0x4c
 8002a4a:	f044 047f 	orr.w	r4, r4, #127	; 0x7f
 8002a4e:	64d4      	str	r4, [r2, #76]	; 0x4c
 8002a50:	6ed4      	ldr	r4, [r2, #108]	; 0x6c
  gpiop->OTYPER  = config->otyper;
 8002a52:	f04f 4190 	mov.w	r1, #1207959552	; 0x48000000
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 8002a56:	f044 047f 	orr.w	r4, r4, #127	; 0x7f
  gpiop->OTYPER  = config->otyper;
 8002a5a:	2300      	movs	r3, #0
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 8002a5c:	66d4      	str	r4, [r2, #108]	; 0x6c
  gpiop->OSPEEDR = config->ospeedr;
 8002a5e:	4c8f      	ldr	r4, [pc, #572]	; (8002c9c <__early_init+0x26c>)
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 8002a60:	6ed5      	ldr	r5, [r2, #108]	; 0x6c
  gpiop->OTYPER  = config->otyper;
 8002a62:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002a64:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8002a66:	f04f 5410 	mov.w	r4, #603979776	; 0x24000000
 8002a6a:	60cc      	str	r4, [r1, #12]
  gpiop->AFRL    = config->afrl;
 8002a6c:	f44f 444c 	mov.w	r4, #52224	; 0xcc00
  gpiop->ODR     = config->odr;
 8002a70:	614b      	str	r3, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8002a72:	620c      	str	r4, [r1, #32]
  gpiop->MODER   = config->moder;
 8002a74:	4c8a      	ldr	r4, [pc, #552]	; (8002ca0 <__early_init+0x270>)
  gpiop->AFRH    = config->afrh;
 8002a76:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002a78:	600c      	str	r4, [r1, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8002a7a:	24c0      	movs	r4, #192	; 0xc0
  gpiop->OTYPER  = config->otyper;
 8002a7c:	6043      	str	r3, [r0, #4]
  gpiop->MODER   = config->moder;
 8002a7e:	f06f 6540 	mvn.w	r5, #201326592	; 0xc000000
  gpiop->OSPEEDR = config->ospeedr;
 8002a82:	6084      	str	r4, [r0, #8]
  gpiop->MODER   = config->moder;
 8002a84:	f06f 0440 	mvn.w	r4, #64	; 0x40
  gpiop->PUPDR   = config->pupdr;
 8002a88:	60c3      	str	r3, [r0, #12]
  gpiop->OTYPER  = config->otyper;
 8002a8a:	f501 6100 	add.w	r1, r1, #2048	; 0x800
  gpiop->ODR     = config->odr;
 8002a8e:	6143      	str	r3, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8002a90:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8002a92:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002a94:	6004      	str	r4, [r0, #0]
  gpiop->OTYPER  = config->otyper;
 8002a96:	4c83      	ldr	r4, [pc, #524]	; (8002ca4 <__early_init+0x274>)
 8002a98:	604b      	str	r3, [r1, #4]
  gpiop->MODER   = config->moder;
 8002a9a:	f04f 30ff 	mov.w	r0, #4294967295
  gpiop->OSPEEDR = config->ospeedr;
 8002a9e:	608b      	str	r3, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8002aa0:	60cb      	str	r3, [r1, #12]
  gpiop->ODR     = config->odr;
 8002aa2:	614b      	str	r3, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8002aa4:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8002aa6:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002aa8:	600d      	str	r5, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 8002aaa:	6063      	str	r3, [r4, #4]
 8002aac:	f501 6100 	add.w	r1, r1, #2048	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
 8002ab0:	60a3      	str	r3, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8002ab2:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 8002ab4:	6163      	str	r3, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8002ab6:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8002ab8:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002aba:	6020      	str	r0, [r4, #0]
  gpiop->OTYPER  = config->otyper;
 8002abc:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002abe:	608b      	str	r3, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8002ac0:	60cb      	str	r3, [r1, #12]
  gpiop->ODR     = config->odr;
 8002ac2:	614b      	str	r3, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8002ac4:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8002ac6:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002ac8:	6008      	str	r0, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 8002aca:	f8c4 3804 	str.w	r3, [r4, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8002ace:	f8c4 3808 	str.w	r3, [r4, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
 8002ad2:	f8c4 380c 	str.w	r3, [r4, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 8002ad6:	f8c4 3814 	str.w	r3, [r4, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 8002ada:	f8c4 3820 	str.w	r3, [r4, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 8002ade:	f8c4 3824 	str.w	r3, [r4, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 8002ae2:	f8c4 0800 	str.w	r0, [r4, #2048]	; 0x800
  gpiop->OTYPER  = config->otyper;
 8002ae6:	f8c1 3804 	str.w	r3, [r1, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8002aea:	f8c1 3808 	str.w	r3, [r1, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
 8002aee:	f8c1 380c 	str.w	r3, [r1, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 8002af2:	f8c1 3814 	str.w	r3, [r1, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 8002af6:	f8c1 3820 	str.w	r3, [r1, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 8002afa:	f8c1 3824 	str.w	r3, [r1, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 8002afe:	f8c1 0800 	str.w	r0, [r1, #2048]	; 0x800

#if !STM32_NO_INIT
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~0);
 8002b02:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8002b04:	6290      	str	r0, [r2, #40]	; 0x28
 8002b06:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8002b08:	6293      	str	r3, [r2, #40]	; 0x28
 8002b0a:	6a91      	ldr	r1, [r2, #40]	; 0x28
  rccResetAHB2(~STM32_GPIO_EN_MASK);
 8002b0c:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
  PWR->CR3   = STM32_PWR_CR3;
 8002b0e:	4966      	ldr	r1, [pc, #408]	; (8002ca8 <__early_init+0x278>)
  rccResetAHB2(~STM32_GPIO_EN_MASK);
 8002b10:	f064 047f 	orn	r4, r4, #127	; 0x7f
 8002b14:	62d4      	str	r4, [r2, #44]	; 0x2c
 8002b16:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
 8002b18:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 8002b1c:	62d4      	str	r4, [r2, #44]	; 0x2c
 8002b1e:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
  rccResetAHB3(~0);
 8002b20:	6b14      	ldr	r4, [r2, #48]	; 0x30
 8002b22:	6310      	str	r0, [r2, #48]	; 0x30
 8002b24:	6b14      	ldr	r4, [r2, #48]	; 0x30
 8002b26:	6313      	str	r3, [r2, #48]	; 0x30
 8002b28:	6b14      	ldr	r4, [r2, #48]	; 0x30
  rccResetAPB1R1(~0);
 8002b2a:	6b94      	ldr	r4, [r2, #56]	; 0x38
 8002b2c:	6390      	str	r0, [r2, #56]	; 0x38
 8002b2e:	6b94      	ldr	r4, [r2, #56]	; 0x38
 8002b30:	6393      	str	r3, [r2, #56]	; 0x38
 8002b32:	6b94      	ldr	r4, [r2, #56]	; 0x38
  rccResetAPB1R2(~0);
 8002b34:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
 8002b36:	63d0      	str	r0, [r2, #60]	; 0x3c
 8002b38:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
 8002b3a:	63d3      	str	r3, [r2, #60]	; 0x3c
 8002b3c:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
  rccResetAPB2(~0);
 8002b3e:	6c14      	ldr	r4, [r2, #64]	; 0x40
 8002b40:	6410      	str	r0, [r2, #64]	; 0x40
 8002b42:	6c10      	ldr	r0, [r2, #64]	; 0x40
 8002b44:	6413      	str	r3, [r2, #64]	; 0x40
 8002b46:	6c10      	ldr	r0, [r2, #64]	; 0x40

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, false);
 8002b48:	6e10      	ldr	r0, [r2, #96]	; 0x60
 8002b4a:	f040 0001 	orr.w	r0, r0, #1
 8002b4e:	6610      	str	r0, [r2, #96]	; 0x60
 8002b50:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
 8002b54:	f020 0001 	bic.w	r0, r0, #1
 8002b58:	f8c2 0080 	str.w	r0, [r2, #128]	; 0x80
 8002b5c:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
  rccEnablePWRInterface(false);
 8002b60:	6d90      	ldr	r0, [r2, #88]	; 0x58
 8002b62:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000
 8002b66:	6590      	str	r0, [r2, #88]	; 0x58
 8002b68:	6f90      	ldr	r0, [r2, #120]	; 0x78
 8002b6a:	f020 5080 	bic.w	r0, r0, #268435456	; 0x10000000
 8002b6e:	6790      	str	r0, [r2, #120]	; 0x78
  PWR->CR3   = STM32_PWR_CR3;
 8002b70:	f44f 4400 	mov.w	r4, #32768	; 0x8000
  rccEnablePWRInterface(false);
 8002b74:	6f90      	ldr	r0, [r2, #120]	; 0x78
  PWR->CR3   = STM32_PWR_CR3;
 8002b76:	608c      	str	r4, [r1, #8]
  PWR->CR4   = STM32_PWR_CR4;
 8002b78:	60cb      	str	r3, [r1, #12]
  PWR->PUCRA = STM32_PWR_PUCRA;
 8002b7a:	620b      	str	r3, [r1, #32]
  PWR->PDCRA = STM32_PWR_PDCRA;
 8002b7c:	624b      	str	r3, [r1, #36]	; 0x24
  PWR->PUCRB = STM32_PWR_PUCRB;
 8002b7e:	628b      	str	r3, [r1, #40]	; 0x28
  PWR->PDCRB = STM32_PWR_PDCRB;
 8002b80:	62cb      	str	r3, [r1, #44]	; 0x2c
  PWR->PUCRC = STM32_PWR_PUCRC;
 8002b82:	630b      	str	r3, [r1, #48]	; 0x30
  PWR->PDCRC = STM32_PWR_PDCRC;
 8002b84:	634b      	str	r3, [r1, #52]	; 0x34
  PWR->PUCRD = STM32_PWR_PUCRD;
 8002b86:	638b      	str	r3, [r1, #56]	; 0x38
  PWR->PDCRD = STM32_PWR_PDCRD;
 8002b88:	63cb      	str	r3, [r1, #60]	; 0x3c
  PWR->PUCRE = STM32_PWR_PUCRE;
 8002b8a:	640b      	str	r3, [r1, #64]	; 0x40
  PWR->PDCRE = STM32_PWR_PDCRE;
 8002b8c:	644b      	str	r3, [r1, #68]	; 0x44
  PWR->PUCRF = STM32_PWR_PUCRF;
 8002b8e:	648b      	str	r3, [r1, #72]	; 0x48
  PWR->PDCRF = STM32_PWR_PDCRF;
 8002b90:	64cb      	str	r3, [r1, #76]	; 0x4c
  PWR->PUCRG = STM32_PWR_PUCRG;
 8002b92:	650b      	str	r3, [r1, #80]	; 0x50
  PWR->PDCRG = STM32_PWR_PDCRG;
 8002b94:	654b      	str	r3, [r1, #84]	; 0x54

  /* Static PWR configurations.*/
  hal_lld_set_static_pwr();

  /* Backup domain made accessible.*/
  PWR->CR1 |= PWR_CR1_DBP;
 8002b96:	6808      	ldr	r0, [r1, #0]
 8002b98:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 8002b9c:	6008      	str	r0, [r1, #0]
 *          of the whole BKP domain.
 */
__STATIC_INLINE void bd_reset(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8002b9e:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 8002ba2:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8002ba6:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8002baa:	d005      	beq.n	8002bb8 <__early_init+0x188>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8002bac:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8002bb0:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
    RCC->BDCR = 0U;
 8002bb4:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN;
 8002bb8:	4a36      	ldr	r2, [pc, #216]	; (8002c94 <__early_init+0x264>)
 8002bba:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002bbe:	f043 0319 	orr.w	r3, r3, #25
 8002bc2:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif
  while ((RCC->BDCR & (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) !=
 8002bc6:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8002bca:	079b      	lsls	r3, r3, #30
 8002bcc:	d5fb      	bpl.n	8002bc6 <__early_init+0x196>
  RCC->CCIPR  = STM32_ADC345SEL  | STM32_ADC12SEL   | STM32_CLK48SEL   |
 8002bce:	4b37      	ldr	r3, [pc, #220]	; (8002cac <__early_init+0x27c>)
  PWR->CR1 = PWR_CR1_VOS_0;
 8002bd0:	4935      	ldr	r1, [pc, #212]	; (8002ca8 <__early_init+0x278>)
  RCC->CFGR   = STM32_MCOPRE | STM32_MCOSEL | STM32_PPRE2 | STM32_PPRE1 |
 8002bd2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8002bd6:	6094      	str	r4, [r2, #8]
  RCC->CCIPR2 = STM32_QSPISEL    | STM32_I2C4SEL;
 8002bd8:	2000      	movs	r0, #0
  RCC->CCIPR  = STM32_ADC345SEL  | STM32_ADC12SEL   | STM32_CLK48SEL   |
 8002bda:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  PWR->CR1 = PWR_CR1_VOS_0;
 8002bde:	f44f 7300 	mov.w	r3, #512	; 0x200
  RCC->CCIPR2 = STM32_QSPISEL    | STM32_I2C4SEL;
 8002be2:	f8c2 009c 	str.w	r0, [r2, #156]	; 0x9c
  PWR->CR1 = PWR_CR1_VOS_0;
 8002be6:	600b      	str	r3, [r1, #0]
  while ((PWR->SR2 & (PWR_SR2_VOSF | PWR_SR2_REGLPF)) != 0U) {
 8002be8:	694b      	ldr	r3, [r1, #20]
 8002bea:	f413 6fc0 	tst.w	r3, #1536	; 0x600
 8002bee:	d1fb      	bne.n	8002be8 <__early_init+0x1b8>
  if ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI) {
 8002bf0:	4a28      	ldr	r2, [pc, #160]	; (8002c94 <__early_init+0x264>)
 8002bf2:	6893      	ldr	r3, [r2, #8]
 8002bf4:	f003 030c 	and.w	r3, r3, #12
 8002bf8:	2b04      	cmp	r3, #4
 8002bfa:	d161      	bne.n	8002cc0 <__early_init+0x290>

#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass case.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  RCC->CR |= RCC_CR_HSEON;
 8002bfc:	4b25      	ldr	r3, [pc, #148]	; (8002c94 <__early_init+0x264>)
 8002bfe:	681a      	ldr	r2, [r3, #0]
 8002c00:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002c04:	601a      	str	r2, [r3, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0U) {
 8002c06:	681a      	ldr	r2, [r3, #0]
 8002c08:	0390      	lsls	r0, r2, #14
 8002c0a:	d5fc      	bpl.n	8002c06 <__early_init+0x1d6>

#if STM32_RCC_HAS_HSI48 == TRUE
#if defined(RCC_CRRCR_HSI48ON)
__STATIC_INLINE void hsi48_enable(void) {

  RCC->CRRCR |= RCC_CRRCR_HSI48ON;
 8002c0c:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
  while ((RCC->CRRCR & RCC_CRRCR_HSI48RDY) == 0U) {
 8002c10:	4a20      	ldr	r2, [pc, #128]	; (8002c94 <__early_init+0x264>)
  RCC->CRRCR |= RCC_CRRCR_HSI48ON;
 8002c12:	f041 0101 	orr.w	r1, r1, #1
 8002c16:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
  while ((RCC->CRRCR & RCC_CRRCR_HSI48RDY) == 0U) {
 8002c1a:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
 8002c1e:	0799      	lsls	r1, r3, #30
 8002c20:	d5fb      	bpl.n	8002c1a <__early_init+0x1ea>
  RCC->PLLCFGR = ccp->rcc_pllcfgr;
 8002c22:	4923      	ldr	r1, [pc, #140]	; (8002cb0 <__early_init+0x280>)
  RCC->CR =  ccp->rcc_cr | RCC_CR_HSION;
 8002c24:	4b23      	ldr	r3, [pc, #140]	; (8002cb4 <__early_init+0x284>)
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE bool pll_not_locked(void) {

  return (bool)((RCC->CR & RCC_CR_PLLRDY) == 0U);
 8002c26:	481b      	ldr	r0, [pc, #108]	; (8002c94 <__early_init+0x264>)
  RCC->PLLCFGR = ccp->rcc_pllcfgr;
 8002c28:	60d1      	str	r1, [r2, #12]
  RCC->CR =  ccp->rcc_cr | RCC_CR_HSION;
 8002c2a:	6013      	str	r3, [r2, #0]
 8002c2c:	6803      	ldr	r3, [r0, #0]
    if (((ccp->rcc_cr & RCC_CR_PLLON) != 0U) && pll_not_locked()) {
 8002c2e:	019a      	lsls	r2, r3, #6
 8002c30:	d5fc      	bpl.n	8002c2c <__early_init+0x1fc>
  RCC->CFGR = (RCC->CFGR & RCC_CFGR_SW_Msk) | (ccp->rcc_cfgr & ~RCC_CFGR_SW_Msk);
 8002c32:	6883      	ldr	r3, [r0, #8]
  FLASH->ACR = acr;
 8002c34:	4a20      	ldr	r2, [pc, #128]	; (8002cb8 <__early_init+0x288>)
 8002c36:	4921      	ldr	r1, [pc, #132]	; (8002cbc <__early_init+0x28c>)
  RCC->CFGR = (RCC->CFGR & RCC_CFGR_SW_Msk) | (ccp->rcc_cfgr & ~RCC_CFGR_SW_Msk);
 8002c38:	f003 0303 	and.w	r3, r3, #3
 8002c3c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8002c40:	6083      	str	r3, [r0, #8]
  FLASH->ACR = acr;
 8002c42:	6011      	str	r1, [r2, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) != (acr & FLASH_ACR_LATENCY_Msk)) {
 8002c44:	6813      	ldr	r3, [r2, #0]
 8002c46:	404b      	eors	r3, r1
 8002c48:	f013 030f 	ands.w	r3, r3, #15
 8002c4c:	d1fa      	bne.n	8002c44 <__early_init+0x214>
  PWR->CR1 = ccp->pwr_cr1;
 8002c4e:	4a16      	ldr	r2, [pc, #88]	; (8002ca8 <__early_init+0x278>)
 8002c50:	f44f 7040 	mov.w	r0, #768	; 0x300
  PWR->CR5 = ccp->pwr_cr5;
 8002c54:	f44f 7180 	mov.w	r1, #256	; 0x100
  PWR->CR1 = ccp->pwr_cr1;
 8002c58:	6010      	str	r0, [r2, #0]
  PWR->CR2 = ccp->pwr_cr2;
 8002c5a:	6053      	str	r3, [r2, #4]
  PWR->CR5 = ccp->pwr_cr5;
 8002c5c:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
    while ((PWR->SR2 & PWR_SR2_REGLPF) != 0U) {
 8002c60:	6953      	ldr	r3, [r2, #20]
 8002c62:	059b      	lsls	r3, r3, #22
 8002c64:	d4fc      	bmi.n	8002c60 <__early_init+0x230>
  RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_SW_Msk) | (ccp->rcc_cfgr & RCC_CFGR_SW_Msk);
 8002c66:	4a0b      	ldr	r2, [pc, #44]	; (8002c94 <__early_init+0x264>)
 8002c68:	6893      	ldr	r3, [r2, #8]
 8002c6a:	f043 0303 	orr.w	r3, r3, #3
  while ((RCC->CFGR & RCC_CFGR_SWS) != ((ccp->rcc_cfgr & RCC_CFGR_SW_Msk) << RCC_CFGR_SWS_Pos)) {
 8002c6e:	f241 010c 	movw	r1, #4108	; 0x100c
  RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_SW_Msk) | (ccp->rcc_cfgr & RCC_CFGR_SW_Msk);
 8002c72:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != ((ccp->rcc_cfgr & RCC_CFGR_SW_Msk) << RCC_CFGR_SWS_Pos)) {
 8002c74:	6893      	ldr	r3, [r2, #8]
 8002c76:	404b      	eors	r3, r1
 8002c78:	f013 0f0c 	tst.w	r3, #12
 8002c7c:	d1fa      	bne.n	8002c74 <__early_init+0x244>
  bdcr = RCC->BDCR;
 8002c7e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
  bdcr &= ~(STM32_RTCSEL_MASK | STM32_LSCOSEL_MASK);
 8002c82:	f023 2303 	bic.w	r3, r3, #50332416	; 0x3000300
  bdcr |= STM32_RTCSEL | STM32_LSCOSEL;
 8002c86:	f443 7380 	orr.w	r3, r3, #256	; 0x100

  stm32_gpio_init();
  stm32_clock_init();
}
 8002c8a:	bc30      	pop	{r4, r5}
  RCC->BDCR = bdcr;
 8002c8c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8002c90:	4770      	bx	lr
 8002c92:	bf00      	nop
 8002c94:	40021000 	.word	0x40021000
 8002c98:	48000400 	.word	0x48000400
 8002c9c:	3c000c00 	.word	0x3c000c00
 8002ca0:	ebfff7af 	.word	0xebfff7af
 8002ca4:	48000c00 	.word	0x48000c00
 8002ca8:	40007000 	.word	0x40007000
 8002cac:	50000155 	.word	0x50000155
 8002cb0:	01615553 	.word	0x01615553
 8002cb4:	01010300 	.word	0x01010300
 8002cb8:	40022000 	.word	0x40022000
 8002cbc:	00040704 	.word	0x00040704
/* Driver local functions.                                                   */
/*===========================================================================*/

__STATIC_INLINE void hsi16_enable(void) {

  RCC->CR |= RCC_CR_HSION;
 8002cc0:	6813      	ldr	r3, [r2, #0]
 8002cc2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002cc6:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSIRDY) == 0U) {
 8002cc8:	6813      	ldr	r3, [r2, #0]
 8002cca:	055d      	lsls	r5, r3, #21
 8002ccc:	d5fc      	bpl.n	8002cc8 <__early_init+0x298>

  /* Making sure HSI is active and ready.*/
  hsi16_enable();

  /* Clocking from HSI, in case HSI was not the default source.*/
  RCC->CFGR = RCC_CFGR_SW_HSI;
 8002cce:	2301      	movs	r3, #1
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI) {
 8002cd0:	490d      	ldr	r1, [pc, #52]	; (8002d08 <__early_init+0x2d8>)
  RCC->CFGR = RCC_CFGR_SW_HSI;
 8002cd2:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI) {
 8002cd4:	688b      	ldr	r3, [r1, #8]
 8002cd6:	f003 030c 	and.w	r3, r3, #12
 8002cda:	2b04      	cmp	r3, #4
 8002cdc:	d1fa      	bne.n	8002cd4 <__early_init+0x2a4>
  FLASH->ACR = acr;
 8002cde:	4a0b      	ldr	r2, [pc, #44]	; (8002d0c <__early_init+0x2dc>)
 8002ce0:	4b0b      	ldr	r3, [pc, #44]	; (8002d10 <__early_init+0x2e0>)
 8002ce2:	6013      	str	r3, [r2, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) != (acr & FLASH_ACR_LATENCY_Msk)) {
 8002ce4:	6813      	ldr	r3, [r2, #0]
 8002ce6:	f013 030f 	ands.w	r3, r3, #15
 8002cea:	d1fb      	bne.n	8002ce4 <__early_init+0x2b4>
    RCC->CRRCR = 0U;
 8002cec:	4a06      	ldr	r2, [pc, #24]	; (8002d08 <__early_init+0x2d8>)
    RCC->CR    = 0x00000063U;
 8002cee:	2163      	movs	r1, #99	; 0x63
    RCC->CRRCR = 0U;
 8002cf0:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    RCC->CR    = 0x00000063U;
 8002cf4:	6011      	str	r1, [r2, #0]
    while ((RCC->CR & RCC_CR_HSERDY) != 0U) {
 8002cf6:	6813      	ldr	r3, [r2, #0]
 8002cf8:	039c      	lsls	r4, r3, #14
 8002cfa:	d4fc      	bmi.n	8002cf6 <__early_init+0x2c6>
    PWR->CR5 = PWR_CR5_R1MODE;
 8002cfc:	4b05      	ldr	r3, [pc, #20]	; (8002d14 <__early_init+0x2e4>)
 8002cfe:	f44f 7280 	mov.w	r2, #256	; 0x100
 8002d02:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
 8002d06:	e779      	b.n	8002bfc <__early_init+0x1cc>
 8002d08:	40021000 	.word	0x40021000
 8002d0c:	40022000 	.word	0x40022000
 8002d10:	00040600 	.word	0x00040600
 8002d14:	40007000 	.word	0x40007000
	...

08002d20 <chThdExit>:
void chThdExit(msg_t msg) {
 8002d20:	b570      	push	{r4, r5, r6, lr}
 8002d22:	2330      	movs	r3, #48	; 0x30
 8002d24:	f383 8811 	msr	BASEPRI, r3
  return __sch_get_currthread();
 8002d28:	4b1d      	ldr	r3, [pc, #116]	; (8002da0 <chThdExit+0x80>)
 8002d2a:	68d9      	ldr	r1, [r3, #12]
  return (bool)(lp->next != lp);
 8002d2c:	6d4a      	ldr	r2, [r1, #84]	; 0x54
  currtp->u.exitcode = msg;
 8002d2e:	6508      	str	r0, [r1, #80]	; 0x50
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8002d30:	f101 0c54 	add.w	ip, r1, #84	; 0x54
 8002d34:	4594      	cmp	ip, r2
  tp->state = CH_STATE_READY;
 8002d36:	bf18      	it	ne
 8002d38:	f04f 0e00 	movne.w	lr, #0
 8002d3c:	d111      	bne.n	8002d62 <chThdExit+0x42>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8002d3e:	f891 204e 	ldrb.w	r2, [r1, #78]	; 0x4e
 8002d42:	b31a      	cbz	r2, 8002d8c <chThdExit+0x6c>
  ch_priority_queue_t *p = pqp->next;
 8002d44:	6818      	ldr	r0, [r3, #0]
  otp->state = newstate;
 8002d46:	220f      	movs	r2, #15
 8002d48:	f881 204c 	strb.w	r2, [r1, #76]	; 0x4c
  pqp->next       = p->next;
 8002d4c:	6802      	ldr	r2, [r0, #0]
 8002d4e:	601a      	str	r2, [r3, #0]
  ntp->state = CH_STATE_CURRENT;
 8002d50:	f04f 0c01 	mov.w	ip, #1
  pqp->next->prev = pqp;
 8002d54:	6053      	str	r3, [r2, #4]
 8002d56:	f880 c04c 	strb.w	ip, [r0, #76]	; 0x4c
  __instance_set_currthread(oip, ntp);
 8002d5a:	60d8      	str	r0, [r3, #12]
  chSysSwitch(ntp, otp);
 8002d5c:	df00      	svc	0
}
 8002d5e:	bd70      	pop	{r4, r5, r6, pc}
 8002d60:	4622      	mov	r2, r4
  lp->next = p->next;
 8002d62:	6814      	ldr	r4, [r2, #0]
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8002d64:	6c10      	ldr	r0, [r2, #64]	; 0x40
  } while (unlikely(pqp->prio >= p->prio));
 8002d66:	6896      	ldr	r6, [r2, #8]
  lp->next = p->next;
 8002d68:	654c      	str	r4, [r1, #84]	; 0x54
  tp->state = CH_STATE_READY;
 8002d6a:	f882 e04c 	strb.w	lr, [r2, #76]	; 0x4c
    pqp = pqp->next;
 8002d6e:	6800      	ldr	r0, [r0, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8002d70:	6885      	ldr	r5, [r0, #8]
 8002d72:	42b5      	cmp	r5, r6
 8002d74:	d2fb      	bcs.n	8002d6e <chThdExit+0x4e>
  p->prev       = pqp->prev;
 8002d76:	6845      	ldr	r5, [r0, #4]
  p->next       = pqp;
 8002d78:	6010      	str	r0, [r2, #0]
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8002d7a:	4564      	cmp	r4, ip
  p->prev       = pqp->prev;
 8002d7c:	6055      	str	r5, [r2, #4]
  p->prev->next = p;
 8002d7e:	602a      	str	r2, [r5, #0]
  pqp->prev     = p;
 8002d80:	6042      	str	r2, [r0, #4]
 8002d82:	d1ed      	bne.n	8002d60 <chThdExit+0x40>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8002d84:	f891 204e 	ldrb.w	r2, [r1, #78]	; 0x4e
 8002d88:	2a00      	cmp	r2, #0
 8002d8a:	d1db      	bne.n	8002d44 <chThdExit+0x24>
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8002d8c:	f891 204d 	ldrb.w	r2, [r1, #77]	; 0x4d
 8002d90:	0792      	lsls	r2, r2, #30
 8002d92:	d1d7      	bne.n	8002d44 <chThdExit+0x24>
  p->prev->next = p->next;
 8002d94:	e9d1 200e 	ldrd	r2, r0, [r1, #56]	; 0x38
 8002d98:	6002      	str	r2, [r0, #0]
  p->next->prev = p->prev;
 8002d9a:	6050      	str	r0, [r2, #4]
  return p;
 8002d9c:	e7d2      	b.n	8002d44 <chThdExit+0x24>
 8002d9e:	bf00      	nop
 8002da0:	20000a68 	.word	0x20000a68
	...

08002db0 <__port_schedule_next>:
/**
 * @brief   Tail ISR context switch code.
 *
 * @return              The threads pointers encoded in a single 64 bits value.
 */
uint64_t __port_schedule_next(void) {
 8002db0:	b410      	push	{r4}
 8002db2:	2330      	movs	r3, #48	; 0x30
 8002db4:	f383 8811 	msr	BASEPRI, r3
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);
 8002db8:	4a11      	ldr	r2, [pc, #68]	; (8002e00 <__port_schedule_next+0x50>)
 8002dba:	68d3      	ldr	r3, [r2, #12]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 8002dbc:	6810      	ldr	r0, [r2, #0]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8002dbe:	6899      	ldr	r1, [r3, #8]

  /* Note, not an error, we are outside the ISR already.*/
  chSysLock();

  if (likely(chSchIsPreemptionRequired())) {
 8002dc0:	6884      	ldr	r4, [r0, #8]
 8002dc2:	428c      	cmp	r4, r1
 8002dc4:	d916      	bls.n	8002df4 <__port_schedule_next+0x44>
  pqp->next       = p->next;
 8002dc6:	6804      	ldr	r4, [r0, #0]
 8002dc8:	6014      	str	r4, [r2, #0]
  pqp->next->prev = pqp;
 8002dca:	6062      	str	r2, [r4, #4]
  thread_t *otp = __instance_get_currthread(oip);
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
 8002dcc:	2401      	movs	r4, #1
 8002dce:	f880 404c 	strb.w	r4, [r0, #76]	; 0x4c
  __instance_set_currthread(oip, ntp);
 8002dd2:	60d0      	str	r0, [r2, #12]
  tp->state = CH_STATE_READY;
 8002dd4:	2400      	movs	r4, #0
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8002dd6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  tp->state = CH_STATE_READY;
 8002dd8:	f883 404c 	strb.w	r4, [r3, #76]	; 0x4c
    pqp = pqp->next;
 8002ddc:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio > p->prio));
 8002dde:	6894      	ldr	r4, [r2, #8]
 8002de0:	42a1      	cmp	r1, r4
 8002de2:	d3fb      	bcc.n	8002ddc <__port_schedule_next+0x2c>
  p->prev       = pqp->prev;
 8002de4:	6851      	ldr	r1, [r2, #4]
  }

  chSysUnlock();

  return (uint64_t)0;
}
 8002de6:	bc10      	pop	{r4}
 8002de8:	e9c3 2100 	strd	r2, r1, [r3]
  p->prev->next = p;
 8002dec:	600b      	str	r3, [r1, #0]
    return ((uint64_t)(uint32_t)otp << 32) | ((uint64_t)(uint32_t)ntp << 0);
 8002dee:	4619      	mov	r1, r3
  pqp->prev     = p;
 8002df0:	6053      	str	r3, [r2, #4]
}
 8002df2:	4770      	bx	lr
 8002df4:	2000      	movs	r0, #0
 8002df6:	f380 8811 	msr	BASEPRI, r0
  return (uint64_t)0;
 8002dfa:	4601      	mov	r1, r0
}
 8002dfc:	bc10      	pop	{r4}
 8002dfe:	4770      	bx	lr
 8002e00:	20000a68 	.word	0x20000a68
	...

08002e10 <main>:
}




int main(void) {
 8002e10:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
void nvicInit(void) {
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  uint32_t n = 0U;
#else
  uint32_t n = SCnSCB->ICTR;
 8002e14:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8002e18:	b089      	sub	sp, #36	; 0x24
 8002e1a:	685c      	ldr	r4, [r3, #4]
#endif

  for (uint32_t i = 0U; i <= n; i++) {
 8002e1c:	2200      	movs	r2, #0
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 8002e1e:	f04f 30ff 	mov.w	r0, #4294967295
 8002e22:	0093      	lsls	r3, r2, #2
 8002e24:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8002e28:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
  for (uint32_t i = 0U; i <= n; i++) {
 8002e2c:	4294      	cmp	r4, r2
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 8002e2e:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
  for (uint32_t i = 0U; i <= n; i++) {
 8002e32:	f102 0201 	add.w	r2, r2, #1
    NVIC->__ICPR[i] = 0xFFFFFFFFU;
 8002e36:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  for (uint32_t i = 0U; i <= n; i++) {
 8002e3a:	d1f2      	bne.n	8002e22 <main+0x12>
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002e3c:	4abe      	ldr	r2, [pc, #760]	; (8003138 <main+0x328>)
 8002e3e:	2360      	movs	r3, #96	; 0x60
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e40:	2140      	movs	r1, #64	; 0x40
 8002e42:	2480      	movs	r4, #128	; 0x80
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002e44:	f882 3306 	strb.w	r3, [r2, #774]	; 0x306
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e48:	f44f 7080 	mov.w	r0, #256	; 0x100
 8002e4c:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002e50:	6011      	str	r1, [r2, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002e52:	f882 3307 	strb.w	r3, [r2, #775]	; 0x307
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e56:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002e5a:	6014      	str	r4, [r2, #0]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e5c:	f44f 7400 	mov.w	r4, #512	; 0x200
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002e60:	f882 3308 	strb.w	r3, [r2, #776]	; 0x308
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e64:	f8c2 0180 	str.w	r0, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002e68:	6010      	str	r0, [r2, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002e6a:	f882 3309 	strb.w	r3, [r2, #777]	; 0x309
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e6e:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002e72:	6014      	str	r4, [r2, #0]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e74:	f44f 6480 	mov.w	r4, #1024	; 0x400
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002e78:	f882 330a 	strb.w	r3, [r2, #778]	; 0x30a
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e7c:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002e80:	6014      	str	r4, [r2, #0]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e82:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002e86:	f882 3317 	strb.w	r3, [r2, #791]	; 0x317
 8002e8a:	2570      	movs	r5, #112	; 0x70
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e8c:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002e90:	6014      	str	r4, [r2, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002e92:	f882 3328 	strb.w	r3, [r2, #808]	; 0x328
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002e96:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002e9a:	f8c2 0184 	str.w	r0, [r2, #388]	; 0x184
 8002e9e:	f04f 5400 	mov.w	r4, #536870912	; 0x20000000
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002ea2:	6050      	str	r0, [r2, #4]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002ea4:	f882 531c 	strb.w	r5, [r2, #796]	; 0x31c
 8002ea8:	20c0      	movs	r0, #192	; 0xc0
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002eaa:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002eae:	6013      	str	r3, [r2, #0]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002eb0:	2320      	movs	r3, #32
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002eb2:	f882 531d 	strb.w	r5, [r2, #797]	; 0x31d
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002eb6:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002eba:	6014      	str	r4, [r2, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002ebc:	f882 0325 	strb.w	r0, [r2, #805]	; 0x325
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002ec0:	f8c2 3184 	str.w	r3, [r2, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002ec4:	6053      	str	r3, [r2, #4]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002ec6:	4b9d      	ldr	r3, [pc, #628]	; (800313c <main+0x32c>)
 8002ec8:	f882 0326 	strb.w	r0, [r2, #806]	; 0x326
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002ecc:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
 8002ed0:	f8c2 1184 	str.w	r1, [r2, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002ed4:	6051      	str	r1, [r2, #4]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8002ed6:	f882 035b 	strb.w	r0, [r2, #859]	; 0x35b
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002eda:	f503 7180 	add.w	r1, r3, #256	; 0x100
 8002ede:	f8c2 4188 	str.w	r4, [r2, #392]	; 0x188
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002ee2:	6094      	str	r4, [r2, #8]
    _pal_init_event(i);
 8002ee4:	2200      	movs	r2, #0
  qp->prev = qp;
 8002ee6:	e9c3 3300 	strd	r3, r3, [r3]
 8002eea:	e9c3 2202 	strd	r2, r2, [r3, #8]
  for (i = 0; i < 16; i++) {
 8002eee:	3310      	adds	r3, #16
 8002ef0:	428b      	cmp	r3, r1
 8002ef2:	d1f8      	bne.n	8002ee6 <main+0xd6>
  pwmp->state    = PWM_STOP;
 8002ef4:	4b92      	ldr	r3, [pc, #584]	; (8003140 <main+0x330>)
  PWMD3.tim = STM32_TIM3;
 8002ef6:	4993      	ldr	r1, [pc, #588]	; (8003144 <main+0x334>)
  iqp->q_buffer  = bp;
 8002ef8:	4893      	ldr	r0, [pc, #588]	; (8003148 <main+0x338>)
 8002efa:	61d9      	str	r1, [r3, #28]
  sdp->vmt = &vmt;
 8002efc:	4993      	ldr	r1, [pc, #588]	; (800314c <main+0x33c>)
  pwmp->config   = NULL;
 8002efe:	605a      	str	r2, [r3, #4]
  iqp->q_wrptr   = bp;
 8002f00:	e9c1 0008 	strd	r0, r0, [r1, #32]
  iqp->q_buffer  = bp;
 8002f04:	6188      	str	r0, [r1, #24]
  iqp->q_top     = bp + size;
 8002f06:	3010      	adds	r0, #16
 8002f08:	61c8      	str	r0, [r1, #28]
  oqp->q_buffer  = bp;
 8002f0a:	4891      	ldr	r0, [pc, #580]	; (8003150 <main+0x340>)
 8002f0c:	63c8      	str	r0, [r1, #60]	; 0x3c
 8002f0e:	460f      	mov	r7, r1
  oqp->q_wrptr   = bp;
 8002f10:	e9c1 0011 	strd	r0, r0, [r1, #68]	; 0x44
  oqp->q_top     = bp + size;
 8002f14:	3010      	adds	r0, #16
  pwmp->state    = PWM_STOP;
 8002f16:	2401      	movs	r4, #1
 8002f18:	6408      	str	r0, [r1, #64]	; 0x40
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8002f1a:	2504      	movs	r5, #4
 8002f1c:	488d      	ldr	r0, [pc, #564]	; (8003154 <main+0x344>)
 8002f1e:	f847 0b04 	str.w	r0, [r7], #4
 8002f22:	701c      	strb	r4, [r3, #0]
  pwmp->enabled  = 0;
 8002f24:	60da      	str	r2, [r3, #12]
 8002f26:	741d      	strb	r5, [r3, #16]
  PWMD3.has_bdtr = false;
 8002f28:	761a      	strb	r2, [r3, #24]
 8002f2a:	4b8b      	ldr	r3, [pc, #556]	; (8003158 <main+0x348>)
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8002f2c:	604f      	str	r7, [r1, #4]
 8002f2e:	461e      	mov	r6, r3
  qp->next = qp;
 8002f30:	f101 070c 	add.w	r7, r1, #12
  qp->prev = qp;
 8002f34:	e9c1 7703 	strd	r7, r7, [r1, #12]
  oqp->q_notify  = onfy;
 8002f38:	f8df 8220 	ldr.w	r8, [pc, #544]	; 800315c <main+0x34c>
 8002f3c:	f846 0b04 	str.w	r0, [r6], #4
  qp->next = qp;
 8002f40:	f101 0730 	add.w	r7, r1, #48	; 0x30
  siop->vmt         = &vmt;
 8002f44:	4886      	ldr	r0, [pc, #536]	; (8003160 <main+0x350>)
 8002f46:	f8c1 804c 	str.w	r8, [r1, #76]	; 0x4c
  qp->prev = qp;
 8002f4a:	e9c1 770c 	strd	r7, r7, [r1, #48]	; 0x30
  SD1.clock = STM32_USART1CLK;
 8002f4e:	f8df c214 	ldr.w	ip, [pc, #532]	; 8003164 <main+0x354>
  SD1.usart = USART1;
 8002f52:	f8df 8214 	ldr.w	r8, [pc, #532]	; 8003168 <main+0x358>
  iqp->q_counter = 0;
 8002f56:	614a      	str	r2, [r1, #20]
  oqp->q_counter = size;
 8002f58:	2710      	movs	r7, #16
 8002f5a:	638f      	str	r7, [r1, #56]	; 0x38
 8002f5c:	f8c1 8054 	str.w	r8, [r1, #84]	; 0x54
  iqp->q_link    = link;
 8002f60:	e9c1 210a 	strd	r2, r1, [r1, #40]	; 0x28
  sdp->state = SD_STOP;
 8002f64:	720c      	strb	r4, [r1, #8]
  oqp->q_link    = link;
 8002f66:	6509      	str	r1, [r1, #80]	; 0x50
  SD1.clock = STM32_USART1CLK;
 8002f68:	f8c1 c058 	str.w	ip, [r1, #88]	; 0x58
  qp->next = qp;
 8002f6c:	f103 0e0c 	add.w	lr, r3, #12
 8002f70:	497e      	ldr	r1, [pc, #504]	; (800316c <main+0x35c>)
 8002f72:	605e      	str	r6, [r3, #4]
 8002f74:	721c      	strb	r4, [r3, #8]
  qp->prev = qp;
 8002f76:	e9c3 ee03 	strd	lr, lr, [r3, #12]
 8002f7a:	6001      	str	r1, [r0, #0]
  iqp->q_buffer  = bp;
 8002f7c:	497c      	ldr	r1, [pc, #496]	; (8003170 <main+0x360>)
 8002f7e:	6199      	str	r1, [r3, #24]
  iqp->q_wrptr   = bp;
 8002f80:	e9c3 1108 	strd	r1, r1, [r3, #32]
  iqp->q_top     = bp + size;
 8002f84:	4439      	add	r1, r7
  siop->enabled     = (sioevents_t)0;
 8002f86:	e9c0 2202 	strd	r2, r2, [r0, #8]
 8002f8a:	61d9      	str	r1, [r3, #28]
  oqp->q_buffer  = bp;
 8002f8c:	4979      	ldr	r1, [pc, #484]	; (8003174 <main+0x364>)
  ST_ENABLE_CLOCK();
 8002f8e:	4e7a      	ldr	r6, [pc, #488]	; (8003178 <main+0x368>)
  iqp->q_counter = 0;
 8002f90:	615a      	str	r2, [r3, #20]
  oqp->q_wrptr   = bp;
 8002f92:	e9c3 1111 	strd	r1, r1, [r3, #68]	; 0x44
  oqp->q_counter = size;
 8002f96:	639f      	str	r7, [r3, #56]	; 0x38
  SD2.clock = STM32_USART2CLK;
 8002f98:	f8c3 c058 	str.w	ip, [r3, #88]	; 0x58
  siop->state       = SIO_STOP;
 8002f9c:	7104      	strb	r4, [r0, #4]
  oqp->q_buffer  = bp;
 8002f9e:	63d9      	str	r1, [r3, #60]	; 0x3c
  oqp->q_top     = bp + size;
 8002fa0:	4439      	add	r1, r7
  qp->next = qp;
 8002fa2:	f103 0730 	add.w	r7, r3, #48	; 0x30
 8002fa6:	6419      	str	r1, [r3, #64]	; 0x40
 8002fa8:	6db1      	ldr	r1, [r6, #88]	; 0x58
  oqp->q_link    = link;
 8002faa:	651b      	str	r3, [r3, #80]	; 0x50
  qp->prev = qp;
 8002fac:	e9c3 770c 	strd	r7, r7, [r3, #48]	; 0x30
  oqp->q_notify  = onfy;
 8002fb0:	4f72      	ldr	r7, [pc, #456]	; (800317c <main+0x36c>)
 8002fb2:	64df      	str	r7, [r3, #76]	; 0x4c
  SD2.usart = USART2;
 8002fb4:	4f72      	ldr	r7, [pc, #456]	; (8003180 <main+0x370>)
 8002fb6:	655f      	str	r7, [r3, #84]	; 0x54
  iqp->q_link    = link;
 8002fb8:	e9c3 230a 	strd	r2, r3, [r3, #40]	; 0x28
  LPSIOD1.clock     = STM32_LPUART1CLK;
 8002fbc:	4f71      	ldr	r7, [pc, #452]	; (8003184 <main+0x374>)
 8002fbe:	4b72      	ldr	r3, [pc, #456]	; (8003188 <main+0x378>)
 */
void chSysInit(void) {
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 8002fc0:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 800318c <main+0x37c>
 8002fc4:	4321      	orrs	r1, r4
 8002fc6:	e9c0 730a 	strd	r7, r3, [r0, #40]	; 0x28
  siop->arg         = NULL;
 8002fca:	e9c0 2204 	strd	r2, r2, [r0, #16]
  siop->sync_rxidle = NULL;
 8002fce:	e9c0 2206 	strd	r2, r2, [r0, #24]
  siop->sync_txend  = NULL;
 8002fd2:	e9c0 2208 	strd	r2, r2, [r0, #32]
 8002fd6:	65b1      	str	r1, [r6, #88]	; 0x58
 8002fd8:	6fb3      	ldr	r3, [r6, #120]	; 0x78
  ST_ENABLE_STOP();
 8002fda:	496d      	ldr	r1, [pc, #436]	; (8003190 <main+0x380>)
  ST_ENABLE_CLOCK();
 8002fdc:	4323      	orrs	r3, r4
 8002fde:	67b3      	str	r3, [r6, #120]	; 0x78
 8002fe0:	6fb3      	ldr	r3, [r6, #120]	; 0x78
  ST_ENABLE_STOP();
 8002fe2:	688b      	ldr	r3, [r1, #8]
 8002fe4:	4323      	orrs	r3, r4
 8002fe6:	608b      	str	r3, [r1, #8]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002fe8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002fec:	f244 2167 	movw	r1, #16999	; 0x4267
 8002ff0:	6299      	str	r1, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002ff2:	f04f 31ff 	mov.w	r1, #4294967295
 8002ff6:	62d9      	str	r1, [r3, #44]	; 0x2c
  tmp->cumulative = (rttime_t)0;
 8002ff8:	2000      	movs	r0, #0
  STM32_ST_TIM->CCMR1  = 0;
 8002ffa:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002ffc:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8002ffe:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8003000:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8003002:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8003004:	601c      	str	r4, [r3, #0]
  tmp->best       = (rtcnt_t)-1;
 8003006:	9102      	str	r1, [sp, #8]
  tmp->cumulative = (rttime_t)0;
 8003008:	2100      	movs	r1, #0
 800300a:	e9cd 0106 	strd	r0, r1, [sp, #24]
  tmp->last       = (rtcnt_t)0;
 800300e:	e9cd 2203 	strd	r2, r2, [sp, #12]
 8003012:	f888 4000 	strb.w	r4, [r8]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 8003016:	f8c8 2008 	str.w	r2, [r8, #8]
  tmp->n          = (ucnt_t)0;
 800301a:	9205      	str	r2, [sp, #20]
  chTMObjectInit(&tm);
  i = TM_CALIBRATION_LOOP;
  do {
    chTMStartMeasurementX(&tm);
 800301c:	a802      	add	r0, sp, #8
 800301e:	f7fd faa7 	bl	8000570 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8003022:	f7fd faad 	bl	8000580 <chTMStopMeasurementX>
    i--;
  } while (i > 0U);
 8003026:	3d01      	subs	r5, #1
 8003028:	d1f8      	bne.n	800301c <main+0x20c>
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 800302a:	495a      	ldr	r1, [pc, #360]	; (8003194 <main+0x384>)
  qp->next = qp;
 800302c:	4a5a      	ldr	r2, [pc, #360]	; (8003198 <main+0x388>)
  ch_memcore.basemem = __heap_base__;
 800302e:	485b      	ldr	r0, [pc, #364]	; (800319c <main+0x38c>)
  tcp->offset = tm.best;
 8003030:	9b02      	ldr	r3, [sp, #8]
 8003032:	f8c8 3008 	str.w	r3, [r8, #8]
 8003036:	f101 040c 	add.w	r4, r1, #12
  qp->prev = qp;
 800303a:	e9c1 4403 	strd	r4, r4, [r1, #12]
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
  mp->align = align;
  mp->provider = provider;
 800303e:	4c58      	ldr	r4, [pc, #352]	; (80031a0 <main+0x390>)
 8003040:	6214      	str	r4, [r2, #32]
 8003042:	6394      	str	r4, [r2, #56]	; 0x38
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8003044:	f102 0410 	add.w	r4, r2, #16
 8003048:	6114      	str	r4, [r2, #16]
  mp->align = align;
 800304a:	2404      	movs	r4, #4
 800304c:	61d4      	str	r4, [r2, #28]
 800304e:	6354      	str	r4, [r2, #52]	; 0x34
 8003050:	f102 0424 	add.w	r4, r2, #36	; 0x24
 8003054:	6254      	str	r4, [r2, #36]	; 0x24
 8003056:	f102 0428 	add.w	r4, r2, #40	; 0x28
 800305a:	6294      	str	r4, [r2, #40]	; 0x28
 800305c:	f102 043c 	add.w	r4, r2, #60	; 0x3c
 8003060:	63d4      	str	r4, [r2, #60]	; 0x3c
 8003062:	f102 0440 	add.w	r4, r2, #64	; 0x40
 8003066:	6414      	str	r4, [r2, #64]	; 0x40
 8003068:	f102 0444 	add.w	r4, r2, #68	; 0x44
 800306c:	6454      	str	r4, [r2, #68]	; 0x44
 800306e:	4c4d      	ldr	r4, [pc, #308]	; (80031a4 <main+0x394>)
 8003070:	6004      	str	r4, [r0, #0]
  ch_memcore.topmem  = __heap_end__;
 8003072:	4c4d      	ldr	r4, [pc, #308]	; (80031a8 <main+0x398>)
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
 8003074:	4b4d      	ldr	r3, [pc, #308]	; (80031ac <main+0x39c>)
 8003076:	6044      	str	r4, [r0, #4]
 8003078:	484d      	ldr	r0, [pc, #308]	; (80031b0 <main+0x3a0>)
  mp->owner = NULL;
 800307a:	614d      	str	r5, [r1, #20]
  H_NEXT(&default_heap.header) = NULL;
  H_PAGES(&default_heap.header) = 0;
 800307c:	e9c1 5501 	strd	r5, r5, [r1, #4]
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8003080:	6008      	str	r0, [r1, #0]

  /* Core associated to this instance.*/
  oip->core_id = core_id;

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 8003082:	494c      	ldr	r1, [pc, #304]	; (80031b4 <main+0x3a4>)
 8003084:	6399      	str	r1, [r3, #56]	; 0x38
  mp->object_size = size;
 8003086:	2114      	movs	r1, #20
 8003088:	6191      	str	r1, [r2, #24]
 800308a:	211c      	movs	r1, #28
 800308c:	e9c2 2200 	strd	r2, r2, [r2]
 8003090:	6095      	str	r5, [r2, #8]
  mp->next = NULL;
 8003092:	6155      	str	r5, [r2, #20]
 8003094:	62d5      	str	r5, [r2, #44]	; 0x2c
  ch_system.instances[core_id] = oip;
 8003096:	f8c8 3004 	str.w	r3, [r8, #4]
  oip->core_id = core_id;
 800309a:	631d      	str	r5, [r3, #48]	; 0x30
 800309c:	2430      	movs	r4, #48	; 0x30
  mp->object_size = size;
 800309e:	6311      	str	r1, [r2, #48]	; 0x30
 80030a0:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 80030a4:	b662      	cpsie	i
  tp->epending          = (eventmask_t)0;
 80030a6:	e9c3 5527 	strd	r5, r5, [r3, #156]	; 0x9c
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80030aa:	4a43      	ldr	r2, [pc, #268]	; (80031b8 <main+0x3a8>)
  pqp->prio = (tprio_t)0;
 80030ac:	609d      	str	r5, [r3, #8]
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
 80030ae:	635d      	str	r5, [r3, #52]	; 0x34

  ch_dlist_init(&vtlp->dlist);
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 80030b0:	61dd      	str	r5, [r3, #28]
 80030b2:	68d0      	ldr	r0, [r2, #12]
  tp->owner             = oip;
 80030b4:	67db      	str	r3, [r3, #124]	; 0x7c
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80030b6:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 80030ba:	4008      	ands	r0, r1
  reg_value  =  (reg_value                                   |
 80030bc:	493f      	ldr	r1, [pc, #252]	; (80031bc <main+0x3ac>)
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 80030be:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
 80030c2:	4301      	orrs	r1, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 80030c4:	60d1      	str	r1, [r2, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80030c6:	f8d2 10fc 	ldr.w	r1, [r2, #252]	; 0xfc
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80030ca:	483d      	ldr	r0, [pc, #244]	; (80031c0 <main+0x3b0>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80030cc:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 80030d0:	f8c2 10fc 	str.w	r1, [r2, #252]	; 0xfc
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80030d4:	6801      	ldr	r1, [r0, #0]
 80030d6:	f041 0101 	orr.w	r1, r1, #1
 80030da:	6001      	str	r1, [r0, #0]
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80030dc:	2620      	movs	r6, #32
 80030de:	21f0      	movs	r1, #240	; 0xf0
 80030e0:	77d6      	strb	r6, [r2, #31]
 80030e2:	f882 1022 	strb.w	r1, [r2, #34]	; 0x22
  dlhp->next  = dlhp;
 80030e6:	f103 0210 	add.w	r2, r3, #16
  dlhp->prev  = dlhp;
 80030ea:	e9c3 2204 	strd	r2, r2, [r3, #16]
  dlhp->delta = (sysinterval_t)-1;
 80030ee:	f04f 32ff 	mov.w	r2, #4294967295
 80030f2:	619a      	str	r2, [r3, #24]
 80030f4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  lp->next = lp;
 80030f8:	f103 0690 	add.w	r6, r3, #144	; 0x90
 80030fc:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80030fe:	f8c3 6090 	str.w	r6, [r3, #144]	; 0x90
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8003102:	f103 063c 	add.w	r6, r3, #60	; 0x3c
 8003106:	9201      	str	r2, [sp, #4]
 8003108:	60de      	str	r6, [r3, #12]
  tp->name              = name;
 800310a:	4e2e      	ldr	r6, [pc, #184]	; (80031c4 <main+0x3b4>)
 800310c:	f8c3 6080 	str.w	r6, [r3, #128]	; 0x80
  qp->next = qp;
 8003110:	f103 0294 	add.w	r2, r3, #148	; 0x94
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8003114:	9e01      	ldr	r6, [sp, #4]
  tp->wabase = tdp->wbase;
 8003116:	492c      	ldr	r1, [pc, #176]	; (80031c8 <main+0x3b8>)
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8003118:	2001      	movs	r0, #1
  qp->prev = qp;
 800311a:	e9c3 2225 	strd	r2, r2, [r3, #148]	; 0x94
  p->prev       = qp->prev;
 800311e:	f103 0c28 	add.w	ip, r3, #40	; 0x28
  p->prev->next = p;
 8003122:	f103 0a74 	add.w	sl, r3, #116	; 0x74
  tp->hdr.pqueue.prio   = prio;
 8003126:	2280      	movs	r2, #128	; 0x80
 8003128:	462f      	mov	r7, r5
 800312a:	f8a3 0088 	strh.w	r0, [r3, #136]	; 0x88
  tp->refs              = (trefs_t)1;
 800312e:	f883 008a 	strb.w	r0, [r3, #138]	; 0x8a
  p->prev       = qp->prev;
 8003132:	f8c3 c078 	str.w	ip, [r3, #120]	; 0x78
 8003136:	e049      	b.n	80031cc <main+0x3bc>
 8003138:	e000e100 	.word	0xe000e100
 800313c:	20000968 	.word	0x20000968
 8003140:	20000888 	.word	0x20000888
 8003144:	40000400 	.word	0x40000400
 8003148:	20000c64 	.word	0x20000c64
 800314c:	200008a8 	.word	0x200008a8
 8003150:	20000c84 	.word	0x20000c84
 8003154:	080034a4 	.word	0x080034a4
 8003158:	20000908 	.word	0x20000908
 800315c:	08000511 	.word	0x08000511
 8003160:	20000858 	.word	0x20000858
 8003164:	0a21fe80 	.word	0x0a21fe80
 8003168:	40013800 	.word	0x40013800
 800316c:	080034cc 	.word	0x080034cc
 8003170:	20000c74 	.word	0x20000c74
 8003174:	20000c94 	.word	0x20000c94
 8003178:	40021000 	.word	0x40021000
 800317c:	08000521 	.word	0x08000521
 8003180:	40004400 	.word	0x40004400
 8003184:	40008000 	.word	0x40008000
 8003188:	0510ff40 	.word	0x0510ff40
 800318c:	20000c38 	.word	0x20000c38
 8003190:	e0042000 	.word	0xe0042000
 8003194:	20000c44 	.word	0x20000c44
 8003198:	20000be8 	.word	0x20000be8
 800319c:	20000c30 	.word	0x20000c30
 80031a0:	08000611 	.word	0x08000611
 80031a4:	200010c8 	.word	0x200010c8
 80031a8:	20020000 	.word	0x20020000
 80031ac:	20000a68 	.word	0x20000a68
 80031b0:	080005d1 	.word	0x080005d1
 80031b4:	080033e4 	.word	0x080033e4
 80031b8:	e000ed00 	.word	0xe000ed00
 80031bc:	05fa0300 	.word	0x05fa0300
 80031c0:	e0001000 	.word	0xe0001000
 80031c4:	080033f8 	.word	0x080033f8
 80031c8:	20000b18 	.word	0x20000b18
  p->prev->next = p;
 80031cc:	f8c3 a028 	str.w	sl, [r3, #40]	; 0x28
  tp->hdr.pqueue.prio   = prio;
 80031d0:	645a      	str	r2, [r3, #68]	; 0x44
  tp->realprio          = prio;
 80031d2:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
 80031d6:	e9c3 6708 	strd	r6, r7, [r3, #32]

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 80031da:	f04f 0602 	mov.w	r6, #2
 80031de:	f888 6000 	strb.w	r6, [r8]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80031e2:	f101 0640 	add.w	r6, r1, #64	; 0x40
 80031e6:	66ce      	str	r6, [r1, #108]	; 0x6c
 80031e8:	4e2a      	ldr	r6, [pc, #168]	; (8003294 <main+0x484>)
 80031ea:	674e      	str	r6, [r1, #116]	; 0x74
 80031ec:	f06f 0602 	mvn.w	r6, #2
 80031f0:	f8c1 6094 	str.w	r6, [r1, #148]	; 0x94
 80031f4:	4e28      	ldr	r6, [pc, #160]	; (8003298 <main+0x488>)
 80031f6:	658e      	str	r6, [r1, #88]	; 0x58
 80031f8:	f04f 7680 	mov.w	r6, #16777216	; 0x1000000
 80031fc:	65ce      	str	r6, [r1, #92]	; 0x5c
  tp->name              = name;
 80031fe:	4e27      	ldr	r6, [pc, #156]	; (800329c <main+0x48c>)
 8003200:	f8c1 60a4 	str.w	r6, [r1, #164]	; 0xa4
 8003204:	f101 0b98 	add.w	fp, r1, #152	; 0x98
  qp->next = qp;
 8003208:	f101 09b8 	add.w	r9, r1, #184	; 0xb8
  p->prev->next = p;
 800320c:	f101 0e60 	add.w	lr, r1, #96	; 0x60
  lp->next = lp;
 8003210:	f101 06b4 	add.w	r6, r1, #180	; 0xb4
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
 8003214:	f8c3 50ac 	str.w	r5, [r3, #172]	; 0xac
  tp->wabase = tdp->wbase;
 8003218:	f8c1 10a8 	str.w	r1, [r1, #168]	; 0xa8
  p->prev       = qp->prev;
 800321c:	e9c1 ca26 	strd	ip, sl, [r1, #152]	; 0x98
  lp->next = lp;
 8003220:	f8c1 60b4 	str.w	r6, [r1, #180]	; 0xb4
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003224:	670c      	str	r4, [r1, #112]	; 0x70
 8003226:	678d      	str	r5, [r1, #120]	; 0x78
  tp->hdr.pqueue.prio   = prio;
 8003228:	6688      	str	r0, [r1, #104]	; 0x68
  tp->owner             = oip;
 800322a:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
  tp->realprio          = prio;
 800322e:	f8c1 00c8 	str.w	r0, [r1, #200]	; 0xc8
  tp->refs              = (trefs_t)1;
 8003232:	f881 00ae 	strb.w	r0, [r1, #174]	; 0xae
  tp->epending          = (eventmask_t)0;
 8003236:	e9c1 5530 	strd	r5, r5, [r1, #192]	; 0xc0
  p->prev->next = p;
 800323a:	f8c3 b074 	str.w	fp, [r3, #116]	; 0x74
  qp->prev      = p;
 800323e:	f8c3 b02c 	str.w	fp, [r3, #44]	; 0x2c
  qp->prev = qp;
 8003242:	e9c1 992e 	strd	r9, r9, [r1, #184]	; 0xb8
  tp->state = CH_STATE_READY;
 8003246:	f8a1 50ac 	strh.w	r5, [r1, #172]	; 0xac
  p->prev       = pqp->prev;
 800324a:	e9c1 3318 	strd	r3, r3, [r1, #96]	; 0x60
  pqp->prev     = p;
 800324e:	e9c3 ee00 	strd	lr, lr, [r3]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003252:	f385 8811 	msr	BASEPRI, r5

  halInit();
  chSysInit();

  chThdCreateStatic(waSerial, sizeof(waSerial), NORMALPRIO, thdSerial,NULL);
 8003256:	4b12      	ldr	r3, [pc, #72]	; (80032a0 <main+0x490>)
 8003258:	4812      	ldr	r0, [pc, #72]	; (80032a4 <main+0x494>)
 800325a:	f44f 71c8 	mov.w	r1, #400	; 0x190
 800325e:	f7fe f9df 	bl	8001620 <chThdCreateStatic.constprop.0.isra.0>
  chThdCreateStatic(waPWM, sizeof(waPWM), NORMALPRIO - 1, thdPWM,NULL);
 8003262:	4b11      	ldr	r3, [pc, #68]	; (80032a8 <main+0x498>)
 8003264:	4811      	ldr	r0, [pc, #68]	; (80032ac <main+0x49c>)
 8003266:	227f      	movs	r2, #127	; 0x7f
 8003268:	f44f 7124 	mov.w	r1, #656	; 0x290
 800326c:	f7fe f9d8 	bl	8001620 <chThdCreateStatic.constprop.0.isra.0>



  while (true) {
    palToggleLine(LINE_LED_GREEN);
 8003270:	f04f 4590 	mov.w	r5, #1207959552	; 0x48000000
 8003274:	696b      	ldr	r3, [r5, #20]
 8003276:	f083 0320 	eor.w	r3, r3, #32
 800327a:	616b      	str	r3, [r5, #20]
 800327c:	f384 8811 	msr	BASEPRI, r4
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8003280:	f241 3188 	movw	r1, #5000	; 0x1388
 8003284:	2008      	movs	r0, #8
 8003286:	f7fd fc8b 	bl	8000ba0 <chSchGoSleepTimeoutS>
 800328a:	2300      	movs	r3, #0
 800328c:	f383 8811 	msr	BASEPRI, r3
 8003290:	e7f0      	b.n	8003274 <main+0x464>
 8003292:	bf00      	nop
 8003294:	08000561 	.word	0x08000561
 8003298:	0800030d 	.word	0x0800030d
 800329c:	080033d8 	.word	0x080033d8
 80032a0:	08001d91 	.word	0x08001d91
 80032a4:	20000f38 	.word	0x20000f38
 80032a8:	08001181 	.word	0x08001181
 80032ac:	20000ca8 	.word	0x20000ca8

080032b0 <memset>:
 80032b0:	0783      	lsls	r3, r0, #30
 80032b2:	b530      	push	{r4, r5, lr}
 80032b4:	d048      	beq.n	8003348 <memset+0x98>
 80032b6:	1e54      	subs	r4, r2, #1
 80032b8:	2a00      	cmp	r2, #0
 80032ba:	d03f      	beq.n	800333c <memset+0x8c>
 80032bc:	b2ca      	uxtb	r2, r1
 80032be:	4603      	mov	r3, r0
 80032c0:	e001      	b.n	80032c6 <memset+0x16>
 80032c2:	3c01      	subs	r4, #1
 80032c4:	d33a      	bcc.n	800333c <memset+0x8c>
 80032c6:	f803 2b01 	strb.w	r2, [r3], #1
 80032ca:	079d      	lsls	r5, r3, #30
 80032cc:	d1f9      	bne.n	80032c2 <memset+0x12>
 80032ce:	2c03      	cmp	r4, #3
 80032d0:	d92d      	bls.n	800332e <memset+0x7e>
 80032d2:	b2cd      	uxtb	r5, r1
 80032d4:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80032d8:	2c0f      	cmp	r4, #15
 80032da:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80032de:	d936      	bls.n	800334e <memset+0x9e>
 80032e0:	f1a4 0210 	sub.w	r2, r4, #16
 80032e4:	f022 0c0f 	bic.w	ip, r2, #15
 80032e8:	f103 0e20 	add.w	lr, r3, #32
 80032ec:	44e6      	add	lr, ip
 80032ee:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 80032f2:	f103 0210 	add.w	r2, r3, #16
 80032f6:	e942 5504 	strd	r5, r5, [r2, #-16]
 80032fa:	e942 5502 	strd	r5, r5, [r2, #-8]
 80032fe:	3210      	adds	r2, #16
 8003300:	4572      	cmp	r2, lr
 8003302:	d1f8      	bne.n	80032f6 <memset+0x46>
 8003304:	f10c 0201 	add.w	r2, ip, #1
 8003308:	f014 0f0c 	tst.w	r4, #12
 800330c:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 8003310:	f004 0c0f 	and.w	ip, r4, #15
 8003314:	d013      	beq.n	800333e <memset+0x8e>
 8003316:	f1ac 0304 	sub.w	r3, ip, #4
 800331a:	f023 0303 	bic.w	r3, r3, #3
 800331e:	3304      	adds	r3, #4
 8003320:	4413      	add	r3, r2
 8003322:	f842 5b04 	str.w	r5, [r2], #4
 8003326:	4293      	cmp	r3, r2
 8003328:	d1fb      	bne.n	8003322 <memset+0x72>
 800332a:	f00c 0403 	and.w	r4, ip, #3
 800332e:	b12c      	cbz	r4, 800333c <memset+0x8c>
 8003330:	b2c9      	uxtb	r1, r1
 8003332:	441c      	add	r4, r3
 8003334:	f803 1b01 	strb.w	r1, [r3], #1
 8003338:	429c      	cmp	r4, r3
 800333a:	d1fb      	bne.n	8003334 <memset+0x84>
 800333c:	bd30      	pop	{r4, r5, pc}
 800333e:	4664      	mov	r4, ip
 8003340:	4613      	mov	r3, r2
 8003342:	2c00      	cmp	r4, #0
 8003344:	d1f4      	bne.n	8003330 <memset+0x80>
 8003346:	e7f9      	b.n	800333c <memset+0x8c>
 8003348:	4603      	mov	r3, r0
 800334a:	4614      	mov	r4, r2
 800334c:	e7bf      	b.n	80032ce <memset+0x1e>
 800334e:	461a      	mov	r2, r3
 8003350:	46a4      	mov	ip, r4
 8003352:	e7e0      	b.n	8003316 <memset+0x66>
